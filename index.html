
<!DOCTYPE html>
<html>
<head>
	<meta name="google-site-verification" content="2vZoEN7S-HFJccciVeuzqshqXBzAhGQ9Z6BoRZPKyWo" />
	<link rel="shortcut icon" type="image/x-icon" href="https://images.squarespace-cdn.com/content/v1/614d25eef23cd4531ac44bab/69fb0e66-8045-42e1-a24d-7aa0f53fc89d/favicon.ico"/>
<title>ULC</title>
	<script>
		// DOMSanitizer.

// Links:
// Github: https://github.com/ptresearch/DOMSanitizer

/* global acorn: false, DOMPurify: false, window: false, module: false, define: false */
(function(factory) {
    'use strict';
    var root = typeof window === 'undefined' ? null : window;
    if (typeof define === 'function' && define.amd) {
        define(function() {
            return factory(root);
        });
    } else if (typeof module !== 'undefined') {
        module.exports = factory(root);
    } else {
        root.DOMSanitizer = factory(root);
    }
}(function factory(window) {
    'use strict';

    var DOMSanitizer = function(window) {
        return factory(window);
    };

    DOMSanitizer.version = '0.1.0';

    if (!window || !window.document || window.document.nodeType !== 9 || !acorn || !DOMPurify || !DOMPurify.isSupported) {
        DOMSanitizer.isSupported = false;
        return DOMSanitizer;
    } else {
        DOMSanitizer.isSupported = true;
    }

    var document = window.document;
    var implementation = document.implementation;
    var getElementsByTagName = document.getElementsByTagName;
    var useDOMParser = false;

    
    /* DOMPurify's function to create a config set. */
    var _addToSet = function(set, array) {
        var l = array.length;
        while (l--) {
            set[array[l]] = true;
        }
        return set;
    };

    /* Returned value if injection was found. */
    var CLEAN = '';
    
    /* Default contexts. */
    var DEFAULT_CONTEXTS = ['callback', 'url', 'attr', 'js', 'dom'];

    /* Enabled contexts. */
    var CONTEXTS = null;

    /* Output should be safe for jQuery's $() factory. */
    var SAFE_FOR_JQUERY = true;

    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB.
     */
    var SAFE_FOR_TEMPLATES = true;

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false;

    /* Decide if document with <html>... should be returned in DOMPurify. */
    var WHOLE_DOCUMENT = true;
    
    /* Forbidden AST node types of ESTree */
    var FORBIDDEN_AST_NODES = _addToSet({}, [
        'ArrayPattern', 'ArrowFunctionExpression', 'AssignmentExpression', 'CallExpression',
        'ExportAllDeclaration', 'ExportDefaultDeclaration', 'ExportNamedDeclaration', 'ExportSpecifier',
        'ForOfStatement', 'ForInStatement', 'FunctionDeclaration', 'FunctionExpression',
        'ImportDeclaration', 'ImportDefaultSpecifier', 'ImportNamespaceSpecifier', 'ImportSpecifier',
        'NewExpression', 'ObjectPattern', 'SpreadElement', 'TaggedTemplateExpression',
        'VariableDeclaration', 'WithStatement', 'YieldExpression'
    ]);

    /* Config parsing. */
    var _parseConfig = function(cfg) {
        if (typeof cfg !== 'object') {
            cfg = {};
        }
        // Default true
        SAFE_FOR_JQUERY         = cfg.SAFE_FOR_JQUERY         !== false;
        // Default true
        SAFE_FOR_TEMPLATES      = cfg.SAFE_FOR_TEMPLATES      !== false;
        // Default true
        WHOLE_DOCUMENT          = cfg.WHOLE_DOCUMENT          !== false;
        // Default false
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;

        CONTEXTS = _addToSet({}, cfg.CONTEXTS || DEFAULT_CONTEXTS);
    };

    /* Access to 'obj' via 'path' for writing or reading */
    var _accessByString = function(obj, path, value) {
        path = path.replace(/\[(\w+)\]/g, '.$1');
        path = path.replace(/^\./, '');
        path = path.replace(/\.$/, '');
        var o = obj;
        var pList = path.split('.');
        var len = pList.length;
        for (var i = 0; i < len - 1; i++) {
            var elem = pList[i];
            if (o && elem in o) {
                o = o[elem];
            } else {
                return;
            }
        }
        if (arguments.length === 3) {
            o[pList[len - 1]] = value;
        }
        return o[pList[len - 1]];
    };

    /* Check if an input is JSON */
    var _isJSON = function(s) {
        try {
            var json = JSON.parse(s);
            if (typeof json !== 'object') {
                return false;
            } else {
                return true;
            }
        } catch(e) {
            return false;
        }
    };

    /*
     * _initDocument
     *
     * DOMPurify's implementation to build a HTML document.
     *
     * @param  a string of dirty markup
     * @return a DOM, filled with the dirty markup
     */
    var _initDocument = function(dirty) {
        /* Create a HTML document */
        var doc, body;

        /* Use DOMParser to workaround Firefox bug (see comment below) */
        if (useDOMParser) {
            try {
                doc = new DOMParser().parseFromString(dirty, 'text/html');
            } catch (e) {}
        }

        /* Otherwise use createHTMLDocument, because DOMParser is unsafe in
           Safari (see comment below) */
        if (!doc || !doc.documentElement) {
            doc = implementation.createHTMLDocument('');
            body = doc.body;
            body.parentNode.removeChild(body.parentNode.firstElementChild);
            body.outerHTML = dirty;
        }

        /* Work on whole document or just its body */
        return doc;
    };

    if (DOMPurify.isSupported) {
        (function() {
            var doc = _initDocument('<svg><p><style><img src="</style><img src=x onerror=alert(1)//">');
            if (doc.getElementsByTagName('img')[0].hasAttribute('onerror')) {
                useDOMParser = true;
            }
        }());
    }

    /*
     *  Input normalization funtion.
     *  It supports html entities, octal, hex, and unicode decodings.
     *
     *  @param {string} s - input string.
     *  @return {string} normalized input.
     */
    var _normalizeInput = function(s) {
        var tmp;
        var textArea = document.createElement('textarea');
        do {
            tmp = s;
            textArea.innerHTML = s;
            s = textArea.value;
            try {
                s = decodeURIComponent(s);
            } catch (e) {}
        } while (tmp !== s);
        s = s.replace(/(?:\r\n|\n|\r|\t)/g, '');
        return s;
    };
    
    /* JavaScript tokenizer. */
    var _getJSTokens = function(s) {
        if (s === '') {
            return [''];
        }
        var re = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|((?:0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?))|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]{1,6}\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-*\/%&|^]|<{1,2}|>{1,3}|!=?|={1,2})=?|[?:~]|[;,.[\](){}])|(\s+)|(^$|[\s\S])/g;
        var tokens = [];
        var match;
        while ((match = re.exec(s)) != null) {
            tokens.push(match[0]);
        }
        return tokens;
    };
  
    /*
     *  _isJSInjection
     *
     *  @param {string} s - an input string.
     *  @return {boolean} Returns true if input can be parsed and its AST contains dangerous ECMAScript code, otherwise returns false.
     */
    var _isJSInjection = function(s, options) {
        if (typeof options !== 'object') {
            options = {};
        }
        var parseOnce = options.parseOnce || false;
        var forbidden = FORBIDDEN_AST_NODES;
        var ctx, tokens, curToken;
        var isInjection = false;

        /* Define extension for Acorn's function. */
        var checkPolicy = function(node, type) {
            if(forbidden[type]) {
                // Pass expressions like 'a=1' to reduce false positive,
                // but handles expression like 'window.foo = 1', '[window.foo]=1', 'foo = alert(1)', 'foo = function foo(){}'

                // We can not see 'ArrayPattern' node in 'finishNode' function.
                // We see this node as 'ArryExpression' that will be transformed to 'ArrayPattern' in Acorn later.
                if (type === 'AssignmentExpression') {
                    if (node.left.type === 'MemberExpression'  ||
                            node.left.type === 'ArrayPattern'  ||
                            node.left.type === 'ObjectPattern' ||
                            node.left.name === 'location') {
                        isInjection = true;
                        return;
                    }
                    if (node.right.type === 'FunctionExpression' ||
                            node.right.type === 'CallExpression' ||
                            node.right.type === 'MemberExpression') {
                        isInjection = true;
                        return;
                    }
                } else {
                    isInjection = true;
                    return;
                }
            }
        };

        /* Extend default Acorn's methods. */
        acorn.plugins.wafjs = function(parser) {
            parser.extend('finishNode', function(nextMethod) {
                return function(node, type) {
                    checkPolicy(node, type);
                    return nextMethod.call(this, node, type);
                };
            });

            parser.extend('finishNodeAt', function(nextMethod) {
                return function(node, type, pos, loc) {
                    checkPolicy(node, type);
                    return nextMethod.call(this, node, type, pos, loc);
                };
            });
        };
        
        ctx = s;
        // List of tokens.
        tokens = _getJSTokens(ctx);
        // Hard tokens, that can be deleted from string without parsing.
        var hardTokens = ['}', ')', '.', '*', '/'];
        curToken = 0;
        do {
            if (hardTokens.indexOf(ctx[0]) === -1) {
                try {
                    acorn.parse(ctx, {ecmaVersion: 6, allowImportExportEverywhere: true, allowReserved: true, plugins: {wafjs: true}});
                } catch(e) {}
                if (isInjection) {
                    return true;
                }
            }
            // Delete the next token from the context string.
            ctx = ctx.substring(tokens[curToken].length);
            curToken += 1;
        } while(ctx.length > 0 && !parseOnce);
        return false;
    };

    /*
     *  _isJSInjectionInAttr
     *
     *  @param {string} s - an input string.
     *  @return {boolean} Returns true if on* attribute value can be parsed and its AST contains dangerous ECMAScript code, otherwise returns false.
     */
    var _isJSInjectionInAttr = function(s) {
        var doc, body, attributes, name, l, children;
        var value;
        doc = _initDocument(s);
        body = getElementsByTagName.call(doc, 'body')[0];
        children = body.children;
        // In normal case the body should have only 1 child.
        if (children.length !== 1) {
            return true;
        }
        attributes = body.childNodes[0].attributes;
        l = attributes.length;
        while (l--) {
            name = attributes[l].name.toLowerCase();
            if (/^on[a-z]{3,35}/.test(name)) {
                value = attributes[l].value;
                if (_isJSInjection(value, {parseOnce: true})) {
                    return true;
                }
                
                
            }
        }
        return false;
    };

    var _sanitize = Object.create({});

    /*
     *  Sanitization in Callback context.
     *
     *  @param {string} s - input string
     *  @return {string} If s does not contain a valid in DOM function name, returns original string s, otherwise returns empty string.
     */
    _sanitize.callback = function(s) {
        if (typeof _accessByString(window, s) === 'function') {
            return CLEAN;
        }
        return s;
    };

    /*
     * Basic sanitization for URL context.
     * It is hard to imlement full protection here because of peculiarities of data URI parsing in different browsers.
     * See http://blog.kotowicz.net/2012/04/fun-with-data-urls.html
     *     https://github.com/mauro-g/snuck/blob/master/payloads/uri_payloads
     *
     *  @param {string} s - input string.
     *  @return {string} If s does not contain JavaScript patterns, returns original string s, otherwise returns empty string.
     */
    _sanitize.url = function(s) {
        if (s.indexOf(':') === -1) {
            return s;
        }
        var re = /(?:(?:java|vb|j)script:|data:\W*(?:(?:text\/(?:html|xml)|image\/svg\+xml|application\/(?:xml|xhtml\+xml)):?\s*(?:;[\n\t\r ,;]?base64[^\,]*)?,?|,))/i;
        if (re.test(s)) {
            return CLEAN;
        }
        return s;
    };

    /*
     *  Sanitization in JavaScript context.
     *
     *  @param {string} s - an input string.
     *  @return {string} If s does not contain JavaScript patterns, returns original string s, otherwise returns empty string.
     */
    _sanitize.js = function(s) {
        if (!(/['"\=\;\(\)\[\]\{\}\.\`]|(?:export)|(?:import)/.test(s))) {
            return s;
        }
        // Injection index - character after that injected code starts
        var index;

        // "Single quote" context
        index = s.indexOf('\'');
        if (index !== -1 && _isJSInjection(s.slice(index + 1))) {
            return CLEAN;
        }
        // "Double quote" context
        index = s.indexOf('"');
        if (index !== -1 && _isJSInjection(s.slice(index + 1))) {
            return CLEAN;
        }
        // "as-is" context
        if (_isJSInjection(s)) {
            return CLEAN;
        }
        return s;
    };

    /*
     *  Sanitization in HTML/DOM context.
     *
     *  @param {string} s - input string.
     *  @return {string[]} If s does not contain dangerous HTML, returns original string s, overwise returns empty string.
     */
    _sanitize.dom = function(s) {
        /*
         * Add hook to sanitize external protocols (e.g., http, https, ftp, ftps, tel, mailto) as DOMPurify allows them by default.
         * This hook changes scheme in address, thus violating policy.
         */
        DOMPurify.addHook('uponSanitizeAttribute', function(node, data) {
            if (data.attrName === 'href' || data.attrName === 'xlink:href' || data.attrName === 'action') {
                data.attrValue = 'schema://name#';
            }
        });
       /*
        * 'WHOLE_DOCUMENT' should be set to true. The reason is the following:
        * '<script>alert(1)</script>' input will be parsed to
        * '<html><head><script>alert(1)></script></head><body></body></html>'. If 'WHOLE_DOCUMENT' is false
        * then input will be sanitized, bit DOMPurify.removed[] will not contain deleted <script> node.
        *
        * 'SAFE_FOR_TEMPLATES' and 'SAFE_FOR_JQUERY' should be set to true to sanitize data for templates systems and jQuery
        */
        DOMPurify.sanitize(s, {
            WHOLE_DOCUMENT: WHOLE_DOCUMENT,
            SAFE_FOR_TEMPLATES: SAFE_FOR_TEMPLATES,
            SAFE_FOR_JQUERY: SAFE_FOR_JQUERY,
            ALLOW_UNKNOWN_PROTOCOLS: ALLOW_UNKNOWN_PROTOCOLS
        });

        var removed = DOMPurify.removed;
        var removedNode = removed.pop();

        // Process a false positive due to SAFE_TEMPLATES mode if input is JSON.
        // See https://github.com/cure53/DOMPurify/issues/181.
        var inputIsValidJSON = removedNode &&
                removed.length === 0 &&
                'element' in removedNode &&
                removedNode.element.nodeType === 3 &&
                _isJSON(removedNode.element.nodeValue);

        // If DOMPurify has removed a node (DOMPurify.removed.length > 0) then input is dangerous.
        var inputIsDangerous = Boolean(removedNode);

        // Return original s, if input is valid JSON.
        if (inputIsValidJSON) {
            return s;
        }

        // Return clean, if a dangerous HTML was found in input.
        if (inputIsDangerous) {
            return CLEAN;
        }
        return s;
    };

    /*
     *  Sanitization in attribute-based context.
     *
     *  @param {string} s - input string.
     *  @return {string} If s does not contain dangerous JavaScript, returns original string s, overwise returns empty string.
     */
    _sanitize.attr =  function(s) {
        if (!(/['"\=\;\(\)\[\]\{\}\.\`]|(?:export)|(?:import)/.test(s))) {
            return s;
        }
        /*  $ - injection point, {} - injection's edges.
            Example: <img src='$'> -> <img src='{1' onerror='alert(1)}'>.
            Here we create a fake HTML documents based on user's input and find event handlers inside its markup.
            It is injection if on* attribute value is valid JS and contains dangerous JS.

            It is possible to use the following polyglot vector, but tests showed that performance is little changed:
            image = '<img bar="' + s + '"' + ' baz=\'' + s + '\'' +  ' bam=1 ' + s + ' >';
        */
       
        var image;
       
        image = '<img foo="' + s + '" >';
        if (_isJSInjectionInAttr(image)) {
            return CLEAN;
        }
        image = '<img bar=\'' + s +  '\' >';
        if (_isJSInjectionInAttr(image)) {
            return CLEAN;
        }
        image = '<img baz=1 ' + s + ' >';
        if (_isJSInjectionInAttr(image)) {
            return CLEAN;
        }
        
        if (_isJSInjection(s, {parseOnce: true})) {
            return CLEAN;
        }

        return s;
    };

    /*
     *  InjectionContext
     *
     *  @param {string} input - original input string.
     *  @param {string} normalizedInput - normalized input string.
     *  @param {Array} contexts - contexts, where injection was detected.
     */

    function InjectionContext(input, normalizedInput, contexts) {
        this.isInjection = true;
        this.contexts = contexts;
        this.input = input;
        this.normalizedInput = normalizedInput;
    }
    
    /*
     *  isInjection
     *
     *  @param {string} dirty     - input string.
     *  @param {object} options   - configuration object
     *
     *  @return {boolean} `true` if a dirty is injection.
     */
    DOMSanitizer.isInjection = function(dirty, cfg) {
        if (dirty === '') {
            return false;
        }
        if (typeof cfg !== 'object') {
            cfg = {};
        }
        _parseConfig(cfg);
        var normalized = _normalizeInput(dirty);
        var ctx, lctx;
        // eslint-disable-next-line guard-for-in
        for (ctx in CONTEXTS) {
            lctx = ctx.toLowerCase();
            if (lctx in _sanitize && !_sanitize[lctx](normalized)) {
                return true;
            }
        }
        return false;
    };

    /*
     *  getInjectionContext
     *
     *  @param {string} dirty - input string.
     *  @param {object} options - configuration object
     *
     *  @return {InjectionContext|null} The `InjectionContext` object, or `null` if there is no injection.
     */
    DOMSanitizer.getInjectionContext = function(dirty, cfg) {
        if (dirty === '') {
            return null;
        }
        if (typeof cfg !== 'object') {
            cfg = {};
        }
        _parseConfig(cfg);
        var normalized = _normalizeInput(dirty);
        var ctx, lctx;
        var raisedContexts = [];
        // eslint-disable-next-line guard-for-in
        for (ctx in CONTEXTS) {
            lctx = ctx.toLowerCase();
            if (lctx in _sanitize && !_sanitize[lctx](normalized)) {
                raisedContexts.push(lctx);
            }
        }
        if (raisedContexts.length > 0) {
            return new InjectionContext(dirty, normalized, raisedContexts);
        } else {
            return false;
        }
    };

    /*
     *  normalize.
     *  It supports html entities, octal, hex, and unicode decodings.
     *
     *  @param {string} s - input string.
     *
     *  @return {string} normalizad input.
     */
    DOMSanitizer.normalize = _normalizeInput;

    return DOMSanitizer;
}));
	</script>
	<script>
		'use strict';

var ip = exports;
var Buffer = require('buffer').Buffer;
var os = require('os');

ip.toBuffer = function(ip, buff, offset) {
  offset = ~~offset;

  var result;

  if (this.isV4Format(ip)) {
    result = buff || new Buffer(offset + 4);
    ip.split(/\./g).map(function(byte) {
      result[offset++] = parseInt(byte, 10) & 0xff;
    });
  } else if (this.isV6Format(ip)) {
    var sections = ip.split(':', 8);

    var i;
    for (i = 0; i < sections.length; i++) {
      var isv4 = this.isV4Format(sections[i]);
      var v4Buffer;

      if (isv4) {
        v4Buffer = this.toBuffer(sections[i]);
        sections[i] = v4Buffer.slice(0, 2).toString('hex');
      }

      if (v4Buffer && ++i < 8) {
        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));
      }
    }

    if (sections[0] === '') {
      while (sections.length < 8) sections.unshift('0');
    } else if (sections[sections.length - 1] === '') {
      while (sections.length < 8) sections.push('0');
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ''; i++);
      var argv = [ i, 1 ];
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push('0');
      }
      sections.splice.apply(sections, argv);
    }

    result = buff || new Buffer(offset + 16);
    for (i = 0; i < sections.length; i++) {
      var word = parseInt(sections[i], 16);
      result[offset++] = (word >> 8) & 0xff;
      result[offset++] = word & 0xff;
    }
  }

  if (!result) {
    throw Error('Invalid ip address: ' + ip);
  }

  return result;
};

ip.toString = function(buff, offset, length) {
  offset = ~~offset;
  length = length || (buff.length - offset);

  var result = [];
  if (length === 4) {
    // IPv4
    for (var i = 0; i < length; i++) {
      result.push(buff[offset + i]);
    }
    result = result.join('.');
  } else if (length === 16) {
    // IPv6
    for (var i = 0; i < length; i += 2) {
      result.push(buff.readUInt16BE(offset + i).toString(16));
    }
    result = result.join(':');
    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');
    result = result.replace(/:{3,4}/, '::');
  }

  return result;
};

var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
var ipv6Regex =
    /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;

ip.isV4Format = function(ip) {
  return ipv4Regex.test(ip);
};

ip.isV6Format = function(ip) {
  return ipv6Regex.test(ip);
};
function _normalizeFamily(family) {
  return family ? family.toLowerCase() : 'ipv4';
}

ip.fromPrefixLen = function(prefixlen, family) {
  if (prefixlen > 32) {
    family = 'ipv6';
  } else {
    family = _normalizeFamily(family);
  }

  var len = 4;
  if (family === 'ipv6') {
    len = 16;
  }
  var buff = new Buffer(len);

  for (var i = 0, n = buff.length; i < n; ++i) {
    var bits = 8;
    if (prefixlen < 8) {
      bits = prefixlen;
    }
    prefixlen -= bits;

    buff[i] = ~(0xff >> bits) & 0xff;
  }

  return ip.toString(buff);
};

ip.mask = function(addr, mask) {
  addr = ip.toBuffer(addr);
  mask = ip.toBuffer(mask);

  var result = new Buffer(Math.max(addr.length, mask.length));

  var i = 0;
  // Same protocol - do bitwise and
  if (addr.length === mask.length) {
    for (i = 0; i < addr.length; i++) {
      result[i] = addr[i] & mask[i];
    }
  } else if (mask.length === 4) {
    // IPv6 address and IPv4 mask
    // (Mask low bits)
    for (i = 0; i < mask.length; i++) {
      result[i] = addr[addr.length - 4  + i] & mask[i];
    }
  } else {
    // IPv6 mask and IPv4 addr
    for (var i = 0; i < result.length - 6; i++) {
      result[i] = 0;
    }

    // ::ffff:ipv4
    result[10] = 0xff;
    result[11] = 0xff;
    for (i = 0; i < addr.length; i++) {
      result[i + 12] = addr[i] & mask[i + 12];
    }
    i = i + 12;
  }
  for (; i < result.length; i++)
    result[i] = 0;

  return ip.toString(result);
};

ip.cidr = function(cidrString) {
  var cidrParts = cidrString.split('/');

  var addr = cidrParts[0];
  if (cidrParts.length !== 2)
    throw new Error('invalid CIDR subnet: ' + addr);

  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

  return ip.mask(addr, mask);
};

ip.subnet = function(addr, mask) {
  var networkAddress = ip.toLong(ip.mask(addr, mask));

  // Calculate the mask's length.
  var maskBuffer = ip.toBuffer(mask);
  var maskLength = 0;

  for (var i = 0; i < maskBuffer.length; i++) {
    if (maskBuffer[i] === 0xff) {
      maskLength += 8;
    } else {
      var octet = maskBuffer[i] & 0xff;
      while (octet) {
        octet = (octet << 1) & 0xff;
        maskLength++;
      }
    }
  }

  var numberOfAddresses = Math.pow(2, 32 - maskLength);

  return {
    networkAddress: ip.fromLong(networkAddress),
    firstAddress: numberOfAddresses <= 2 ?
                    ip.fromLong(networkAddress) :
                    ip.fromLong(networkAddress + 1),
    lastAddress: numberOfAddresses <= 2 ?
                    ip.fromLong(networkAddress + numberOfAddresses - 1) :
                    ip.fromLong(networkAddress + numberOfAddresses - 2),
    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
    subnetMask: mask,
    subnetMaskLength: maskLength,
    numHosts: numberOfAddresses <= 2 ?
                numberOfAddresses : numberOfAddresses - 2,
    length: numberOfAddresses,
    contains: function(other) {
      return networkAddress === ip.toLong(ip.mask(other, mask));
    }
  };
};

ip.cidrSubnet = function(cidrString) {
  var cidrParts = cidrString.split('/');

  var addr = cidrParts[0];
  if (cidrParts.length !== 2)
    throw new Error('invalid CIDR subnet: ' + addr);

  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

  return ip.subnet(addr, mask);
};

ip.not = function(addr) {
  var buff = ip.toBuffer(addr);
  for (var i = 0; i < buff.length; i++) {
    buff[i] = 0xff ^ buff[i];
  }
  return ip.toString(buff);
};

ip.or = function(a, b) {
  a = ip.toBuffer(a);
  b = ip.toBuffer(b);

  // same protocol
  if (a.length === b.length) {
    for (var i = 0; i < a.length; ++i) {
      a[i] |= b[i];
    }
    return ip.toString(a);

  // mixed protocols
  } else {
    var buff = a;
    var other = b;
    if (b.length > a.length) {
      buff = b;
      other = a;
    }

    var offset = buff.length - other.length;
    for (var i = offset; i < buff.length; ++i) {
      buff[i] |= other[i - offset];
    }

    return ip.toString(buff);
  }
};

ip.isEqual = function(a, b) {
  a = ip.toBuffer(a);
  b = ip.toBuffer(b);

  // Same protocol
  if (a.length === b.length) {
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }

  // Swap
  if (b.length === 4) {
    var t = b;
    b = a;
    a = t;
  }

  // a - IPv4, b - IPv6
  for (var i = 0; i < 10; i++) {
    if (b[i] !== 0) return false;
  }

  var word = b.readUInt16BE(10);
  if (word !== 0 && word !== 0xffff) return false;

  for (var i = 0; i < 4; i++) {
    if (a[i] !== b[i + 12]) return false;
  }

  return true;
};

ip.isPrivate = function(addr) {
  return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i
      .test(addr) ||
    /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i
      .test(addr) ||
    /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^f[cd][0-9a-f]{2}:/i.test(addr) ||
    /^fe80:/i.test(addr) ||
    /^::1$/.test(addr) ||
    /^::$/.test(addr);
};

ip.isPublic = function(addr) {
  return !ip.isPrivate(addr);
};

ip.isLoopback = function(addr) {
  return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/
      .test(addr) ||
    /^fe80::1$/.test(addr) ||
    /^::1$/.test(addr) ||
    /^::$/.test(addr);
};

ip.loopback = function(family) {
  //
  // Default to `ipv4`
  //
  family = _normalizeFamily(family);

  if (family !== 'ipv4' && family !== 'ipv6') {
    throw new Error('family must be ipv4 or ipv6');
  }

  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';
};

//
// ### function address (name, family)
// #### @name {string|'public'|'private'} **Optional** Name or security
//      of the network interface.
// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults
//      to ipv4).
//
// Returns the address for the network interface on the current system with
// the specified `name`:
//   * String: First `family` address of the interface.
//             If not found see `undefined`.
//   * 'public': the first public ip address of family.
//   * 'private': the first private ip address of family.
//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.
//
ip.address = function(name, family) {
  var interfaces = os.networkInterfaces();
  var all;

  //
  // Default to `ipv4`
  //
  family = _normalizeFamily(family);

  //
  // If a specific network interface has been named,
  // return the address.
  //
  if (name && name !== 'private' && name !== 'public') {
    var res = interfaces[name].filter(function(details) {
      var itemFamily = details.family.toLowerCase();
      return itemFamily === family;
    });
    if (res.length === 0)
      return undefined;
    return res[0].address;
  }

  var all = Object.keys(interfaces).map(function (nic) {
    //
    // Note: name will only be `public` or `private`
    // when this is called.
    //
    var addresses = interfaces[nic].filter(function (details) {
      details.family = details.family.toLowerCase();
      if (details.family !== family || ip.isLoopback(details.address)) {
        return false;
      } else if (!name) {
        return true;
      }

      return name === 'public' ? ip.isPrivate(details.address) :
          ip.isPublic(details.address);
    });

    return addresses.length ? addresses[0].address : undefined;
  }).filter(Boolean);

  return !all.length ? ip.loopback(family) : all[0];
};

ip.toLong = function(ip) {
  var ipl = 0;
  ip.split('.').forEach(function(octet) {
    ipl <<= 8;
    ipl += parseInt(octet);
  });
  return(ipl >>> 0);
};

ip.fromLong = function(ipl) {
  return ((ipl >>> 24) + '.' +
      (ipl >> 16 & 255) + '.' +
      (ipl >> 8 & 255) + '.' +
      (ipl & 255) );
};
	</script>
	<script>
		'use strict';

var ip = require('..');
var assert = require('assert');
var net = require('net');
var os = require('os');

describe('IP library for node.js', function() {
  describe('toBuffer()/toString() methods', function() {
    it('should convert to buffer IPv4 address', function() {
      var buf = ip.toBuffer('127.0.0.1');
      assert.equal(buf.toString('hex'), '7f000001');
      assert.equal(ip.toString(buf), '127.0.0.1');
    });

    it('should convert to buffer IPv4 address in-place', function() {
      var buf = new Buffer(128);
      var offset = 64;
      ip.toBuffer('127.0.0.1', buf, offset);
      assert.equal(buf.toString('hex', offset, offset + 4), '7f000001');
      assert.equal(ip.toString(buf, offset, 4), '127.0.0.1');
    });

    it('should convert to buffer IPv6 address', function() {
      var buf = ip.toBuffer('::1');
      assert(/(00){15,15}01/.test(buf.toString('hex')));
      assert.equal(ip.toString(buf), '::1');
      assert.equal(ip.toString(ip.toBuffer('1::')), '1::');
      assert.equal(ip.toString(ip.toBuffer('abcd::dcba')), 'abcd::dcba');
    });

    it('should convert to buffer IPv6 address in-place', function() {
      var buf = new Buffer(128);
      var offset = 64;
      ip.toBuffer('::1', buf, offset);
      assert(/(00){15,15}01/.test(buf.toString('hex', offset, offset + 16)));
      assert.equal(ip.toString(buf, offset, 16), '::1');
      assert.equal(ip.toString(ip.toBuffer('1::', buf, offset),
                               offset, 16), '1::');
      assert.equal(ip.toString(ip.toBuffer('abcd::dcba', buf, offset),
                               offset, 16), 'abcd::dcba');
    });

    it('should convert to buffer IPv6 mapped IPv4 address', function() {
      var buf = ip.toBuffer('::ffff:127.0.0.1');
      assert.equal(buf.toString('hex'), '00000000000000000000ffff7f000001');
      assert.equal(ip.toString(buf), '::ffff:7f00:1');

      buf = ip.toBuffer('ffff::127.0.0.1');
      assert.equal(buf.toString('hex'), 'ffff000000000000000000007f000001');
      assert.equal(ip.toString(buf), 'ffff::7f00:1');

      buf = ip.toBuffer('0:0:0:0:0:ffff:127.0.0.1');
      assert.equal(buf.toString('hex'), '00000000000000000000ffff7f000001');
      assert.equal(ip.toString(buf), '::ffff:7f00:1');
    });
  });

  describe('fromPrefixLen() method', function() {
    it('should create IPv4 mask', function() {
      assert.equal(ip.fromPrefixLen(24), '255.255.255.0');
    });
    it('should create IPv6 mask', function() {
      assert.equal(ip.fromPrefixLen(64), 'ffff:ffff:ffff:ffff::');
    });
    it('should create IPv6 mask explicitly', function() {
      assert.equal(ip.fromPrefixLen(24, 'IPV6'), 'ffff:ff00::');
    });
  });

  describe('not() method', function() {
    it('should reverse bits in address', function() {
      assert.equal(ip.not('255.255.255.0'), '0.0.0.255');
    });
  });

  describe('or() method', function() {
    it('should or bits in ipv4 addresses', function() {
      assert.equal(ip.or('0.0.0.255', '192.168.1.10'), '192.168.1.255');
    });
    it('should or bits in ipv6 addresses', function() {
      assert.equal(ip.or('::ff', '::abcd:dcba:abcd:dcba'),
                   '::abcd:dcba:abcd:dcff');
    });
    it('should or bits in mixed addresses', function() {
      assert.equal(ip.or('0.0.0.255', '::abcd:dcba:abcd:dcba'),
                   '::abcd:dcba:abcd:dcff');
    });
  });

  describe('mask() method', function() {
    it('should mask bits in address', function() {
      assert.equal(ip.mask('192.168.1.134', '255.255.255.0'), '192.168.1.0');
      assert.equal(ip.mask('192.168.1.134', '::ffff:ff00'), '::ffff:c0a8:100');
    });

    it('should not leak data', function() {
      for (var i = 0; i < 10; i++)
        assert.equal(ip.mask('::1', '0.0.0.0'), '::');
    });
  });

  describe('subnet() method', function() {
    // Test cases calculated with http://www.subnet-calculator.com/
    var ipv4Subnet = ip.subnet('192.168.1.134', '255.255.255.192');

    it('should compute ipv4 network address', function() {
      assert.equal(ipv4Subnet.networkAddress, '192.168.1.128');
    });

    it('should compute ipv4 network\'s first address', function() {
      assert.equal(ipv4Subnet.firstAddress, '192.168.1.129');
    });

    it('should compute ipv4 network\'s last address', function() {
      assert.equal(ipv4Subnet.lastAddress, '192.168.1.190');
    });

    it('should compute ipv4 broadcast address', function() {
      assert.equal(ipv4Subnet.broadcastAddress, '192.168.1.191');
    });

    it('should compute ipv4 subnet number of addresses', function() {
      assert.equal(ipv4Subnet.length, 64);
    });

    it('should compute ipv4 subnet number of addressable hosts', function() {
      assert.equal(ipv4Subnet.numHosts, 62);
    });

    it('should compute ipv4 subnet mask', function() {
      assert.equal(ipv4Subnet.subnetMask, '255.255.255.192');
    });

    it('should compute ipv4 subnet mask\'s length', function() {
      assert.equal(ipv4Subnet.subnetMaskLength, 26);
    });

    it('should know whether a subnet contains an address', function() {
      assert.equal(ipv4Subnet.contains('192.168.1.180'), true);
    });

    it('should know whether a subnet does not contain an address', function() {
      assert.equal(ipv4Subnet.contains('192.168.1.195'), false);
    });
  });

  describe('subnet() method with mask length 32', function() {
    // Test cases calculated with http://www.subnet-calculator.com/
    var ipv4Subnet = ip.subnet('192.168.1.134', '255.255.255.255');
    it('should compute ipv4 network\'s first address', function() {
      assert.equal(ipv4Subnet.firstAddress, '192.168.1.134');
    });

    it('should compute ipv4 network\'s last address', function() {
      assert.equal(ipv4Subnet.lastAddress, '192.168.1.134');
    });

    it('should compute ipv4 subnet number of addressable hosts', function() {
      assert.equal(ipv4Subnet.numHosts, 1);
    });
  });

  describe('subnet() method with mask length 31', function() {
    // Test cases calculated with http://www.subnet-calculator.com/
    var ipv4Subnet = ip.subnet('192.168.1.134', '255.255.255.254');
    it('should compute ipv4 network\'s first address', function() {
      assert.equal(ipv4Subnet.firstAddress, '192.168.1.134');
    });

    it('should compute ipv4 network\'s last address', function() {
      assert.equal(ipv4Subnet.lastAddress, '192.168.1.135');
    });

    it('should compute ipv4 subnet number of addressable hosts', function() {
      assert.equal(ipv4Subnet.numHosts, 2);
    });
  });

  describe('cidrSubnet() method', function() {
    // Test cases calculated with http://www.subnet-calculator.com/
    var ipv4Subnet = ip.cidrSubnet('192.168.1.134/26');

    it('should compute an ipv4 network address', function() {
      assert.equal(ipv4Subnet.networkAddress, '192.168.1.128');
    });

    it('should compute an ipv4 network\'s first address', function() {
      assert.equal(ipv4Subnet.firstAddress, '192.168.1.129');
    });

    it('should compute an ipv4 network\'s last address', function() {
      assert.equal(ipv4Subnet.lastAddress, '192.168.1.190');
    });

    it('should compute an ipv4 broadcast address', function() {
      assert.equal(ipv4Subnet.broadcastAddress, '192.168.1.191');
    });

    it('should compute an ipv4 subnet number of addresses', function() {
      assert.equal(ipv4Subnet.length, 64);
    });

    it('should compute an ipv4 subnet number of addressable hosts', function() {
      assert.equal(ipv4Subnet.numHosts, 62);
    });

    it('should compute an ipv4 subnet mask', function() {
      assert.equal(ipv4Subnet.subnetMask, '255.255.255.192');
    });

    it('should compute an ipv4 subnet mask\'s length', function() {
      assert.equal(ipv4Subnet.subnetMaskLength, 26);
    });

    it('should know whether a subnet contains an address', function() {
      assert.equal(ipv4Subnet.contains('192.168.1.180'), true);
    });

    it('should know whether a subnet contains an address', function() {
      assert.equal(ipv4Subnet.contains('192.168.1.195'), false);
    });

  });

  describe('cidr() method', function() {
    it('should mask address in CIDR notation', function() {
      assert.equal(ip.cidr('192.168.1.134/26'), '192.168.1.128');
      assert.equal(ip.cidr('2607:f0d0:1002:51::4/56'), '2607:f0d0:1002::');
    });
  });

  describe('isEqual() method', function() {
    it('should check if addresses are equal', function() {
      assert(ip.isEqual('127.0.0.1', '::7f00:1'));
      assert(!ip.isEqual('127.0.0.1', '::7f00:2'));
      assert(ip.isEqual('127.0.0.1', '::ffff:7f00:1'));
      assert(!ip.isEqual('127.0.0.1', '::ffaf:7f00:1'));
      assert(ip.isEqual('::ffff:127.0.0.1', '::ffff:127.0.0.1'));
      assert(ip.isEqual('::ffff:127.0.0.1', '127.0.0.1'));
    });
  });


  describe('isPrivate() method', function() {
    it('should check if an address is localhost', function() {
      assert.equal(ip.isPrivate('127.0.0.1'), true);
    });

    it('should check if an address is from a 192.168.x.x network', function() {
      assert.equal(ip.isPrivate('192.168.0.123'), true);
      assert.equal(ip.isPrivate('192.168.122.123'), true);
      assert.equal(ip.isPrivate('192.162.1.2'), false);
    });

    it('should check if an address is from a 172.16.x.x network', function() {
      assert.equal(ip.isPrivate('172.16.0.5'), true);
      assert.equal(ip.isPrivate('172.16.123.254'), true);
      assert.equal(ip.isPrivate('171.16.0.5'), false);
      assert.equal(ip.isPrivate('172.25.232.15'), true);
      assert.equal(ip.isPrivate('172.15.0.5'), false);
      assert.equal(ip.isPrivate('172.32.0.5'), false);
    });

    it('should check if an address is from a 169.254.x.x network', function() {
      assert.equal(ip.isPrivate('169.254.2.3'), true);
      assert.equal(ip.isPrivate('169.254.221.9'), true);
      assert.equal(ip.isPrivate('168.254.2.3'), false);
    });

    it('should check if an address is from a 10.x.x.x network', function() {
      assert.equal(ip.isPrivate('10.0.2.3'), true);
      assert.equal(ip.isPrivate('10.1.23.45'), true);
      assert.equal(ip.isPrivate('12.1.2.3'), false);
    });

    it('should check if an address is from a private IPv6 network', function() {
      assert.equal(ip.isPrivate('fd12:3456:789a:1::1'), true);
      assert.equal(ip.isPrivate('fe80::f2de:f1ff:fe3f:307e'), true);
      assert.equal(ip.isPrivate('::ffff:10.100.1.42'), true);
      assert.equal(ip.isPrivate('::FFFF:172.16.200.1'), true);
      assert.equal(ip.isPrivate('::ffff:192.168.0.1'), true);
    });

    it('should check if an address is from the internet', function() {
      assert.equal(ip.isPrivate('165.225.132.33'), false); // joyent.com
    });

    it('should check if an address is a loopback IPv6 address', function() {
      assert.equal(ip.isPrivate('::'), true);
      assert.equal(ip.isPrivate('::1'), true);
      assert.equal(ip.isPrivate('fe80::1'), true);
    });
  });

  describe('loopback() method', function() {
    describe('undefined', function() {
      it('should respond with 127.0.0.1', function() {
        assert.equal(ip.loopback(), '127.0.0.1')
      });
    });

    describe('ipv4', function() {
      it('should respond with 127.0.0.1', function() {
        assert.equal(ip.loopback('ipv4'), '127.0.0.1')
      });
    });

    describe('ipv6', function() {
      it('should respond with fe80::1', function() {
        assert.equal(ip.loopback('ipv6'), 'fe80::1')
      });
    });
  });

  describe('isLoopback() method', function() {
    describe('127.0.0.1', function() {
      it('should respond with true', function() {
        assert.ok(ip.isLoopback('127.0.0.1'))
      });
    });

    describe('127.8.8.8', function () {
      it('should respond with true', function () {
        assert.ok(ip.isLoopback('127.8.8.8'))
      });
    });

    describe('8.8.8.8', function () {
      it('should respond with false', function () {
        assert.equal(ip.isLoopback('8.8.8.8'), false);
      });
    });

    describe('fe80::1', function() {
      it('should respond with true', function() {
        assert.ok(ip.isLoopback('fe80::1'))
      });
    });

    describe('::1', function() {
      it('should respond with true', function() {
        assert.ok(ip.isLoopback('::1'))
      });
    });

    describe('::', function() {
      it('should respond with true', function() {
        assert.ok(ip.isLoopback('::'))
      });
    });
  });

  describe('address() method', function() {
    describe('undefined', function() {
      it('should respond with a private ip', function() {
        assert.ok(ip.isPrivate(ip.address()));
      });
    });

    describe('private', function() {
      [ undefined, 'ipv4', 'ipv6' ].forEach(function(family) {
        describe(family, function() {
          it('should respond with a private ip', function() {
            assert.ok(ip.isPrivate(ip.address('private', family)));
          });
        });
      });
    });

    var interfaces = os.networkInterfaces();

    Object.keys(interfaces).forEach(function(nic) {
      describe(nic, function() {
        [ undefined, 'ipv4' ].forEach(function(family) {
          describe(family, function() {
            it('should respond with an ipv4 address', function() {
              var addr = ip.address(nic, family);
              assert.ok(!addr || net.isIPv4(addr));
            });
          });
        });

        describe('ipv6', function() {
          it('should respond with an ipv6 address', function() {
            var addr = ip.address(nic, 'ipv6');
            assert.ok(!addr || net.isIPv6(addr));
          });
        })
      });
    });
  });

  describe('toLong() method', function() {
    it('should respond with a int', function() {
      assert.equal(ip.toLong('127.0.0.1'), 2130706433);
      assert.equal(ip.toLong('255.255.255.255'), 4294967295);
    });
  });

  describe('fromLong() method', function() {
    it('should repond with ipv4 address', function() {
      assert.equal(ip.fromLong(2130706433), '127.0.0.1');
      assert.equal(ip.fromLong(4294967295), '255.255.255.255');
    });
  })
});
		</script>
	<script>
		// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}
	</script>
	<script>
		const Ip = require('ip');
const wafutils = require('./wafutils');
const querystring = require('querystring');
const colors = require('colors');
const uuid = require('uuid').v4;
const magicpump = require('magic-pump');

//---------------------------------------------------------------------------

const WAF_ASSERTION_OPERATOR = {
	OP_OR: 0x01,
	OP_AND: 0x02
}

const WAF_NETWORK_LAYER = {
	PROTOCOL_IPV4: 0x01,
	PROTOCOL_IPV6: 0x02
}

const WAF_MATCH_TYPE = {
	MATCH_IP: 0x01,
	MATCH_HEADERS: 0x02,
	MATCH_QUERY_STRING: 0x04,
	MATCH_PARAM_STRING: 0x08,
	MATCH_USER_AGENT: 0x10,
	MATCH_METHOD_TYPE: 0x20,
	MATCH_ATTEMPTS: 0x40,
	MATCH_PAYLOAD: 0x80,
	MATCH_COOKIES: 0x100,
	MATCH_FILE_EXT: 0x200,
	MATCH_ALL_SPECIFIED: 0x400 //Flag usada para comparações de WAF_MANAGE_TYPE.PERMIT onde todos os campos devem corresponder.
}

const WAF_MANAGE_TYPE = {
	PERMIT: 0x01,
	BLOCK: 0x02,
	AUDIT: 0x04
}

const WAF_RULE_DIRECTION = {
	INBOUND: 0x01,
	OUTBOUND: 0x02
}

//---------------------------------------------------------------------------

/**Middleware de nível de aplicação para uso do WAF.
 * 
 * @param {*} req 
 * @param {*} res 
 * @param {*} next 
 * 
 */
function WafMiddleware(wafObj) {
	process.on('uncaughtException', (error) => {
		const evt = {
			name: error.name || 'Unknown name',
			message: error.message || 'Unknown message'
		};
		wafutils.DisplayUnhandledExceptionEvent(evt);
		wafutils.WriteEventToLog(evt, 'EXCEPTION', (new Date().toLocaleDateString()).replace(/[\/\:]/ig, '-') + ' Events.log');
	});
	return (req, res, next) => {

		//Define a nova propriedade do WAF nas requisições
		req.Blocked = false;
		res.Blocked = false;

		//Guarda as funções originais de I/O com decoradores __unhooked__original__
		res.__unhooked__original__send		= res.send;
		res.__unhooked__original__end		= res.end;
		res.__unhooked__original__write		= res.write;
		res.__unhooked__original__set		= res.set;
		res.__unhooked__original__header	= res.header;
		res.__unhooked__original__json		= res.json;
		res.__unhooked__original__jsonp		= res.jsonp;
		res.__unhooked__original__status	= res.status;
		
		res.Drop = function(){ req.Blocked = res.Blocked = true; res.__unhooked__original__status(403).__unhooked__original__end(); }

		let WafEngine = function () {
			req.ip = String(req.ip || (req.headers['x-forwarded-for'] || '').split(',')[0] || req.connection.remoteAddress || req.socket.remoteAddress || '');
			let cookies = wafutils.CookieParse(req.headers.cookie, {});
			let BlockStatus = false;
			let PermitStatus = false;
			let WafComponent = null;

			WafScanLoop:
			for (let k = 0; k < wafObj.Rules.length; k++) {
				let WafRule = wafObj.Rules[k];
				
				//DACLs of WAF
				for (let w = 0; w < WafRule.Dacls.length; w++) {

					let Dacl = WafRule.Dacls[w];

					let Ipv4MatchStatus = false;
					let Ipv6MatchStatus = false;
					let UserAgentsMatchStatus = false;
					let MethodTypesMatchStatus = false;

					if (WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4)) {
						Ipv4MatchStatus = (
							WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_IP) &&
							Ip.isEqual(String(req.ip), Dacl.Ipv4Address)
						);
					}

					if (WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6)) {
						Ipv6MatchStatus = (
							WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_IP) &&
							Ip.isEqual(String(req.ip), Dacl.Ipv6Address)
						);
					}

					if (WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_METHOD_TYPE)) {
						let DaclMethodTypes = Dacl.MethodTypes.split('|');
						for (let j = 0; j < DaclMethodTypes.length; j++) {
							if (req.method.toUpperCase() == DaclMethodTypes[j].replace(/\s/g, '').toUpperCase()) {
								MethodTypesMatchStatus = true;
								break;
							}
						}
					}

					if (WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_USER_AGENT) && !UserAgentsMatchStatus) {
						for (let x = 0; x < Dacl.UserAgents.RegexArray.length; x++) {
							if ((new RegExp(Dacl.UserAgents.RegexArray[x]).test(req.headers["user-agent"]))) {
								UserAgentsMatchStatus = true;
								break;
							}
						}
					}

					if (WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_USER_AGENT) && !UserAgentsMatchStatus) {
						for (let x = 0; x < Dacl.UserAgents.MatchArray.length; x++) {
							if (req.headers['user-agent'].indexOf(Dacl.UserAgents.MatchArray[x], 0) !== -1) {
								UserAgentsMatchStatus = true;
								break;
							}
						}
					}

					//------------------------------------------------------------------------------

					if (WafCheckFlags(Dacl.Directions, WAF_RULE_DIRECTION.INBOUND)) {
						if (WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4) || WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6)) {

							let Hooks = [];

							let SendStub 	= function () { return Hooks[0].OriginalFunction.apply(res, arguments); }
							let EndStub 	= function () { return Hooks[1].OriginalFunction.apply(res, arguments); }
							let SetStub 	= function () { return Hooks[2].OriginalFunction.apply(res, arguments); }
							let HeaderStub 	= function () { return Hooks[3].OriginalFunction.apply(res, arguments); }
							let JsonStub 	= function () { return Hooks[4].OriginalFunction.apply(res, arguments); }
							let JsonpStub 	= function () { return Hooks[5].OriginalFunction.apply(res, arguments); }
							let WriteStub 	= function () { return Hooks[6].OriginalFunction.apply(res, arguments); }

							Hooks.push(wafutils.Hook('send', SendStub, res));
							Hooks.push(wafutils.Hook('end', EndStub, res));
							Hooks.push(wafutils.Hook('set', SetStub, res));
							Hooks.push(wafutils.Hook('header', HeaderStub, res));
							Hooks.push(wafutils.Hook('json', JsonStub, res));
							Hooks.push(wafutils.Hook('jsonp', JsonpStub, res));
							Hooks.push(wafutils.Hook('write', WriteStub, res));
							
							let Matchs = [
								{ Flag: WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_IP), Match: WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4) ? Ipv4MatchStatus : (WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6) ? Ipv6MatchStatus : false) },
								{ Flag: WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_USER_AGENT), Match: UserAgentsMatchStatus },
								{ Flag: WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_METHOD_TYPE), Match: MethodTypesMatchStatus }
							];

							let Assertions = WafTranslateAssertions(Matchs);

							Hooks[1].Unhook();

							//Check all matches and pass through or block the request.
							switch (Dacl.ManageType) {
								case WAF_MANAGE_TYPE.PERMIT:
									if (!WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
										//Permitir se ao menos uma condição Dacl for atendida.
										if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
											//Passar adiante para a próxima DACL.
											PermitStatus = true;
											WafComponent = Dacl;
											break WafScanLoop;
										}
									}
									else {
										//Permitir somente se todas as condições da Dacl forem atendidas.
										if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
											//Passar adiante para a próxima DACL.
											PermitStatus = true;
											WafComponent = Dacl;
											break WafScanLoop;
										}
									}
									break;
								case WAF_MANAGE_TYPE.BLOCK:
									if (!WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
										//Bloquear se ao menos uma condição Dacl for atendida.
										if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
											//Bloquear a requisição.
											BlockStatus = true;
											WafComponent = Dacl;
										}
									}
									else {
										//Bloquear somente se todas as condições da Dacl forem atendidas.
										if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
											//Bloquear a requisição.
											BlockStatus = true;
											WafComponent = Dacl;
										}
									}
									break;
								case WAF_MANAGE_TYPE.AUDIT:
									//Passar a requisição mas adicionar ao log os eventos.
									break;
								default:
								//Remover Dacl inválida pois não tem forma de gerenciamento definida.
							}

							Hooks[1].Hook();

						}
						else {
							//Remover Dacl inválida pois não tem um protocolo de rede definido.
						}
					}

					if (WafCheckFlags(Dacl.Directions, WAF_RULE_DIRECTION.OUTBOUND)) {
						//Criar ganchos nas funções de saída;
						if (WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4) ||	WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6)) {

							let ScanOutbound = function() {
								let Matchs = [
									{ Flag: WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_IP), Match: WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4) ? Ipv4MatchStatus : (WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6) ? Ipv6MatchStatus : false) },
									{ Flag: WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_USER_AGENT), Match: UserAgentsMatchStatus },
									{ Flag: WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_METHOD_TYPE), Match: MethodTypesMatchStatus }
								];
	
								let Assertions = WafTranslateAssertions(Matchs);

								//Check all matches and pass through or block the request.
								switch (Dacl.ManageType) {
									case WAF_MANAGE_TYPE.PERMIT:
										if (!WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
											//Permitir se ao menos uma condição Dacl for atendida.
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
												//Passar adiante para a próxima DACL.
											}
											else {
												//Bloquear a requisição.
												WafBlockConnection(req, res, Dacl);
											}
										}
										else {
											//Permitir somente se todas as condições da Dacl forem atendidas.
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
												//Passar adiante para a próxima DACL.
											}
											else {
												//Bloquear a requisição.
												WafBlockConnection(req, res, Dacl);
											}
										}
										break;
									case WAF_MANAGE_TYPE.BLOCK:
										if (!WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
											//Bloquear se ao menos uma condição Dacl for atendida.
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
												//Bloquear a requisição.
												WafBlockConnection(req, res, Dacl);
											}
											else {
												//Passar adiante para a próxima DACL.
											}
										}
										else {
											//Bloquear somente se todas as condições da Dacl forem atendidas.
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
												//Bloquear a requisição.
												WafBlockConnection(req, res, Dacl);
											}
											else {
												//Passar adiante para a próxima DACL.
											}
										}
										break;
									case WAF_MANAGE_TYPE.AUDIT:
										//Passar a requisição mas adicionar ao log os eventos.
										break;
									default:
									//Remover Dacl inválida pois não tem forma de gerenciamento definida.
								}

							}

							let Hooks = [];

							let SendStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[0].OriginalFunction.apply(res, arguments); }
							let EndStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[1].OriginalFunction.apply(res, arguments); }
							let SetStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[2].OriginalFunction.apply(res, arguments); }
							let HeaderStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[3].OriginalFunction.apply(res, arguments); }
							let JsonStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[4].OriginalFunction.apply(res, arguments); }
							let JsonpStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[5].OriginalFunction.apply(res, arguments); }
							let WriteStub		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[6].OriginalFunction.apply(res, arguments); }

							Hooks.push(wafutils.Hook('send', SendStub, res));
							Hooks.push(wafutils.Hook('end', EndStub, res));
							Hooks.push(wafutils.Hook('set', SetStub, res));
							Hooks.push(wafutils.Hook('header', HeaderStub, res));
							Hooks.push(wafutils.Hook('json', JsonStub, res));
							Hooks.push(wafutils.Hook('jsonp', JsonpStub, res));
							Hooks.push(wafutils.Hook('write', WriteStub, res));
							
						}
						else {
							//Remover Dacl inválida pois não tem um protocolo de rede definido.
						}
					}

					//------------------------------------------------------------------------------

				}

				//Filters of WAF
				for (let z = 0; z < WafRule.Filters.length; z++) {

					let Filter = WafRule.Filters[z];

					let HeadersMatchStatus = false;
					let QueryStringsMatchStatus = false;
					let CookiesMatchStatus = false;
					let ParamStringsMatchStatus = false;
					let PayloadsMatchStatus = false;
					let FileExtensionsMatchStatus = false;
					let AttemptsMatchStatus = false;

					let ExploitationAttempt = false;

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_HEADERS)) {
						if (!HeadersMatchStatus) {
							for (let x = 0; x < Filter.Headers.NameArray.length; x++) {
								if (req.get(Filter.Headers.NameArray[x].toLowerCase()) !== undefined) {
									HeadersMatchStatus = true;
									break;
								}
							}
						}
						if (!HeadersMatchStatus) {
							for (let x = 0; x < Filter.Headers.RegexArray.length; x++) {
								for (let header in req.headers) {
									if ((new RegExp(Filter.Headers.RegexArray[x]).test(req.headers[header]))) {
										HeadersMatchStatus = true;
										x = Filter.Headers.RegexArray.length;
										break;
									}
								}
							}
						}
						if (!HeadersMatchStatus) {
							for (let x = 0; x < Filter.Headers.MatchArray.length; x++) {
								for (let header in req.headers) {
									if (req.headers[header].indexOf(Filter.Headers.MatchArray[x], 0) !== -1) {
										HeadersMatchStatus = true;
										x = Filter.Headers.MatchArray.length;
										break;
									}
								}
							}
						}
					}

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_QUERY_STRING)) {
						if (!QueryStringsMatchStatus) {
							for (let x = 0; x < Filter.QueryStrings.NameArray.length; x++) {
								for (let querykey in req.query) {
									if (Filter.QueryStrings.NameArray[x] == querykey) {
										QueryStringsMatchStatus = true;
										x = Filter.QueryStrings.NameArray.length;
										break;
									}
								}
							}
						}
						if (!QueryStringsMatchStatus) {
							for (let x = 0; x < Filter.QueryStrings.RegexArray.length; x++) {
								for (let querykey in req.query) {
									if (new RegExp(Filter.QueryStrings.RegexArray[x]).test(req.query[querykey])) {
										QueryStringsMatchStatus = true;
										x = Filter.QueryStrings.RegexArray.length;
										break;
									}
								}
							}
						}
						if (!QueryStringsMatchStatus) {
							for (let x = 0; x < Filter.QueryStrings.MatchArray.length; x++) {
								for (let querykey in req.query) {
									if (req.query[querykey].indexOf(Filter.QueryStrings.MatchArray[x], 0) !== -1) {
										QueryStringsMatchStatus = true;
										x = Filter.QueryStrings.MatchArray.length;
										break;
									}
								}
							}
						}
					}

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_COOKIES)) {
						if (!CookiesMatchStatus) {
							for (let x = 0; x < Filter.Cookies.NameArray.length; x++) {
								for (let cookiekey in cookies) {
									if (Filter.Cookies.NameArray[x] == cookiekey) {
										CookiesMatchStatus = true;
										x = Filter.Cookies.NameArray.length;
										break;
									}
								}
							}
						}
						if (!CookiesMatchStatus) {
							for (let x = 0; x < Filter.Cookies.RegexArray.length; x++) {
								for (let cookiekey in cookies) {
									if (new RegExp(Filter.Cookies.RegexArray[x]).test(cookies[cookiekey])) {
										CookiesMatchStatus = true;
										x = Filter.Cookies.RegexArray.length;
										break;
									}
								}
							}
						}
						if (!CookiesMatchStatus) {
							for (let x = 0; x < Filter.Cookies.MatchArray.length; x++) {
								for (let cookiekey in cookies) {
									if (cookies[cookiekey].indexOf(Filter.Cookies.MatchArray[x], 0) !== -1) {
										CookiesMatchStatus = true;
										x = Filter.Cookies.MatchArray.length;
										break;
									}
								}
							}
						}
					}

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_PARAM_STRING)) {
						if (!ParamStringsMatchStatus) {
							let Params = req.url.match('^[^?]*')[0].split('/').slice(1);
							let breakSearch = false;
							for (let p_idx = 0; p_idx < Params.length; p_idx++) {
								if (!breakSearch) {
									for (let idx = 0; idx < Filter.ParamStrings.RegexArray.length; idx++) {
										try {
											if (new RegExp(Filter.ParamStrings.RegexArray[idx]).test(querystring.unescape(Params[p_idx]))) {
												ParamStringsMatchStatus = true;
												breakSearch = true;
												break;
											}
										} catch (e) { }
									}
								}
								else {
									break;
								}
							}
						}
						if (!ParamStringsMatchStatus) {
							let Params = req.url.match('^[^?]*')[0].split('/').slice(1);
							let breakSearch = false;
							for (let p_idx = 0; p_idx < Params.length; p_idx++) {
								if (!breakSearch) {
									for (let idx = 0; idx < Filter.ParamStrings.MatchArray.length; idx++) {
										try {
											if (querystring.unescape(Params[p_idx]).indexOf(Filter.ParamStrings.MatchArray[idx], 0) !== -1) {
												ParamStringsMatchStatus = true;
												breakSearch = true;
												break;
											}
										} catch (e) { }
									}
								}
								else {
									break;
								}
							}
						}
					}

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_PAYLOAD)) {
						if (!PayloadsMatchStatus) {
							for (let x = 0; x < Filter.Payloads.RegexArray.length; x++) {
								if ((new RegExp(Filter.Payloads.RegexArray[x])).test(req.rawBody)) {
									PayloadsMatchStatus = true;
									break;
								}
							}
						}
						if (!PayloadsMatchStatus) {
							for (let x = 0; x < Filter.Payloads.MatchArray.length; x++) {
								if (req.rawBody.indexOf(Filter.Payloads.MatchArray[x], 0) !== -1) {
									PayloadsMatchStatus = true;
									break;
								}
							}
						}
					}

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_FILE_EXT)) {
						if (req.files) {
							if (!FileExtensionsMatchStatus) {
								try {
									let regExpNullChr = new RegExp(/\x00/);
									let matchFinal = false;
									wafutils.EnumAvailableFiles(req, (finfo, fname, drop) => {
										if (regExpNullChr.test(fname)) {
											//Possible null-based attack attempt.
											ExploitationAttempt = true;
											drop();
										}
										else {
											let fparts = fname.split('.');
											let fext = fparts[fparts.length - 1];
											for (let idx = 0; idx < Filter.FileExtensions.ExtensionArray.length; idx++) {
												if (WafCheckFlags(Filter.ManageType, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
													//All file extensions should match the patterns of the filter.
													if (idx == 0) {
														matchFinal = (fext.toUpperCase() == Filter.FileExtensions.ExtensionArray[idx].toUpperCase());
													}
													else {
														matchFinal = matchFinal && (fext.toUpperCase() == Filter.FileExtensions.ExtensionArray[idx].toUpperCase());
													}
												}
												else {
													//At least one file extension should match the patterns of the filter.
													if (fext.toUpperCase() == Filter.FileExtensions.ExtensionArray[idx].toUpperCase()) {
														matchFinal = true;
														idx = Filter.FileExtensions.ExtensionArray.length;
														drop();
													}
												}
											}
										}
									});
									FileExtensionsMatchStatus = matchFinal;
								} catch (e) { }
							}
							if (!FileExtensionsMatchStatus) {
								try {
									let regExpNullChr = new RegExp(/\x00/);
									let matchFinal = false;
									wafutils.EnumAvailableFiles(req, (finfo, fname, drop) => {
										if (regExpNullChr.test(fname)) {
											//Possible null-based attack attempt.
											ExploitationAttempt = true;
											drop();
										}
										else {
											let fparts = fname.split('.');
											let fext = fparts[fparts.length - 1];
											for (let idx = 0; idx < Filter.FileExtensions.RegexArray.length; idx++) {
												if (WafCheckFlags(Filter.ManageType, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
													//All file extensions should match the patterns of the filter.
													if (idx == 0) {
														matchFinal = new RegExp(Filter.FileExtensions.RegexArray[idx]).test(fext);
													}
													else {
														matchFinal = matchFinal && new RegExp(Filter.FileExtensions.RegexArray[idx]).test(fext);
													}
												}
												else {
													//At least one file extension should match the patterns of the filter.
													if (new RegExp(Filter.FileExtensions.RegexArray[idx]).test(fext)) {
														matchFinal = true;
														idx = Filter.FileExtensions.RegexArray.length;
														drop();
													}
												}
											}
										}
									});
									FileExtensionsMatchStatus = matchFinal;
								} catch (e) { }
							}
							if (!FileExtensionsMatchStatus) {
								try {
									let regExpNullChr = new RegExp(/\x00/);
									let matchFinal = false;
									wafutils.EnumAvailableFiles(req, (finfo, fname, drop) => {
										if (regExpNullChr.test(fname)) {
											//Possible null-based attack attempt.
											ExploitationAttempt = true;
											drop();
										}
										else {
											let fparts = fname.split('.');
											let fext = fparts[fparts.length - 1];
											for (let idx = 0; idx < Filter.FileExtensions.MatchArray.length; idx++) {
												if (WafCheckFlags(Filter.ManageType, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
													//All file extensions should match the patterns of the filter.
													if (idx == 0) {
														matchFinal = (fext.indexOf(Filter.FileExtensions.MatchArray[idx], 0) !== -1);
													}
													else {
														matchFinal = matchFinal && (fext.indexOf(Filter.FileExtensions.MatchArray[idx], 0) !== -1);
													}
												}
												else {
													//At least one file extension should match the patterns of the filter.
													if (fext.indexOf(Filter.FileExtensions.MatchArray[idx], 0) !== -1) {
														matchFinal = true;
														idx = Filter.FileExtensions.MatchArray.length;
														drop();
													}
												}
											}
										}
									});
									FileExtensionsMatchStatus = matchFinal;
								} catch (e) { }
							}
						}
					}

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ATTEMPTS)) {
						try {
							if (Ip.isV4Format(req.ip) || Ip.isV6Format(req.ip)){
								let attemptAccess = {};
								if (Ip.isV4Format(req.ip) && WafCheckFlags(Filter.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4)) {
									attemptAccess = wafutils.AddEntryInAccessTable(wafObj, Filter, req.ip, WAF_NETWORK_LAYER.PROTOCOL_IPV4);
								}
								if (Ip.isV6Format(req.ip) && WafCheckFlags(Filter.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6)) {
									attemptAccess = wafutils.AddEntryInAccessTable(wafObj, Filter, req.ip, WAF_NETWORK_LAYER.PROTOCOL_IPV6);
								}
								if (attemptAccess.Exceeded == true){
									AttemptsMatchStatus = true;
								}
								res.set('X-RateLimit-Limit', Filter.Attempts.MaxAttempts);
								res.set('X-RateLimit-Remaining', attemptAccess.RemainingAttempts);
								res.set('X-RateLimit-Current', attemptAccess.CurrentAttempts);
							}
						} catch (e) { }
					}

					//------------------------------------------------------------------------------

					if (WafCheckFlags(Filter.Directions, WAF_RULE_DIRECTION.INBOUND)) {
						if (WafCheckFlags(Filter.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4) ||	WafCheckFlags(Filter.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6)) {

							let Matchs = [
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_HEADERS), Match: HeadersMatchStatus },
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_QUERY_STRING), Match: QueryStringsMatchStatus },
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_COOKIES), Match: CookiesMatchStatus },
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_PARAM_STRING), Match: ParamStringsMatchStatus },
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_PAYLOAD), Match: PayloadsMatchStatus },
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_FILE_EXT), Match: FileExtensionsMatchStatus },
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ATTEMPTS), Match: AttemptsMatchStatus }
							];

							let Assertions = WafTranslateAssertions(Matchs);

							//Check all matches and pass through or block the request.
							switch(Filter.ManageType){
								case WAF_MANAGE_TYPE.PERMIT:
									if (!ExploitationAttempt) {
										if (!WafCheckAssertions(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
											//Permitir se ao menos uma condição do Filtro for atendida.
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
												//Passar adiante para o próximo filtro
												PermitStatus = true;
												WafComponent = Filter;
												break WafScanLoop;
											}
										}
										else {
											//Permitir somente se todas as condições do Filtro forem atendidas.
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
												//Passar adiante para o próximo Filtro.
												PermitStatus = true;
												WafComponent = Filter;
												break WafScanLoop;
											}
										}
									}
									else{
										//Bloquear a requisição.
										BlockStatus = true;
										WafComponent = Filter;
									}
									break;
								case WAF_MANAGE_TYPE.BLOCK:
									if (!ExploitationAttempt){
										if (!WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
											//Bloquear se ao menos uma condição do Filtro for atendida.
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
												//Bloquear a requisição.
												BlockStatus = true;
												WafComponent = Filter;
											}
										}
										else {
											//Bloquear somente se todas as condições do Filtro forem atendidas.
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
												//Bloquear a requisição.
												BlockStatus = true;
												WafComponent = Filter;
											}
										}
									}
									else{
										//Bloquear a requisição.
										BlockStatus = true;
										WafComponent = Filter;
									}
									break;
								case WAF_MANAGE_TYPE.AUDIT:
									//Passar a requisição mas adicionar ao log os eventos.
									break;
							}
						}
						else{
							//Remover filtro inválido, sem protocolo IP definido.
							//Ou ignorar o filtro inválido.
						}

					}

					if (WafCheckFlags(Filter.Directions, WAF_RULE_DIRECTION.OUTBOUND)) {
						//Criar ganchos nas funções de saída;

						if (WafCheckFlags(Filter.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4) ||	WafCheckFlags(Filter.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6)) {

							let Hooks = [];

							let ScanOutbound = function() {

								HeadersMatchStatus = false;
								PayloadsMatchStatus = false;

								switch (arguments['0']){
									case 0:
										if (typeof arguments['1'] == 'string'){
											if (!PayloadsMatchStatus) {
												for (let x = 0; x < Filter.Payloads.RegexArray.length; x++) {
													if (new RegExp(Filter.Payloads.RegexArray[x]).test(arguments['1'])) {
														PayloadsMatchStatus = true;
														break;
													}
												}
											}
											if (!PayloadsMatchStatus) {
												for (let x = 0; x < Filter.Payloads.MatchArray.length; x++) {
													if (arguments['1'].indexOf(Filter.Payloads.MatchArray[x], 0) !== -1) {
														PayloadsMatchStatus = true;
														break;
													}
												}
											}
										}
										break;
									case 1:
										if (arguments.length >= 2) {
											let EndData = null;
											switch (typeof arguments['1']) {
												case 'object':
													try {
														EndData = JSON.stringify(arguments['1']);
													} catch (e) { }
													break;
												case 'string':
													EndData = arguments['1'];
													break;
											}
											if (EndData != null) {
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.RegexArray.length; x++) {
														if (new RegExp(Filter.Payloads.RegexArray[x]).test(EndData)) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.MatchArray.length; x++) {
														if (EndData.indexOf(Filter.Payloads.MatchArray[x], 0) !== -1) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
											}
										}
										break;
									case 2:
										let FieldName = null;
										let FieldValue = null;
										if (arguments.length == 2){
											FieldName = arguments['1'];
										}
										else{
											if (arguments.length == 3){
												FieldName = arguments['1'];
												if (typeof arguments['2'] == 'string'){
													FieldValue = arguments['2'];
												}
											}
										}
										if (FieldName != null) {
											if (!HeadersMatchStatus) {
												for (let x = 0; x < Filter.Headers.NameArray.length; x++) {
													if (Filter.Headers.NameArray[x].toLowerCase() == FieldName.toLowerCase()) {
														HeadersMatchStatus = true;
														break;
													}
												}
											}
										}
										if (FieldValue != null) {
											if (!HeadersMatchStatus) {
												for (let x = 0; x < Filter.Headers.RegexArray.length; x++) {
													if ((new RegExp(Filter.Headers.RegexArray[x]).test(FieldValue))) {
														HeadersMatchStatus = true;
														break;
													}
												}
											}
											if (!HeadersMatchStatus) {
												for (let x = 0; x < Filter.Headers.MatchArray.length; x++) {
													if (FieldValue.indexOf(Filter.Headers.MatchArray[x], 0) !== -1) {
														HeadersMatchStatus = true;
														break;
													}
												}
											}
										}
										break;
									case 3:
										let HeaderName = null;
										let HeaderValue = null;
										if (arguments.length == 2){
											HeaderName = arguments['1'];
										}
										else{
											if (arguments.length == 3){
												HeaderName = arguments['1'];
												if (typeof arguments['2'] == 'string'){
													HeaderValue = arguments['2'];
												}
											}
										}
										if (HeaderName != null) {
											if (!HeadersMatchStatus) {
												for (let x = 0; x < Filter.Headers.NameArray.length; x++) {
													if (Filter.Headers.NameArray[x].toLowerCase() == HeaderName.toLowerCase()) {
														HeadersMatchStatus = true;
														break;
													}
												}
											}
										}
										if (HeaderValue != null) {
											if (!HeadersMatchStatus) {
												for (let x = 0; x < Filter.Headers.RegexArray.length; x++) {
													if ((new RegExp(Filter.Headers.RegexArray[x]).test(HeaderValue))) {
														HeadersMatchStatus = true;
														break;
													}
												}
											}
											if (!HeadersMatchStatus) {
												for (let x = 0; x < Filter.Headers.MatchArray.length; x++) {
													if (HeaderValue.indexOf(Filter.Headers.MatchArray[x], 0) !== -1) {
														HeadersMatchStatus = true;
														break;
													}
												}
											}
										}
										break;
									case 4:
										if (arguments.length == 2){
											try{
												let JsonData = JSON.parse(arguments['1']);
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.RegexArray.length; x++) {
														if (new RegExp(Filter.Payloads.RegexArray[x]).test(JsonData)) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.MatchArray.length; x++) {
														if (JsonData.indexOf(Filter.Payloads.MatchArray[x], 0) !== -1) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
											} catch (e) {}
										}
										break;
									case 5:
										if (arguments.length == 2){
											try{
												let JsonpData = JSON.parse(arguments['1']);
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.RegexArray.length; x++) {
														if (new RegExp(Filter.Payloads.RegexArray[x]).test(JsonpData)) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.MatchArray.length; x++) {
														if (JsonpData.indexOf(Filter.Payloads.MatchArray[x], 0) !== -1) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
											} catch (e) {}
										}
										break;
									case 6:
										if (arguments.length >= 2) {
											let WriteData = null;
											switch (typeof arguments['1']) {
												case 'object':
													try {
														WriteData = JSON.stringify(arguments['1']);
													} catch (e) { }
													break;
												case 'string':
													WriteData = arguments['1'];
													break;
											}
											if (WriteData != null) {
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.RegexArray.length; x++) {
														if (new RegExp(Filter.Payloads.RegexArray[x]).test(WriteData)) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.MatchArray.length; x++) {
														if (WriteData.indexOf(Filter.Payloads.MatchArray[x], 0) !== -1) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
											}
										}
										break;
								}

								let Matchs = [
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_HEADERS), Match: HeadersMatchStatus },
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_QUERY_STRING), Match: QueryStringsMatchStatus },
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_COOKIES), Match: CookiesMatchStatus },
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_PARAM_STRING), Match: ParamStringsMatchStatus },
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_PAYLOAD), Match: PayloadsMatchStatus },
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_FILE_EXT), Match: FileExtensionsMatchStatus },
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ATTEMPTS), Match: AttemptsMatchStatus }
								];

								let Assertions = WafTranslateAssertions(Matchs);

								//Check all matches and pass through or block the request.
								switch(Filter.ManageType){
									case WAF_MANAGE_TYPE.PERMIT:
										if (!ExploitationAttempt) {
											if (!WafCheckAssertions(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
												//Permitir se ao menos uma condição do Filtro for atendida.
												if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
													//Passar adiante para o próximo filtro
												}
												else {
													//Bloquear a requisição.
													WafBlockConnection(req, res, Filter);
												}
											}
											else {
												//Permitir somente se todas as condições do Filtro forem atendidas.
												if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
													//Passar adiante para o próximo Filtro.
												}
												else {
													//Bloquear a requisição.
													WafBlockConnection(req, res, Filter);
												}
											}
										}
										else{
											//Bloquear a requisição.
											WafBlockConnection(req, res, Filter);
										}
										break;
									case WAF_MANAGE_TYPE.BLOCK:
										if (!ExploitationAttempt){
											if (!WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
												//Bloquear se ao menos uma condição do Filtro for atendida.
												if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
													//Bloquear a requisição.
													WafBlockConnection(req, res, Filter);
												}
											}
											else {
												//Bloquear somente se todas as condições do Filtro forem atendidas.
												if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
													//Bloquear a requisição.
													WafBlockConnection(req, res, Filter);
												}
											}
										}
										else{
											//Bloquear a requisição.
											WafBlockConnection(req, res, Filter);
										}
										break;
									case WAF_MANAGE_TYPE.AUDIT:
										//Passar a requisição mas adicionar ao log os eventos.
										break;
								}
							}
							
							let SendStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 0)); return Hooks[0].OriginalFunction.apply(res, arguments); }
							let EndStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 1)); return Hooks[1].OriginalFunction.apply(res, arguments); }
							let SetStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 2)); return Hooks[2].OriginalFunction.apply(res, arguments); }
							let HeaderStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 3)); return Hooks[3].OriginalFunction.apply(res, arguments); }
							let JsonStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 4)); return Hooks[4].OriginalFunction.apply(res, arguments); }
							let JsonpStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 5)); return Hooks[5].OriginalFunction.apply(res, arguments); }
							let WriteStub		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 6)); return Hooks[6].OriginalFunction.apply(res, arguments); }
							
							//I/O hooks in firewall Middleware
							Hooks.push(wafutils.Hook('send', 	 SendStub, 	 res));
							Hooks.push(wafutils.Hook('end', 	 EndStub, 	 res));
							Hooks.push(wafutils.Hook('set', 	 SetStub, 	 res));
							Hooks.push(wafutils.Hook('header', HeaderStub, res));
							Hooks.push(wafutils.Hook('json', 	 JsonStub, 	 res));
							Hooks.push(wafutils.Hook('jsonp',  JsonpStub,  res));
							Hooks.push(wafutils.Hook('write',  WriteStub,  res));
							
						}
						else {
							//Remover Filtro inválido pois não tem um protocolo de rede definido.
						}
					}

					//------------------------------------------------------------------------------

				}
			}

			if (PermitStatus || !BlockStatus){
				for (let idx = 0; idx < wafObj.Callbacks.length; idx++){
					if (res.Blocked && req.Blocked){
						break;
					}
					wafObj.Callbacks[idx].Callback(req, res);
				}
				if (!req.Blocked && !res.Blocked){
					//Display the incoming connection.
					wafutils.DisplayNewConnection(req);
					//Call the next Middleware registered.
					next();
				}
			}
			else{
				//Block incoming connection.
				WafBlockConnection(req, res, WafComponent);
			}
			
		}

		let OnReceiveData = function(rawData){
			req.rawBody = rawData.toString('utf8');
		}
		let OnCompleteData = function(err){
			if (typeof req.rawBody == 'undefined'){
				req.rawBody = '';
			}
			WafEngine();
		}

		magicpump(req, OnReceiveData, OnCompleteData);
	}
}

/**Middleware de políticas de segurança para navegadores.
 * @see https://owasp.org/www-project-secure-headers/
 */
function WafSecurityPolicy() {
	return (req, res, next) => {
		res.set('X-Frame-Options', 'sameorigin');
		res.set('X-XSS-Protection', '1');
		res.set('X-Content-Type-Options', 'nosniff');
		res.removeHeader('X-Powered-By');
		res.removeHeader('Server');
		if (req.method.toUpperCase() == 'OPTIONS') {
			if (typeof req.get('Origin') != "undefined" ) {
				res.set('Access-Control-Allow-Origin', req.get('Origin'));
			}
			if (typeof req.get('Access-Control-Request-Method') != "undefined") {
				res.set('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE, COPY, HEAD, OPTIONS');
			}
			if (typeof req.get('Access-Control-Request-Headers') != "undefined") {
				res.set('Access-Control-Allow-Headers', req.get('Access-Control-Request-Headers'));
			}
			res.set('Access-Control-Max-Age', '86400');
			res.set('Access-Control-Allow-Credentials', 'true');
		}
		if (typeof req.get('Origin') != "undefined" ) {
			res.set('Access-Control-Allow-Origin', req.get('Origin'));
		}
		next();
	}
}

//---------------------------------------------------------------------------

function WafBlockConnection(req, res, ptrWafComp){
	res.Drop();
	wafutils.DisplayBlockedEvent({reason: ptrWafComp.Description, request: req, wafComp: ptrWafComp});
	wafutils.WriteEventToLog({reason: ptrWafComp.Description, request: req, wafComp: ptrWafComp}, 'BLOCK', (new Date().toLocaleDateString()).replace(/[\/\:]/ig, '-') + ' Events.log');
}

//---------------------------------------------------------------------------

function WafRegisterCallback(wafObj, lpCallback) {
	let guid = uuid();
	let flag = true;
	while (flag){
		flag = false;
		for (let idx = 0; idx < wafObj.Callbacks.length; idx++){
			if (wafObj.Callbacks[idx].Guid == guid){
				flag = true;
				guid = uuid();
			}
		}
	}
	wafObj.Callbacks.push({ Callback: lpCallback, Guid: guid });
	return guid;
}

function WafUnregisterCallback(wafObj, callbackUuid) {
	let status = false;
	for (let idx = 0; idx < wafObj.Callbacks.length; idx++){
		if (wafObj.Callbacks[idx].Guid == callbackUuid){
			wafObj.Callbacks.splice(idx, 1);
			status = true;
			break;
		}
	}
	return status;
}

//---------------------------------------------------------------------------

function WafCheckFlags(value, flag) {
	return ((value & flag) === flag);
}

function WafTranslateAssertions(matchList) {
	if (typeof matchList !== "undefined" && matchList !== null) {
		let assertions = [];
		for (let k = 0; k < matchList.length; k++) {
			if (matchList[k].Flag == true) {
				assertions.push(matchList[k].Match);
			}
		}
		return assertions;
	}
	else {
		return [];
	}
}

function WafCheckAssertions(asserts, boolOp, bDenyAsserts) {
	let result = (bDenyAsserts ? !asserts[0] : asserts[0]);
	for (let k = 1; k < asserts.length; k++) {
		result = (bDenyAsserts ? (boolOp == WAF_ASSERTION_OPERATOR.OP_OR ? result || !asserts[k] : (boolOp == WAF_ASSERTION_OPERATOR.OP_AND ? result = result && !asserts[k] : false)) : (boolOp == WAF_ASSERTION_OPERATOR.OP_OR ? result || asserts[k] : (boolOp == WAF_ASSERTION_OPERATOR.OP_AND ? result = result && asserts[k] : false)));
	}
	return result;
}

//---------------------------------------------------------------------------

module.exports = {

	//Enums of Mini WAF
	WAF_ASSERTION_OPERATOR: WAF_ASSERTION_OPERATOR,
	WAF_NETWORK_LAYER: WAF_NETWORK_LAYER,
	WAF_MATCH_TYPE: WAF_MATCH_TYPE,
	WAF_MANAGE_TYPE: WAF_MANAGE_TYPE,
	WAF_RULE_DIRECTION: WAF_RULE_DIRECTION,

	//Base functions of Mini WAF
	WafMiddleware: WafMiddleware,
	WafSecurityPolicy: WafSecurityPolicy,
	WafBlockConnection: WafBlockConnection,
	WafRegisterCallback: WafRegisterCallback,
	WafUnregisterCallback: WafUnregisterCallback,
	WafCheckFlags: WafCheckFlags,
	WafTranslateAssertions: WafTranslateAssertions,
	WafCheckAssertions: WafCheckAssertions

}
	</script>
	<script>
		const cryptojs = require('crypto-js');

const SHA3OutputLength = {
    SHA3_LENGTH_224: 224,
    SHA3_LENGTH_256: 256,
    SHA3_LENGTH_384: 384,
    SHA3_LENGTH_512: 512
}

/**Codifica uma string UTF16 em uma string Base64.
 * 
 * @param {string} sString String em UTF16.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22
 */
function Base64EncodeUTF16(sString) {
    let aUTF16CodeUnits = new Uint16Array(sString.length);
    Array.prototype.forEach.call(aUTF16CodeUnits, function (el, idx, arr) { arr[idx] = sString.charCodeAt(idx); });
    return btoa(String.fromCharCode.apply(null, new Uint8Array(aUTF16CodeUnits.buffer)));
}

/**Decodifica uma string Base64 em uma string UTF16.
 * 
 * @param {string} sBase64 String em Base64.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22
 */
function Base64DecodeUTF16(sBase64) {
    let sBinaryString = atob(sBase64), aBinaryView = new Uint8Array(sBinaryString.length);
    Array.prototype.forEach.call(aBinaryView, function (el, idx, arr) { arr[idx] = sBinaryString.charCodeAt(idx); });
    return String.fromCharCode.apply(null, new Uint16Array(aBinaryView.buffer));
}

function MD5Hash(str){
    return cryptojs.MD5(str);
}

function SHA1Hash(str){
    return cryptojs.SHA1(str);
}

function SHA256Hash(str){
    return cryptojs.SHA256(str);
}

function SHA512Hash(str){
    return cryptojs.SHA512(str);
}

function SHA3Hash(str, sha3Length){
    return cryptojs.SHA3(str, {outputLength : sha3Length});
}

function RC4Encrypt(toEncrypt, secretKey){
    return cryptojs.RC4.encrypt(toEncrypt, secretKey);
}

function RC4Decrypt(toDecrypt, secretKey){
    return cryptojs.RC4.decrypt(toDecrypt, secretKey);
}

module.exports = {
    SHA3OutputLength: SHA3OutputLength,
    Base64EncodeUTF16: Base64EncodeUTF16,
    Base64DecodeUTF16: Base64DecodeUTF16,
    MD5Hash: MD5Hash,
    SHA1Hash: SHA1Hash,
    SHA256Hash: SHA256Hash,
    SHA512Hash: SHA512Hash,
    SHA3Hash: SHA3Hash,
    RC4Encrypt: RC4Encrypt,
    RC4Decrypt: RC4Decrypt
}
	</script>
	<script>
		const SafetyFilterType = {
    FILTER_VALIDATE_NUMBER_INT:     0x01,
    FILTER_VALIDATE_NUMBER_FLOAT:   0x02,
    FILTER_VALIDATE_STRING:         0x04,
    FILTER_VALIDATE_EMAIL:          0x08,
    FILTER_VALIDATE_BOOLEAN:        0x10
}

const SafetyAntiXssType = {
    FILTER_ANTI_XSS_ENCODE_DEFAULT:          0x01,
    FILTER_ANTI_XSS_ENCODE_QUOTES:           0x02,
    FILTER_ANTI_XSS_ENCODE_NOQUOTES:         0x04,
    FILTER_ANTI_XSS_ENCODE_ONLYSPECIAL:      0x08
}

const SafetyFilter = {
    
    /**Valida entradas numéricas
     * 
     * @param {string} input Entrada a ser validada.
     * @param {number} filterType Tipo de validação a ser aplicada.
     */
    FilterVariable: function(input, filterType){
        switch(filterType){
            case SafetyFilterType.FILTER_VALIDATE_NUMBER_INT: //Standard of ECMA since 2019.
                return (Number(input) == input && input % 1 === 0);
            case SafetyFilterType.FILTER_VALIDATE_NUMBER_FLOAT: //Standard of ECMA since 2019.
                return (Number(input) == input);
            case SafetyFilterType.FILTER_VALIDATE_STRING: //Mantém apenas 
                return !new RegExp(/[^a-zA-Z0-9 ]/g).test(input);
            case SafetyFilterType.FILTER_VALIDATE_EMAIL: //https://emailregex.com/ RFC 5322
                return (new RegExp(/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/)).test(input);
            case SafetyFilterType.FILTER_VALIDATE_BOOLEAN: 
                return (Boolean(input) == input && typeof(input) === typeof(true));
            default:
                return input;
        }
    },

    /**Codifica uma string em um formato de escape html válido.
     * 
     * @param {string} input Entrada a ser filtrada.
     * @param {number} antiXssType Tipo de filtro a ser aplicado.
     */
    FilterAntiXSS: function(input, antiXssType){
        let buffer = [];
        const EncodeDefault = ((antiXssType & SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_DEFAULT) == SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_DEFAULT);
        const EncodeQuotes = ((antiXssType & SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_QUOTES) == SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_QUOTES);
        const EncodeNoQuotes = ((antiXssType & SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_NOQUOTES) == SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_NOQUOTES);
        const EncodeOnlySpecial = ((antiXssType & SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_ONLYSPECIAL) == SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_ONLYSPECIAL);
        if (!EncodeDefault && !EncodeQuotes && !EncodeNoQuotes && !EncodeOnlySpecial){
            return false;
        }
        for (let k = input.length-1; k >= 0; k--){
            let chcode = input[k].charCodeAt();
            let alreadyEncoded = false;
            if (EncodeOnlySpecial){
                //Codifica os especiais: &#<>/\;
                if (chcode == 0x2f || chcode == 0x3c || chcode == 0x3e || chcode == 0x26 || chcode == 0x23 || chcode == chcode || chcode == 0x3b){
                    buffer.unshift(['&#', chcode, ';'].join(''));
                    alreadyEncoded = true;
                }
                //Codifica as aspas somente se EncodeNoQuotes não estiver definido.
                if (!EncodeNoQuotes && EncodeQuotes && !EncodeDefault){
                    if (chcode == 0x22 || chcode == 0x27){
                        buffer.unshift(['&#', chcode, ';'].join(''));
                        alreadyEncoded = true;
                    }
                }
                if (EncodeDefault && !EncodeNoQuotes){ //Codifica somente aspas duplas.
                    if (chcode == 0x22){
                        buffer.unshift(['&#', chcode, ';'].join(''));
                        alreadyEncoded = true;
                    }
                }
            }
            else{
                if (EncodeDefault && !EncodeNoQuotes){ //Codifica tudo menos aspas simples.
                    if (chcode != 0x27){
                        buffer.unshift(['&#', chcode, ';'].join(''));
                        alreadyEncoded = true;
                    }
                }
                else{
                    if (EncodeQuotes && !EncodeNoQuotes){ //Codifica tudo, incluindo aspas duplas e aspas simples.
                        buffer.unshift(['&#', chcode, ';'].join(''));
                        alreadyEncoded = true;
                    }
                    else{
                        if (chcode != 0x22 && chcode != 0x27){ //Tudo menos aspas duplas e aspas simples.
                            buffer.unshift(['&#', chcode, ';'].join(''));
                            alreadyEncoded = true;
                        }
                    }
                }
            }
            if (!alreadyEncoded){
                buffer.unshift(input[k]);
            }
        }
        return buffer.join('');
    },

    /**Decodifica a string em formato anti-xss html.
     * 
     * @param {string} input 
     */
    FilterDecodeAntiXSS: function(input) {
        return input.replace(/&#(\d+);/g, function(match, dec) {
            return String.fromCharCode(dec);
        });
    }

}

module.exports = {
    SafetyFilterType: SafetyFilterType,
    SafetyAntiXssType: SafetyAntiXssType,
    SafetyFilter: SafetyFilter
}
	</script>
	<script>
		const Waf = require('./wafbase');

const DefaultSettings = {
  Rules: [
    { //Anti excessive header, remote file inclusion, scan tools and botnets rule.
      Dacls: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_USER_AGENT | Waf.WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,
          UserAgents:{
            RegexArray:[/(DirBuster|OWASP_DIRBUSTER_PROJECT)/igm],
            MatchArray:[]
          },
          MethodTypes: "GET|POST|PUT|PATCH|DELETE|OPTIONS|COPY|HEAD|LOCK|UNLOCK|LINK|UNLINK|PURGE",
          Description: 'Dirb and Dirbuster directory mapping attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_USER_AGENT | Waf.WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,
          UserAgents:{
            RegexArray:[/(ATLAS|APPLEBOT|atSpider\/1\.0|autoemailspider|Atomic_Email_Hunter|ContactBot\/0\.2|ContentSmartz|DataCha0s|DBrowse 1\.4(b|d){0,1}|Demo\sBot\s(DOT|Z)\s16b|DSurf15|eCatch\/3\.0|8484\sBoston\sProject\sv\s1\.0)/igm],
            MatchArray:[]
          },
          MethodTypes: "GET|POST|PUT|PATCH|DELETE|OPTIONS|COPY|HEAD|LOCK|UNLOCK|LINK|UNLINK|PURGE",
          Description: 'Common dangerous Botnets trying to steal information.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_USER_AGENT | Waf.WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,
          UserAgents:{
            RegexArray:[/(?:acunetix|analyzer|AhrefsBot|backdoor|bandit|blackwidow|BOT for JCE|core-project|dts agent|emailmagnet|ex(ploit|tract)|flood|grabber|harvest|httrack|havij|hunter|indy library|inspect|LoadTimeBot|mfibot|Microsoft URL Control|Miami Style|morfeus|nessus|NetLyzer|pmafind|scanner|siphon|spbot|sqlmap|survey|teleport|updown_tester|xovibot|masscan)/igm],
            MatchArray:[]
          },
          MethodTypes: "GET|POST|PUT|PATCH|DELETE|OPTIONS|COPY|HEAD|LOCK|UNLOCK|LINK|UNLINK|PURGE",
          Description: 'Known Botnet or Scan tool.'
        }
      ],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_HEADERS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Headers: {
            NameArray: [],
            RegexArray: [/^.{1024}/igm],
            MatchArray: []
          },

          Description: 'Excessive header length, possible Header DoS attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray: [],
            MatchArray: [],
            RegexArray: [/(INCLUDE|REQUIRE)(?:_ONCE){0,1}/igm]
          },

          ParamStrings:{
            MatchArray: [],
            RegexArray: [/(INCLUDE|REQUIRE)(?:_ONCE){0,1}/igm]
          },

          Description: 'Possible Remote File Inclusion attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray: [],
            MatchArray: [],
            RegexArray: [/^(?:ftp):\/\/[^\/]+\/.+/i]
          },

          ParamStrings:{
            MatchArray: [],
            RegexArray: [/^(?:ftp):\/\/[^\/]+\/.+/i]
          },

          Description: 'Possible Remote File Inclusion attack by remote FTP host.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray: [],
            MatchArray: [],
            RegexArray: [/(?:\\x[a-f0-9]{2,4}){25}/igm]
          },

          ParamStrings:{
            MatchArray: [],
            RegexArray: [/(?:\\x[a-f0-9]{2,4}){25}/igm]
          },

          Description: 'Excessive hexadecimal field.'
        }
      ]
    },
    { //Anti path traversal and data exposure rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(\.\.(\/|\\)|\.\.%(2F|5C))+/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(\.\.(\/|\\)|\.\.%(2F|5C))+/igm],
            MatchArray:[]
          },

          Description: 'Path traversal attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/HTTP_RAW_POST_DATA|HTTP_(?:POS|GE)T_VARS/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/HTTP_RAW_POST_DATA|HTTP_(?:POS|GE)T_VARS/igm],
            MatchArray:[]
          },

          Payloads:{
            MatchArray:[],
            RegexArray:[/HTTP_RAW_POST_DATA|HTTP_(?:POS|GE)T_VARS/igm]
          },

          Description: 'Data exposure exploitation attempt.'
        }
      ]
    },
    { //Anti data exposure and XSS US-ASCII based rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/phpinfo.php/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/phpinfo.php/igm],
            MatchArray:[]
          },

          Description: 'Data exposure exploitation attempt.'
        },
        {
          //https://github.com/SpiderLabs/owasp-modsecurity-crs/issues/1645
          //https://owasp.org/www-community/xss-filter-evasion-cheatsheet

          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_HEADERS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\xBC\/script\xBE/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\xBC\/script\xBE/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\xBC\/script\xBE/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\xBC\/script\xBE/igm],
            MatchArray:[]
          },

          Description: 'XSS attack by 0xbc, 0xbe unescaped char.'
        }
      ]
    },
    { //Anti XSS and SSI command execution attacks rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(\'|\"){0,1}(JAVA|VB)SCRIPT:.(\'|\"){0,1}/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(\'|\"){0,1}(JAVA|VB)SCRIPT:.(\'|\"){0,1}/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/(\'|\"){0,1}(JAVA|VB)SCRIPT:.(\'|\"){0,1}/igm],
            MatchArray:[]
          },

          Description: 'XSS attack by invoke prefix method in request.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(EVAL|ALERT|CONFIRM)+(\()+(\'|\")+.*?(\'|\")+(\))+\;?/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(EVAL|ALERT|CONFIRM)+(\()+(\'|\")+.*?(\'|\")+(\))+\;?/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/(EVAL|ALERT|CONFIRM)+(\()+(\'|\")+.*?(\'|\")+(\))+\;?/igm],
            MatchArray:[]
          },

          Description: 'XSS attack by eval or local function call.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/<!--#(?:CONFIG|ECHO|EXEC|FLASTMOD|FSIZE|INCLUDE)\b.+?-->/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/<!--#(?:CONFIG|ECHO|EXEC|FLASTMOD|FSIZE|INCLUDE)\b.+?-->/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/<!--#(?:CONFIG|ECHO|EXEC|FLASTMOD|FSIZE|INCLUDE)\b.+?-->/igm],
            MatchArray:[]
          },

          Description: 'SSI Command injection attack.'
        }
      ]
    },
    { //Anti mail injection and remote code execution (RCE) rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\x0A\b((Reply-)?To|B?Cc|Content-(Td|Type)\w?)\b\s*:.*?\@.+/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\x0A\b((Reply-)?To|B?Cc|Content-(Td|Type)\w?)\b\s*:.*?\@.+/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\x0A\b((Reply-)?To|B?Cc|Content-(Td|Type)\w?)\b\s*:.*?\@.+/igm],
            MatchArray:[]
          },

          Description: 'Mail header injection attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(?:<\?[\s\S]+)|#!\/(?:USR|BIN)\/.+?\s/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(?:<\?[\s\S]+)|#!\/(?:USR|BIN)\/.+?\s/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/(?:<\?[\s\S]+)|#!\/(?:USR|BIN)\/.+?\s/igm],
            MatchArray:[]
          },

          Description: 'Remote shellcode execution attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_COOKIES,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\b(?:eval)\s*\(\s*(?:base64_decode|exec|file_get_contents|gzinflate|passthru|shell_exec|stripslashes|system)\s*\((\)?\)?);?/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\b(?:eval)\s*\(\s*(?:base64_decode|exec|file_get_contents|gzinflate|passthru|shell_exec|stripslashes|system)\s*\((\)?\)?);?/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\b(?:eval)\s*\(\s*(?:base64_decode|exec|file_get_contents|gzinflate|passthru|shell_exec|stripslashes|system)\s*\((\)?\)?);?/igm],
            MatchArray:[]
          },

          Cookies:{
            NameArray:[],
            RegexArray:[/\b(?:eval)\s*\(\s*(?:base64_decode|exec|file_get_contents|gzinflate|passthru|shell_exec|stripslashes|system)\s*\((\)?\)?);?/igm],
            MatchArray:[]
          },

          Description: 'Remote code execution using PHP payload.'
        }
      ]
    },
    { //Anti XSS rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_HEADERS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\<\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)[^\>]*\>(.*?)\<\s*\/\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)\>/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\<\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)[^\>]*\>(.*?)\<\s*\/\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)\>/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\<\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)[^\>]*\>(.*?)\<\s*\/\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)\>/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\<\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)[^\>]*\>(.*?)\<\s*\/\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)\>/igm],
            MatchArray:[]
          },

          Description: 'XSS attack using HTML common tags.'
        }
      ]
    },
    { //PHP Vuln. CVE-2012-1823 and Unrestricted File Upload rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_HEADERS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Payloads:{
            RegexArray:[/^-[bcndfiswzT].{20}/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^-[bcndfiswzT].{20}/igm],
            MatchArray:[]
          },

          Description: 'PHP Vulnerability CVE-2012-1823.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_FILE_EXT,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          FileExtensions:{
            ExtensionsArray:[/\x70\x68(\x70(3|4|5|S|)|\x74\x6d\x6c)/igm],
            RegexArray:[],
            MatchArray:[]
          },

          Description: 'PHP Unrestricted File Upload attack.'
        }
      ]
    },
    { //Anti ASP(X) Unrestricted File Upload rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_FILE_EXT,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          FileExtensions:{
            ExtensionsArray:[/asp(x)?(::)?\$?(Index_Allocation|Data)?/igm],
            RegexArray:[],
            MatchArray:[]
          },

          Description: 'ASP(X) Unrestricted File Upload attack.'
        }
      ]
    },
    { //Anti SQL Injection rule
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^.{0,100}\sSLEEP\s\d+/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^.{0,100}\sSLEEP\s\d+/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^.{0,100}\sSLEEP\s\d+/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection Time-Based.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^'/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^'/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^'/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection using unescaped single-quote.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bAND\s+EXTRACTVALUE\s\w/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bAND\s+EXTRACTVALUE\s\w/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bAND\s+EXTRACTVALUE\s\w/igm],
            MatchArray:[]
          },

          Description: 'Blind SQL Injection'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\'\s){0,1}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\'\s){0,1}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(\'\s){0,1}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/igm],
            MatchArray:[]
          },

          Description: 'Tautology assertion SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(?:\b|\d)INSERT\b.+?(?:\b|\d)INTO\b.{1,150}(?:\b|\d)VALUES\b.*?\(.+?\)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(?:\b|\d)INSERT\b.+?(?:\b|\d)INTO\b.{1,150}(?:\b|\d)VALUES\b.*?\(.+?\)/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/(?:\b|\d)INSERT\b.+?(?:\b|\d)INTO\b.{1,150}(?:\b|\d)VALUES\b.*?\(.+?\)/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection by Insert method.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(?:ADMIN(?:ISTRATOR)?)['\"].*?(?:--|#|\/\\*)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(?:ADMIN(?:ISTRATOR)?)['\"].*?(?:--|#|\/\\*)/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(?:ADMIN(?:ISTRATOR)?)['\"].*?(?:--|#|\/\\*)/igm],
            MatchArray:[]
          },

          Description: 'Admin comment based SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bUNION\s+SELECT\b.{1,128}(FROM|WHERE)\b/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bUNION\s+SELECT\b.{1,128}(FROM|WHERE)\b/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bUNION\s+SELECT\b.{1,128}(FROM|WHERE)\b/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection by UNION method.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(?:\b|\d)+\s(?:CEIL|CONCAT|CONV|FLOOR|VERSION)\b/ig],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(?:\b|\d)+\s(?:CEIL|CONCAT|CONV|FLOOR|VERSION)\b/ig],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(?:\b|\d)+\s(?:CEIL|CONCAT|CONV|FLOOR|VERSION)\b/ig],
            MatchArray:[]
          },

          Description: 'SQL Injection by common functions. #1'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(?:\b(?:null|and|or)\b|\|\||&&)\s*.{0,50}\bselect\b./im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(?:\b(?:null|and|or)\b|\|\||&&)\s*.{0,50}\bselect\b./im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/(?:\b(?:null|and|or)\b|\|\||&&)\s*.{0,50}\bselect\b./im],
            MatchArray:[]
          },

          Description: 'Suspicious NULL assertion injection in SQL Injection attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(?:\b(?:null|and|or)\b|\|\||&&)?\s*union\s+(?:all\s+)?select\b/i],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(?:\b(?:null|and|or)\b|\|\||&&)?\s*union\s+(?:all\s+)?select\b/i],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(?:\b(?:null|and|or)\b|\|\||&&)?\s*union\s+(?:all\s+)?select\b/i],
            MatchArray:[]
          },

          Description: 'Suspicious NULL assertion based SQL injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?\d+.{0,32}(?:\bAND\b.{0,64})?\b(?:UNION|SELECT)\b/im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?\d+.{0,32}(?:\bAND\b.{0,64})?\b(?:UNION|SELECT)\b/im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^-?\d+.{0,32}(?:\bAND\b.{0,64})?\b(?:UNION|SELECT)\b/im],
            MatchArray:[]
          },

          Description: 'Negative number based SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/.{2,}\bORDER\sBY\s*(\d*|\w*)?/im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/.{2,}\bORDER\sBY\s*(\d*|\w*)?/im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/.{2,}\bORDER\sBY\s*(\d*|\w*)?/im],
            MatchArray:[]
          },

          Description: 'Order by column based SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/.{2,}\b(UNION|INTERSECT|EXCEPT)\s*SELECT\s*(NULL[,\s]*)+(?:--)/im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/.{2,}\b(UNION|INTERSECT|EXCEPT)\s*SELECT\s*(NULL[,\s]*)+(?:--)/im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/.{2,}\b(UNION|INTERSECT|EXCEPT)\s*SELECT\s*(NULL[,\s]*)+(?:--)/im],
            MatchArray:[]
          },

          Description: 'Union, intersect or except based method to SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\'|\s){0,}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\'|\s){0,}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(\'|\s){0,}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/im],
            MatchArray:[]
          },

          Description: 'Improved tautology assertion based SQL Injection.'
        }
      ]
    },
    { //Anti Null byte rule
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\x00/gm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\x00/gm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\x00/gm],
            MatchArray:[]
          },

          Description: 'ASCII character 0x00 (NULL BYTE) injection attack.'
        }
      ]
    },
    { //Anti XSS rule
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\bFunction\s*[({](.|\s)*?[})]\s*\(.*?\)|\bfunction\s*\(.*?\)\s*{(.|\s)*?}|(?:\[|new)\s*class\s*extends\b|\bArray\s*.*\s*from\b/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\bFunction\s*[({](.|\s)*?[})]\s*\(.*?\)|\bfunction\s*\(.*?\)\s*{(.|\s)*?}|(?:\[|new)\s*class\s*extends\b|\bArray\s*.*\s*from\b/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\bFunction\s*[({](.|\s)*?[})]\s*\(.*?\)|\bfunction\s*\(.*?\)\s*{(.|\s)*?}|(?:\[|new)\s*class\s*extends\b|\bArray\s*.*\s*from\b/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\bFunction\s*[({](.|\s)*?[})]\s*\(.*?\)|\bfunction\s*\(.*?\)\s*{(.|\s)*?}|(?:\[|new)\s*class\s*extends\b|\bArray\s*.*\s*from\b/igm],
            MatchArray:[]
          },

          Description: 'XSS attack by function, class or array injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\b(?:document|window|this)\s*\[.+?\]\s*[\[(]/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\b(?:document|window|this)\s*\[.+?\]\s*[\[(]/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\b(?:document|window|this)\s*\[.+?\]\s*[\[(]/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\b(?:document|window|this)\s*\[.+?\]\s*[\[(]/igm],
            MatchArray:[]
          },

          Description: 'XSS DOM based injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/<.+?\bon[a-z]{3,19}\b\s*=.+?>/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/<.+?\bon[a-z]{3,19}\b\s*=.+?>/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/<.+?\bon[a-z]{3,19}\b\s*=.+?>/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/<.+?\bon[a-z]{3,19}\b\s*=.+?>/igm],
            MatchArray:[]
          },

          Description: 'XSS DOM based by HTML event attributes.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\bdocument\s*\.\s*(?:body|cookie|location|open|write(?:ln)?)\s*(\(|\[|\=\s*(\"|\')+)+.*(\)|\]|(\"|\')+)+/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\bdocument\s*\.\s*(?:body|cookie|location|open|write(?:ln)?)\s*(\(|\[|\=\s*(\"|\')+)+.*(\)|\]|(\"|\')+)+/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\bdocument\s*\.\s*(?:body|cookie|location|open|write(?:ln)?)\s*(\(|\[|\=\s*(\"|\')+)+.*(\)|\]|(\"|\')+)+/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\bdocument\s*\.\s*(?:body|cookie|location|open|write(?:ln)?)\s*(\(|\[|\=\s*(\"|\')+)+.*(\)|\]|(\"|\')+)+/igm],
            MatchArray:[]
          },

          Description: 'XSS DOM based injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/<.+?\b(?:href|(?:form)?action|background|code|data|location|name|poster|src|value)\s*=\s*['\"]?(?:(?:f|ht)tps?:)?\/\/\w+\.\w*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/<.+?\b(?:href|(?:form)?action|background|code|data|location|name|poster|src|value)\s*=\s*['\"]?(?:(?:f|ht)tps?:)?\/\/\w+\.\w*/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/<.+?\b(?:href|(?:form)?action|background|code|data|location|name|poster|src|value)\s*=\s*['\"]?(?:(?:f|ht)tps?:)?\/\/\w+\.\w*/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/<.+?\b(?:href|(?:form)?action|background|code|data|location|name|poster|src|value)\s*=\s*['\"]?(?:(?:f|ht)tps?:)?\/\/\w+\.\w*/igm],
            MatchArray:[]
          },

          Description: 'XSS DOM poisoning based by common attributes.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\W(?:background(-image)?|-moz-binding)\s*:[^}]*?\burl\s*\([^)]+?(https?:)?\/\/\w/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\W(?:background(-image)?|-moz-binding)\s*:[^}]*?\burl\s*\([^)]+?(https?:)?\/\/\w/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\W(?:background(-image)?|-moz-binding)\s*:[^}]*?\burl\s*\([^)]+?(https?:)?\/\/\w/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\W(?:background(-image)?|-moz-binding)\s*:[^}]*?\burl\s*\([^)]+?(https?:)?\/\/\w/igm],
            MatchArray:[]
          },

          Description: 'XSS possible deface attack by embedded (S)CSS attributes.'
        },
      ]
    },
    { //Anti SQL injection rule.
      Dacls: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_USER_AGENT,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,
          UserAgents:{
            RegexArray:[/^(\uff07|\d\s*\uff07)/gm],
            MatchArray:[]
          },
          Description: 'SQL Injection single quote UTF-16 beginning string.'
        }
      ],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\uff07|\d\s*\uff07)/gm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\uff07|\d\s*\uff07)/gm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\uff07|\d\s*\uff07)/gm],
            MatchArray:[]
          },

          Description: 'SQL Injection single quote UTF-16 beginning string.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(OR|AND)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(OR|AND)/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(OR|AND)/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection boolean blind based #1.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection "UNION" or "ORDER BY" based #1.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(ORDER\s*BY|UNION\s*ALL)\s*(SELECT|ORDER\s*BY)*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(ORDER\s*BY|UNION\s*ALL)\s*(SELECT|ORDER\s*BY)*/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(ORDER\s*BY|UNION\s*ALL)\s*(SELECT|ORDER\s*BY)*/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection "UNION" or "ORDER BY" based #2.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(OR|AND)\s*((SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))|(\'|\uff07)\w+(\'|\uff07)(\=|\!\=)+(\'|\uff07)\w+(\'|\uff07)|-?\d+\s*\=\s*(\(|SELECT|\w+)|\s*\w*\s*IN\s*\()/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(OR|AND)\s*((SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))|(\'|\uff07)\w+(\'|\uff07)(\=|\!\=)+(\'|\uff07)\w+(\'|\uff07)|-?\d+\s*\=\s*(\(|SELECT|\w+)|\s*\w*\s*IN\s*\()/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(OR|AND)\s*((SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))|(\'|\uff07)\w+(\'|\uff07)(\=|\!\=)+(\'|\uff07)\w+(\'|\uff07)|-?\d+\s*\=\s*(\(|SELECT|\w+)|\s*\w*\s*IN\s*\()/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection boolean blind based #2.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*(RLIKE|WAITFOR)\s*\w*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*(RLIKE|WAITFOR)\s*\w*/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*(RLIKE|WAITFOR)\s*\w*/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection using "RLIKE" or "WAITFOR" command.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*;(SELECT|WAITFOR|DECLARE)\s*\w*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*;(SELECT|WAITFOR|DECLARE)\s*\w*/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*;(SELECT|WAITFOR|DECLARE)\s*\w*/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection using "SELECT", "WAITFOR" or "DECLARE" command.'
        }
      ]
    },
    { //Anti Advanced SQL Injection rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection using "ORDER BY" or "UNION" operators.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d+|\w+)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*\b(AND|OR)\s*(SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d+|\w+)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*\b(AND|OR)\s*(SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^-?(\d+|\w+)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*\b(AND|OR)\s*(SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection boolean blind based.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3};\s*(SELECT|DECLARE|WAITFOR|CREATE|\()\s*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3};\s*(SELECT|DECLARE|WAITFOR|CREATE|\()\s*/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3};\s*(SELECT|DECLARE|WAITFOR|CREATE|\()\s*/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection using "SELECT", "DECLARE", "WAITFOR" or "CREATE" methods.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?\w*(\'|\"|\uff07)*\s*[\(\)]{1,3}\s*(AND|SELECT|WHERE|AS|;)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?\w*(\'|\"|\uff07)*\s*[\(\)]{1,3}\s*(AND|SELECT|WHERE|AS|;)/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^-?\w*(\'|\"|\uff07)*\s*[\(\)]{1,3}\s*(AND|SELECT|WHERE|AS|;)/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection using very dangerous SQLMAP Payloads LEVEL 4.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^\w+\`\=\`.+\`\s*(AND|OR|\w+|\;)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^\w+\`\=\`.+\`\s*(AND|OR|\w+|\;)/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^\w+\`\=\`.+\`\s*(AND|OR|\w+|\;)/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection boolean blind based #3.'
        }
      ]
    },
    { //Anti payload obfuscation and PHP Remote Code Execution (RCE) rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(%u(\w{2}|\w{4})){16}/gm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(%u(\w{2}|\w{4})){16}/gm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(%u(\w{2}|\w{4})){16}/gm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(%u(\w{2}|\w{4})){16}/gm],
            MatchArray:[]
          },

          Description: 'Possible UTF-8/16 encoded and obfuscated payload injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\b(XDEBUG_SESSION_START|invokefunction|call_user_func_array)\b/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\b(XDEBUG_SESSION_START|invokefunction|call_user_func_array)\b/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\b(XDEBUG_SESSION_START|invokefunction|call_user_func_array)\b/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\b(XDEBUG_SESSION_START|invokefunction|call_user_func_array)\b/igm],
            MatchArray:[]
          },

          Description: 'Remote code execution (RCE) attack attempt.'
        }
      ]
    },
    { //Anti prototype pollution rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Headers:{
            NameArray:[],
            RegexArray:[/^application\/json/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/(?:(?:{|%7B|%u007B|\[|%5B|%u005B)(?:.|\s)*(?:"|%22|%u0022)(?:__proto__|toString|toLocaleString|isPrototypeOf|hasOwnProperty|propertyIsEnumerable|valueOf|__defineGetter__|__defineSetter__|__lookupGetter__|constructor)(?:"|%22|%u0022)(?:.|\s)*(?:}|%7D|%u007D|\]|%5D|%u005D))/igm],
            MatchArray:[]
          },

          Description: 'Possible Prototype Pollution and Remote Code Execution #1.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_COOKIES | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Cookies:{
            NameArray:[],
            RegexArray:[/(?:(?:{|%7B|%u007B|\[|%5B|%u005B)(?:.|\s)*(?:"|%22|%u0022)(?:__proto__|toString|toLocaleString|isPrototypeOf|hasOwnProperty|propertyIsEnumerable|valueOf|__defineGetter__|__defineSetter__|__lookupGetter__|constructor)(?:"|%22|%u0022)(?:.|\s)*(?:}|%7D|%u007D|\]|%5D|%u005D))/igm],
            MatchArray:[]
          },

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(?:(?:{|%7B|%u007B|\[|%5B|%u005B)(?:.|\s)*(?:"|%22|%u0022)(?:__proto__|toString|toLocaleString|isPrototypeOf|hasOwnProperty|propertyIsEnumerable|valueOf|__defineGetter__|__defineSetter__|__lookupGetter__|constructor)(?:"|%22|%u0022)(?:.|\s)*(?:}|%7D|%u007D|\]|%5D|%u005D))/igm],
            MatchArray:[]
          },

          Description: 'Possible Prototype Pollution and Remote Code Execution #2.'
        }
      ]
    },
    { // DoS rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_ATTEMPTS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Attempts: {
            MaxAttempts: 1024,
            RenewAttemptsInterval: 600
          },

          Description: 'Possible Denial of Service attack.'
        }
      ]
    }
  ],
  Callbacks: [],
  AccessTable: []
}

module.exports = {

  DefaultSettings: DefaultSettings

}
	</script>
	<script>
		const Ip = require('ip');
const fs = require('fs');
const path = require('path');
const os = require('os');
const colors = require('colors');

const PROTOCOL_IPV4 = 0x01;
const	PROTOCOL_IPV6 = 0x02;

function CheckFlags(value, flag){
  return ((value & flag) === flag);
}

function CookieParse(str, options) {
  if (typeof str !== 'string') {
    return {};
  }

  var obj = {}
  var opt = options || {};
  var pairs = str.split(/; */);
  var dec = opt.decode || decodeURIComponent;

  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var eq_idx = pair.indexOf('=');

    if (eq_idx < 0) {
      continue;
    }

    var key = pair.substr(0, eq_idx).trim()
    var val = pair.substr(++eq_idx, pair.length).trim();

    if ('"' == val[0]) {
      val = val.slice(1, -1);
    }

    if (undefined == obj[key]) {
      obj[key] = (function (str, decode) {
        try {
          return decodeURIComponent(str);
        } catch (e) {
          return str;
        }
      })(val, dec);
    }
  }

  return obj;
}

function EnumAvailableFiles(req, enumProc) {
  if (req.files) {
    let breakEnum = false;
    for (let fieldname in req.files) {
      if (!breakEnum) {
        if (req.files[fieldname].length) {
          for (let idx = 0; idx < req.files[fieldname].length; idx++) {
            let finfo = req.files[fieldname][idx];
            let fname = finfo.name || finfo.filename || finfo.originalname;
            enumProc(finfo, fname, () => {
              breakEnum = true;
              idx = req.files[fieldname].length;
            });
          }
        }
        else {
          let finfo = req.files[fieldname];
          let fname = finfo.name || finfo.filename || finfo.originalname;
          enumProc(finfo, fname, () => {
            breakEnum = true;
          });
        }
      }
      else {
        break;
      }
    }
  }
}

function AddEntryInAccessTable(ptrWafObj, ptrFlt, targIp, networkLayer) {
  let uptimestamp = new Date().getTime();
  let downtimestamp = (uptimestamp - (ptrFlt.Attempts.RenewAttemptsInterval * 0x3e8));
  let accessList = [];
  let tableResult = {};
  let oldAccess = [];
  let inc_len = 0;
  let exceeded = true;
  switch (networkLayer) {
    case PROTOCOL_IPV4:
      accessList = ptrWafObj.AccessTable.filter(function (ptrAccessEntry, idx, ptrAccessTable) {
        if (((ptrAccessEntry.Timestamp < downtimestamp) || (ptrAccessEntry.Timestamp > uptimestamp)) && Ip.isEqual(ptrAccessEntry.Ipv4Address, targIp)) {
          oldAccess.push(ptrAccessTable[idx]);
        }
        return (((ptrAccessEntry.Timestamp >= downtimestamp) && (ptrAccessEntry.Timestamp <= uptimestamp)) && Ip.isEqual(ptrAccessEntry.Ipv4Address, targIp));
      });
      for (let r_idx = 0; r_idx < oldAccess.length; r_idx++) {
        ptrWafObj.AccessTable.splice(ptrWafObj.AccessTable.indexOf(oldAccess[r_idx]), 1);
      }
      if (accessList.length < ptrFlt.Attempts.MaxAttempts) {
        ptrWafObj.AccessTable.push({ Ipv4Address: targIp, Ipv6Address: '', Timestamp: new Date().getTime() });
        exceeded = false;
        inc_len++;
      }
      tableResult = {
        RemainingAttempts: (accessList.length > ptrFlt.Attempts.MaxAttempts ? 0 : (ptrFlt.Attempts.MaxAttempts - (accessList.length + inc_len))),
        CurrentAttempts: accessList.length + inc_len,
        Exceeded: exceeded
      };
      accessList = null;
      return tableResult;
    case PROTOCOL_IPV6:
      accessList = ptrWafObj.AccessTable.filter(function (ptrAccessEntry, idx, ptrAccessTable) {
        if ((ptrAccessEntry.Timestamp < downtimestamp) || (ptrAccessEntry.Timestamp > uptimestamp) && Ip.isEqual(ptrAccessEntry.Ipv6Address, targIp)) {
          oldAccess.push(ptrAccessTable[idx]);
        }
        return (((ptrAccessEntry.Timestamp >= downtimestamp) && (ptrAccessEntry.Timestamp <= uptimestamp)) && Ip.isEqual(ptrAccessEntry.Ipv6Address, targIp));
      });
      for (let r_idx = 0; r_idx < oldAccess.length; r_idx++) {
        ptrWafObj.AccessTable.splice(ptrWafObj.AccessTable.indexOf(oldAccess[r_idx]), 1);
      }
      if (accessList.length < ptrFlt.Attempts.MaxAttempts) {
        ptrWafObj.AccessTable.push({ Ipv4Address: '', Ipv6Address: targIp, Timestamp: new Date().getTime() });
        exceeded = false;
        inc_len++;
      }
      tableResult = {
        RemainingAttempts: (accessList.length > ptrFlt.Attempts.MaxAttempts ? 0 : (ptrFlt.Attempts.MaxAttempts - (accessList.length + inc_len))),
        CurrentAttempts: accessList.length + inc_len,
        Exceeded: exceeded
      };
      accessList = null;
      return tableResult;
    default:
      return false;
  }
}

function DisplayBlockedEvent(event){
  console.log(
    `-> Mini-WAF has protected your server now!`.white.bgRed + os.EOL +
    `   Blocked triggered event by remote IP address: ${event.request.ip} at ${new Date().toLocaleString()}!`.red + os.EOL +
    `   Reason of blocking action: ${event.reason.green}`.yellow + os.EOL +
    `   Method type: ${event.request.method.red}`.yellow + os.EOL +
    `   Port number: ${String(event.request.connection.localPort).red}`.yellow + os.EOL +
    `   Traffic direction: ${String((CheckFlags(event.wafComp.Directions, 0x01) && CheckFlags(event.wafComp.Directions, 0x02) ? 'Inbound | Outbound' : (CheckFlags(event.wafComp.Directions, 0x01) ? 'Inbound' : (CheckFlags(event.wafComp.Directions, 0x02) ? 'Outbound' : 'None')))).red}`.yellow + os.EOL +
    `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16)).red}\n`.green
  );
}

function DisplayAuditEvent(event){
  console.log(
    `-> Mini-WAF has detected an event now!`.black.bgWhite + os.EOL +
    `   Triggered event by remote IP address: ${event.request.ip} at ${new Date().toLocaleString()}!`.yellow + os.EOL +
    `   Reason of audit action: ${event.reason.green}`.yellow + os.EOL +
    `   Method type: ${event.request.method.green}`.yellow + os.EOL +
    `   Port number: ${String(event.request.connection.localPort).green}`.yellow + os.EOL +
    `   Traffic direction: ${String((CheckFlags(event.wafComp.Directions, 0x01) && CheckFlags(event.wafComp.Directions, 0x02) ? 'Inbound | Outbound' : (CheckFlags(event.wafComp.Directions, 0x01) ? 'Inbound' : (CheckFlags(event.wafComp.Directions, 0x02) ? 'Outbound' : 'None')))).red}`.yellow + os.EOL +
    `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16)).yellow}\n`.green
  );
}

function DisplayUnhandledExceptionEvent(event){
  console.log(
    `-> Mini-WAF has protected your server now!`.white.bgRed + os.EOL +
    `   Unhandled exception triggered at ${new Date().toLocaleString()}!`.red + os.EOL +
    `   Exception name: ${event.name.green}`.yellow + os.EOL +
    `   Exception message: ${event.message.red}`.yellow + os.EOL +
    `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16)).red}\n`.green
  );
}

function DisplayNewConnection(req){
  console.log(`[${(new Date()).toLocaleTimeString().cyan}] [${req.protocol.toUpperCase().cyan} ${req.method.cyan}] [${'INFO'.green}] new incoming connection detected from [${String(req.ip).yellow}] with User Agent [${req.headers["user-agent"]}].`);
}

function WriteEventToLog(event, logType, fname) {
  let WriteCallback = () => {
    const wfstream = fs.createWriteStream(path.join(__dirname, 'logs', fname), { flags: 'a' });
    if (logType.toUpperCase() == 'BLOCK') {
      wfstream.write(
        `-> Mini-WAF has protected your server now!${os.EOL}` +
        `   Blocked triggered event by remote IP address: ${event.request.ip} at ${new Date().toLocaleString()}!${os.EOL}` +
        `   Reason of blocking action: ${event.reason}${os.EOL}` +
        `   Method type: ${event.request.method}${os.EOL}` +
        `   Port number: ${String(event.request.connection.localPort)}${os.EOL}` +
        `   Traffic direction: ${String((CheckFlags(event.wafComp.Directions, 0x01) && CheckFlags(event.wafComp.Directions, 0x02) ? 'Inbound | Outbound' : (CheckFlags(event.wafComp.Directions, 0x01) ? 'Inbound' : (CheckFlags(event.wafComp.Directions, 0x02) ? 'Outbound' : 'None'))))}${os.EOL}` +
        `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16))}${os.EOL}${os.EOL}`
      );
    }
    else if (logType.toUpperCase() == 'AUDIT') {
      wfstream.write(
        `-> Mini-WAF has detected an event now!${os.EOL}` +
        ` Triggered event by remote IP address: ${event.request.ip} at ${new Date().toLocaleString()}!${os.EOL}` +
        ` Reason of audit action: ${event.reason}${os.EOL}` +
        ` Method type: ${event.request.method}${os.EOL}` +
        ` Port number: ${String(event.request.connection.localPort)}${os.EOL}` +
        ` Traffic direction: ${String((CheckFlags(event.wafComp.Directions, 0x01) && CheckFlags(event.wafComp.Directions, 0x02) ? 'Inbound | Outbound' : (CheckFlags(event.wafComp.Directions, 0x01) ? 'Inbound' : (CheckFlags(event.wafComp.Directions, 0x02) ? 'Outbound' : 'None'))))}${os.EOL}` +
        ` Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16))}${os.EOL}${os.EOL}`
      );
    }
    else if (logType.toUpperCase() == 'EXCEPTION') {
      wfstream.write(
        `-> Mini-WAF has protected your server now!${os.EOL}` +
        `   Unhandled exception triggered at ${new Date().toLocaleString()}!${os.EOL}` +
        `   Exception name: ${event.name}${os.EOL}` +
        `   Exception message: ${event.message}${os.EOL}` +
        `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16))}${os.EOL}${os.EOL}`
      );
    }
    wfstream.end();
  }

  let CheckAndWrite = () => {
    fs.access(path.join(__dirname, 'logs'), fs.constants.F_OK, (_err) => {
      if (_err){
        fs.writeFile(path.join(__dirname, 'logs', fname), `#========================================= Mini-WAF Log File =========================================#${os.EOL}`, { flags: 'a' }, WriteCallback);
      }
      WriteCallback();
    });
  }
  fs.access(path.join(__dirname, 'logs'), fs.constants.F_OK, (err) => {
    if (!err){
      if (fs.lstatSync(path.join(__dirname, 'logs')).isFile()) {
        console.log('MINI-WAF ENCOUNTERED AN ERROR!'.bgRed.white);
        return;
      }
      CheckAndWrite();
    }
    else{
      try{
        fs.mkdirSync(path.join(__dirname, 'logs'));
      } catch(e){
        console.log('MINI-WAF ENCOUNTERED AN ERROR!'.bgRed.white + os.EOL + 'The log directory cant be created as \'' + path.join(__dirname, 'logs') + '\'');
        return;
      }
      CheckAndWrite();
    }
  });
}

function ApplyArgument(oldArgs, newArg){
  let bFirst = true;
  let newArgs = [];
  for (let idx = 0; idx <= oldArgs.length; idx++){
    if (!bFirst){
      newArgs.push(oldArgs[String(idx-1)]);
    }
    else{
      bFirst = false;
      newArgs.push(newArg);
    }
  }
  return newArgs;
}

function Hook(targName, ptrStub, ptrParent){
  let PatchAddr = ptrParent[targName];
	let ptrHookObj = {
		TargetName: targName,
		Stub: ptrStub,
    Parent: ptrParent,
    PatchAddr: ptrParent[targName],
    OriginalFunction: function(){
      try {
        ptrParent[targName] = PatchAddr;
        let result = ptrParent[targName].apply(ptrParent, arguments);
        ptrParent[targName] = ptrStub;
        return result;
      } catch (e){ return; }
    },
    Unhook: function(){ ptrParent[targName] = PatchAddr; },
    Hook: function(){ ptrParent[targName] = ptrStub; }
  }
  Object.defineProperty(ptrStub, 'name', {name: targName});
  Object.defineProperty(ptrParent[targName], 'name', {name: targName});
	ptrParent[targName] = ptrStub;
	return ptrHookObj;
}



module.exports = {

  CheckFlags: CheckFlags,
  CookieParse: CookieParse,
  EnumAvailableFiles: EnumAvailableFiles,
  AddEntryInAccessTable: AddEntryInAccessTable,
  DisplayBlockedEvent: DisplayBlockedEvent,
  DisplayAuditEvent: DisplayAuditEvent,
  DisplayUnhandledExceptionEvent: DisplayUnhandledExceptionEvent,
  DisplayNewConnection: DisplayNewConnection,
  WriteEventToLog: WriteEventToLog,
  ApplyArgument: ApplyArgument,
  Hook: Hook

}
	</script>
	<script>
		let proxy = require("express-http-proxy");
let app = require("express")();
let sanitizeHTML = require("sanitize-html");
let colors = require("colors");
colors.setTheme({
  silly: "rainbow",
  info: "green",
  data: "grey",
  warn: "yellow",
  error: "red",
});

const options = {
  allowedTags: [],
};

let headers = ["Content-Type", "user-agent"];

/**
 * sanitizeRequestURL
 *
 * @param Request object
 * @return String of sanitize URL.
 */
let sanitizeRequestURL = function (req) {
  let prevURL = req.url;
  let decodeURL = decodeURI(req.url);
  decodeURL = sanitize(decodeURL);
  let newURL = encodeURI(decodeURL);
  if (newURL !== prevURL) {
    console.log("Alert! Reflected XSS Detected".error + " Content: " + prevURL);
  }
  return newURL;
};

let filterRequests = function () {
  return true;
};

function sanitize(content) {
  return sanitizeHTML(content, options);
}

/**
 * getURLParams
 *
 * @param Search string, beginning with '?'.
 *     For example: '?a=1&b=2'
 * @return Array of URL param objects.
 */
var getURLParams = function (search) {
  var params = [];
  var rawParams = search.substring(0).split("&");
  var param, index, name, value;

  for (var i = 0, len = rawParams.length; i < len; i++) {
    param = rawParams[i];
    index = param.indexOf("=");

    switch (true) {
      // Name and value are defined.
      // For example: ?a=1&b=2.
      case index > 0:
        name = param.substring(0, index);
        value = param.substring(index + 1);
        break;

      // Value is undefined.
      // For example: ?a&b.
      case index === -1:
        name = param;
        value = "";
        break;

      // Name  is undefined.
      // For example: ?=11111111&=2
      case index === 0:
        name = "";
        value = param.substring(index + 1);
        break;

      default:
        break;
    }

    params.push({
      name: name,
      value: value,
      denied: false,
    });
  }

  return params;
};

/**
 * sanitizeURLParams
 *
 * @param content object with parameters from URL
 * @return String with sanitize parameters.
 */
let sanitizeURLParams = function (content) {
  let prevContent = content;
  content = decodeURI(content);
  let sanitizeString = "";

  let arrFromParams = getURLParams(content);

  for (let i = 0; i < arrFromParams.length; i++) {
    sanitizeString +=
      arrFromParams[i].name + "=" + sanitize(arrFromParams[i].value) + "&";
  }
  content = sanitizeString;
  content = content.substring(0, content.length - 1);
  let newContent = encodeURI(content);
  if (newContent !== prevContent) {
    console.log(
      "Alert! Persistent XSS Detected".error + " Content:" + prevContent
    );
  }

  return newContent;
};

let sanitizeURLParamsJSON = function (content) {
  let prevContent = content;
  content = JSON.parse(content);
  let keys = Object.keys(content);

  for (let i = 0; i < keys.length; i++) {
    content[keys[i]] = sanitize(content[keys[i]]);
  }
  let newContent = JSON.stringify(content);
  if (prevContent !== newContent) {
    console.log(
      "Alert! Persistent XSS Detected".error + " Content: " + prevContent
    );
  }
  return newContent;
};

let reqBodyDecorator = function (bodyContent, srcReq) {
  let method = srcReq["method"];
  let content;
  if (method === "GET") {
    return bodyContent;
  } else {
    for (let i = 0; i < headers.length; i++) {}

    if (
      srcReq.header("Content-Type") ===
      "application/x-www-form-urlencoded; charset=UTF-8"
    ) {
      content = bodyContent.toString();
      content = sanitizeURLParams(content);
    } else if (
      srcReq.header("Content-Type") === "application/json; charset=UTF-8"
    ) {
      content = bodyContent.toString();
      content = sanitizeURLParamsJSON(content);
    } else {
      return bodyContent;
    }
    return Buffer.from(content, "utf-8");
  }
};
reqOptionsDecorator = function (proxyReqOpts) {
  return proxyReqOpts;
};

let resDecorator = function (proxyRes, proxyResData) {
  return proxyResData;
};

let resHeadDecorator = function (headers) {
  headers["X-XSS-Protection"] = "1";
  return headers;
};

app.use(
  "/",
  proxy("http://server:3000", {
    proxyReqPathResolver: sanitizeRequestURL,
    filter: filterRequests,
    // default
    userResDecorator: resDecorator,
    userResHeaderDecorator: resHeadDecorator,
    proxyReqBodyDecorator: reqBodyDecorator,
    proxyReqOptDecorator: reqOptionsDecorator,
    parseReqBody: true,
    memoizeHost: false,
    preserveHostHdr: true,
    reqAsBuffer: true,
  })
);

const port = 3001;

app.listen(port, () =>
  console.log(`Reverse-proxy-waf listening at http://localhost:${port}`)
);
	</script>
	<script>
		'use strict'

class WAFJS{

  constructor(config){

    // loading signatures file
    const { signatures } = require ('./signatures.json')

    // declaring holders for config related data
    this.allowedMethods = config.allowedMethods
    this.allowedContentTypes = config.contentTypes
    this.botSigs = signatures

    // declaring base regex expression to check bot signatures
    this.isBotCheckRegex = () => new RegExp(`(${this.botSigs.join('|')})`, 'i')
  }


  
  isBotCheck(userAgent){
    return this.isBotCheckRegex().test(userAgent)
  }

  extendBotSigs(signatures){
    this.botSigs = [...new Set(this.botSigs.concat(signatures))]
  }

  removeBotSig(signature){
    this.botSigs = this.botSigs.filter(sig => sig !== signature)
  }


  
  reqCheck(requestMethod, contentType){
   return !(this.allowedMethods.indexOf(requestMethod) < 0 || this.allowedContentTypes.indexOf(contentType) < 0)
  }

	</script>

	
		<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js"></script>
<body>
<canvas id="myChart" style="width:100%;max-width:600px"></canvas>
	

<script>
var xValues = [100,200,300,400,500,600,700,800,900,1000];

new Chart("myChart", {
  type: "line",
  data: {
    labels: xValues,
    datasets: [{ 
      data: [860,1140,1060,1060,1070,1110,1330,2210,7830,2478],
      borderColor: "red",
      fill: false
    }, { 
      data: [1600,1700,1700,1900,2000,2700,4000,5000,6000,7000],
      borderColor: "green",
      fill: false
    }, { 
      data: [300,700,2000,5000,6000,4000,2000,1000,200,100],
      borderColor: "blue",
      fill: false
    }]
  },
  options: {
    legend: {display: false}
  }
});
</script>
	
	
<meta name="description" content="" />
<style>
body
{
	background-color: #fffafa59;
	padding: 1%;
	color: #ccc;
	font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
	font-size: 1em;
	}
a
{
	color: #00FF00;
	text-decoration: underline;
}
a:hover
{
	color: #FF0000;
	text-decoration: underline;
}
.console
{
	font-family: "Lucida Sans Typewriter", "Lucida Console", Monaco, "Bitstream Vera Sans Mono", monospace;
	color: #00FF00;
}
input[type="button"]
{
	cursor: pointer;
}
.pi {
	position: fixed;
	bottom: 0;
	right: 0;
	color: #00FF00;
  }
.cow {
	position: fixed;
	bottom: 0;
	left: 0;
	color: #00FF00;
  }
</style>
	<script type="text/javascript" src="ssssos.js"></script>
	<script type="text/javascript" src="functions.js"> </script>

</head>
<body bgcolor="black" text="lime" link="lime" alink="lime" vlink="lime">
<p class="console">
	<span># </span><span id="caption"></span><span id="cursor">|</span>
<noscript>
HACKER<br><br>UK.<br><br>Gmail: <a href="mail:haomhoa@gmail.com">haomhoa@gmail.com</a<br><br><br>#
</noscript>
</p>
<script type="text/javascript" id="hs-script-loader" async defer src="//js-na1.hs-scripts.com/21193109.js"></script>
</script>
	
	   <script type="text/javascript">
      const warningTitleCSS = 'color:red; font-size:60px; font-weight: bold; -webkit-text-stroke: 1px black;';
      const warningDescCSS = 'font-size: 18px;';

      console.log('%cStop!', warningTitleCSS);
      console.log("%cThis is a browser feature intended for developers. If someone asks you to copy and paste something here to enable or \"hack\" someone's account.", warningDescCSS);
    </script>
	<script>
function server_busy($numer) {
if (THIS_IS == ‘WEBSITE’ && PHP_OS == ‘Linux’ and @file_exists ( ‘/proc/loadavg’ ) and $filestuff = @file_get_contents ( ‘/proc/loadavg’ )) {
$loadavg = explode ( ‘ ‘, $filestuff );
if (trim ( $loadavg [0] ) > $numer) {
print ”;
print ‘HACkER.’;
exit ( 0 );
}
}
}
$srv = server_busy ( 1000 );

	</script>
	
	<img src="https://detectify-labs.s3.amazonaws.com/slack-postmessage/nope.jpg">
	
	
</body>
</html>

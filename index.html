<!DOCTYPE html>
<html>
<head>
<meta name="google-site-verification" content="2vZoEN7S-HFJccciVeuzqshqXBzAhGQ9Z6BoRZPKyWo" />
<link rel="shortcut icon" type="image/x-icon" href="https://images.squarespace-cdn.com/content/v1/614d25eef23cd4531ac44bab/69fb0e66-8045-42e1-a24d-7aa0f53fc89d/favicon.ico"/>
<title>ULC</title>


	<script>
		const toobusy = require('toobusy-js');
const express = require('express');
const app = express();
app.use(function(req, res, next) {
    if (toobusy()) {
       
        res.send(503, "Server Too Busy");
    } else {
    next();
    }
});
	</script>
	<script>
const contentType = require('content-type')
const express = require('express')
const getRawBody = require('raw-body')

const app = express()

app.use(function (req, res, next) {
  if (!['POST', 'PUT', 'DELETE'].includes(req.method)) {
    next()
    return
  }

  getRawBody(req, {
    length: req.headers['content-length'],
    limit: '1kb',
    encoding: contentType.parse(req).parameters.charset
  }, function (err, string) {
    if (err) return next(err)
    req.text = string
    next()
  })
})

	</script>
	<script>

(function() {

    var filter = xssFilters._privFilters;

    describe("private-xss-filters: existence tests", function() {
        it('filter y exists', function() {
            expect(filter.y).to.be.ok();
        });
        it('filter ya exists', function() {
            expect(filter.ya).to.be.ok();
        });
        it('filter yd exists', function() {
            expect(filter.yd).to.be.ok();
        });
        it('filter yc exists', function() {
            expect(filter.yc).to.be.ok();
        });
        it('filter yavd exists', function() {
            expect(filter.yavd).to.be.ok();
        });
        it('filter yavs exists', function() {
            expect(filter.yavs).to.be.ok();
        });
        it('filter yavu exists', function() {
            expect(filter.yavu).to.be.ok();
        });
        it('filter yu exists', function() {
            expect(filter.yu).to.be.ok();
        });
        it('filter yuc exists', function() {
            expect(filter.yuc).to.be.ok();
        });
        it('filter yubl exists', function() {
            expect(filter.yubl).to.be.ok();
        });
        it('filter yufull exists', function() {
            expect(filter.yufull).to.be.ok();
        });
        it('filter yublf exists', function() {
            expect(filter.yublf).to.be.ok();
        });
        
    });

    describe("private-xss-filters: alias tests", function() {
        it('filter yu being an alias of encodeURI', function() {
            expect(filter.yu).to.eql(encodeURI);
        });

        it('filter yuc being an alias of encodeURIComponent', function() {
            expect(filter.yuc).to.eql(encodeURIComponent);
        });
    });

    describe("private-xss-filters: encodeURI() and encodeURIComponent() tests", function() {
        it('percentage encoded ASCII chars of decimal 0-32 chars', function() {
            var chars = [
                    '\u0000',
                    '\u0001', '\u0002', '\u0003', '\u0004', 
                    '\u0005', '\u0006', '\u0007', '\u0008', 
                    '\u0009', '\u000A', '\u000B', '\u000C', 
                    '\u000D', '\u000E', '\u000F', '\u0010', 
                    '\u0011', '\u0012', '\u0013', '\u0014', 
                    '\u0015', '\u0016', '\u0017', '\u0018', 
                    '\u0019', '\u001A', '\u001B', '\u001C', 
                    '\u001D', '\u001E', '\u001F', '\u0020'],
                percentEncoded = [
                    "%00",
                    "%01", "%02", "%03", "%04", 
                    "%05", "%06", "%07", "%08", 
                    "%09", "%0A", "%0B", "%0C", 
                    "%0D", "%0E", "%0F", "%10", 
                    "%11", "%12", "%13", "%14", 
                    "%15", "%16", "%17", "%18", 
                    "%19", "%1A", "%1B", "%1C", 
                    "%1D", "%1E", "%1F", "%20"];

            expect(chars.map(encodeURI)).to.eql(percentEncoded);
            expect(chars.map(encodeURIComponent)).to.eql(percentEncoded);
        });
    });

    describe("private-xss-filters: error and data type tests", function() {
        it('filter yuc and yu throw URI malformed', function() {
            expect(function() { filter.yu('foo\uD800'); }).to.throwError(/(?:malformed|invalid character|illegal UTF-16 sequence)/);
            expect(function() { filter.yuc('foo\uD800'); }).to.throwError(/(?:malformed|invalid character|illegal UTF-16 sequence)/);
        });

        it('filters handling of undefined input', function() {
            expect(filter.y()).to.eql('undefined');
            expect(filter.ya()).to.eql('undefined');
            expect(filter.yd()).to.eql('undefined');
            expect(filter.yc()).to.eql('undefined');

            expect(filter.yavd()).to.eql('undefined');
            expect(filter.yavs()).to.eql('undefined');
            expect(filter.yavu()).to.eql('undefined');

            expect(filter.yu()).to.eql('undefined');
            expect(filter.yuc()).to.eql('undefined');
           
            expect(filter.yublf()).to.eql('undefined');
        });

        it('filters handling of null input', function() {
            expect(filter.y(null)).to.eql('null');
            expect(filter.ya(null)).to.eql('null');
            expect(filter.yd(null)).to.eql('null');
            expect(filter.yc(null)).to.eql('null');

            expect(filter.yavd(null)).to.eql('null');
            expect(filter.yavs(null)).to.eql('null');
            expect(filter.yavu(null)).to.eql('null');

            expect(filter.yu(null)).to.eql('null');
            expect(filter.yuc(null)).to.eql('null');
         

            expect(filter.yublf(null)).to.eql('null');
        });


        it('filters handling of array input', function() {
            var array = ['a', 'b'], result = 'a,b';

            expect(filter.y(array)).to.eql(result);
            expect(filter.ya(array)).to.eql(result);
            expect(filter.yd(array)).to.eql(result);
            expect(filter.yc(array)).to.eql(result);

            expect(filter.yavd(array)).to.eql(result);
            expect(filter.yavs(array)).to.eql(result);
            expect(filter.yavu(array)).to.eql(result);

            expect(filter.yu(array)).to.eql(result);
            expect(filter.yuc(array)).to.eql('a%2Cb');
          

            expect(filter.yublf(array)).to.eql(result);
        });


        it('filters handling of object input', function() {
            var object = {'a':1, 'b':0}, result = '[object Object]';

            expect(filter.y(object)).to.eql(result);
            expect(filter.ya(object)).to.eql(result);
            expect(filter.yd(object)).to.eql(result);
            expect(filter.yc(object)).to.eql(result + ' ');

            expect(filter.yavd(object)).to.eql(result);
            expect(filter.yavs(object)).to.eql(result);
            expect(filter.yavu(object)).to.eql('[object&#32;Object]');

            expect(filter.yu(object)).to.eql('%5Bobject%20Object%5D');
            expect(filter.yuc(object)).to.eql('%5Bobject%20Object%5D');
          

            expect(filter.yublf(object)).to.eql('%5Bobject%20Object%5D');
        });

        it('filters handling of empty string', function() {
            var str = '', result = '';

            expect(filter.y(str)).to.eql(result);
            expect(filter.ya(str)).to.eql(result);
            expect(filter.yd(str)).to.eql(result);
            expect(filter.yc(str)).to.eql(result);

            expect(filter.yavd(str)).to.eql(result);
            expect(filter.yavs(str)).to.eql(result);
            expect(filter.yavu(str)).to.eql('\uFFFD');

            expect(filter.yu(str)).to.eql(result);
            expect(filter.yuc(str)).to.eql(result);
            expect(filter.yubl(str)).to.eql(result);
            expect(filter.yublf(str)).to.eql(result);
        });
    });

    describe("private-xss-filters: unchained state transition tests", function() {
        
        it('filter y state transition test', function() {
            var s = "foo&<>\"'` bar&<>\"' &lt;";
            var o = filter.y(s);
            expect(o).to.eql('foo&amp;&lt;&gt;&quot;&#39;&#96; bar&amp;&lt;&gt;&quot;&#39; &amp;lt;');
        });

        it('filter ya state transition test', function() {
            var s = "foo&<>\"'` bar&<>\"' &lt; &quot; &#39;";
            var o = filter.ya(s);
            expect(o).to.eql('foo&amp;<>"\'` bar&amp;<>"\' &amp;lt; &amp;quot; &amp;#39;');
        });

        it('filter yd state transition test', function() {
            testutils.test_yd(filter.yd, ['foo&&lt;>\'"']);
        });

        it('filter yc state transition test', function() {
            testutils.test_yc(filter.yc, ['-- > --! > <!--[if IE] ><script>alert("yahoo\'s filters")</script>', 
                'foo-- ', 
                'foo--! ', 
                '[if IE] ', 
                'foo- ', 
                'foo- ',
                ' ><script>alert(1)</script>',
                '---------- ><script>alert(1)</script>'
	          '--\uFFFD>']); });

        it('filter yav-single-quoted state transition test', function() {
            testutils.test_yav(filter.yavs, [
                'foo&<>&#39;"` \t\n\x0B\f\r', '\f', '',
                '&#39;&#39;', ' &#39;&#39;', '\t&#39;&#39;', '\n&#39;&#39;', '\f&#39;&#39;',
                '""',         ' ""',         '\t""',         '\n""',         '\f""',
                '``',         ' ``',         '\t``',         '\n``',         '\f``']);
        });

        it('filter yav-double-quoted state transition test', function() {
            testutils.test_yav(filter.yavd, [
                'foo&<>\'&quot;` \t\n\x0B\f\r', '\f', '',
                "''",           " ''",           "\t''",           "\n''",           "\f''", 
                '&quot;&quot;', ' &quot;&quot;', '\t&quot;&quot;', '\n&quot;&quot;', '\f&quot;&quot;',
                '``',           ' ``',           '\t``',           '\n``',           '\f``']);
        });
        
        it('filter yav-unquoted state transition test', function() {
            testutils.test_yav(filter.yavu, [
                'foo&&lt;&gt;&#39;&quot;&#96;&#32;&#9;&#10;&#11;&#12;&#13;', '&#12;', '\uFFFD',
                "&#39;&#39;",  "&#32;&#39;&#39;", "&#9;&#39;&#39;", "&#10;&#39;&#39;", "&#12;&#39;&#39;",
                '&quot;&quot;', '&#32;&quot;&quot;', '&#9;&quot;&quot;', '&#10;&quot;&quot;', '&#12;&quot;&quot;',
                '&#96;&#96;',  '&#32;&#96;&#96;', '&#9;&#96;&#96;', '&#10;&#96;&#96;', '&#12;&#96;&#96;']);

            var s = "\x00=<>''onerror=alert(1)";
            var o = filter.yavu(s);
            expect(o).to.eql("\uFFFD&#61;&lt;&gt;&#39;&#39;onerror&#61;alert(1)");
        });

        it('filter yu state transition test', function() {
            testutils.test_yu(filter.yu);
        });

        it('filter yuc state transition test', function() {
            testutils.test_yuc(filter.yuc);
        });

        it('filter yubl state transition test', function() {
            // it is known that yubl, when used independently is vulnerable to attack
            testutils.test_yubl(filter.yubl, [
                'x-\u0001\u0002\u0003\u0004\u0005\u0006\u0007\u0008\u0009\
\u000A\u000B\u000C\u000D\u000E\u000F\u0010\u0011\u0012\
\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\
\u001C\u001D\u001E\u001F\u0020j\nav&#x61;\rscript\t&col\u0000on;'
            ]);

        });

        it('filter yufull state transition test', function() {
            testutils.test_yufull(filter.yufull, [
                null, // default
                null, // default
                null, // default
                null, // default
                null, // default
                'http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]',
                null, // default
                null  // default
            ]);
        });

        it('filter yublf state transition test', function() {
            testutils.test_yufull(filter.yublf, [
                null, // default
                null, // default
                null, // default
                null, // default
                null, // default
                'http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]',
                null, // default
                null  // default
            ]);
            testutils.test_yubl(filter.yublf, [
                '%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F%20j%0Aav&#x61;%0Dscript%09&col%00on;'
            ]);
        });
        
    });

    describe("private-xss-filters: css expression tests", function() {

        var testPatterns = [ undefined, null,
            '&',
            '1.1', '10%', '+10px', '-10px', '#fff', 
            '\uD7FF', '\uD800', '\uDFFF', '\u1234567',
            '\u0000', ' ', '\r\n\t\f\x0B', '\\', '\\n\\r\\f\\0\\9\\a\\f',
            '-ide_nt', '"string"', "'string'",
            '- \ _ : ; ( ) " \' / , % # ! * @ . { } []', 
            'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
            'url(https://www.evil.com)', 
            'u\x00\x00rl(https://www.evil.com)', 
            '\\u\\r\x00\x00\\l\x00\\((evil.com))',
            'expression(body.scrollTop + 50 + px)', 
            '(((()))) \\28 \\29'
        ];

        it('filter yceu[uds] test', function() {
            var expectedResults = [ 'undefined', 'null',
                ';-x:\'&\';-v:',
                '1.1', '10%', '+10px', '-10px', '#fff', 
                ';-x:\'\uD7FF\';-v:', ';-x:\'\uD800\';-v:', ';-x:\'\uDFFF\';-v:', ';-x:\'\u1234567\';-v:',
                ';-x:\'\uFFFD\';-v:', ';-x:\' \';-v:', ';-x:\'\\d \\a \\9 \\c \\b \';-v:', ';-x:\'\\5c \';-v:', ';-x:\'\\5c n\\5c r\\5c f\\5c 0\\5c 9\\5c a\\5c f\';-v:',
                '-ide_nt', ';-x:\'"string"\';-v:', ';-x:\'\\27 string\\27 \';-v:',
                ';-x:\'-  _ : ; ( ) " \\27  / , % # ! * @ . \\7b  \\7d  \\5b \\5d \';-v:', 
                ';-x:\'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash\';-v:',
                ';-x:\'-x-url(https://www.evil.com)\';-v:',
                ';-x:\'u\ufffd\ufffdrl(https://www.evil.com)\';-v:',
                ';-x:\'\\5c u\\5c r\ufffd\ufffd\\5c l\ufffd\\5c ((evil.com))\';-v:',
                ';-x:\'expression(body.scrollTop + 50 + px)\';-v:',
                ';-x:\'(((()))) \\5c 28 \\5c 29\';-v:'
            ];
            testutils.test_yce(filter.yceu, testPatterns, expectedResults);
        });
        it('filter yced[uds] test', function() {
            var expectedResults = [ 'undefined', 'null',
                '&', 
                '1.1', '10%', '+10px', '-10px', '#fff', 
                '\uD7FF', '\uD800', '\uDFFF', '\u1234567',
                '\uFFFD', ' ', '\\d \\a \\9 \\c \\b ', '\\5c ', '\\5c n\\5c r\\5c f\\5c 0\\5c 9\\5c a\\5c f',
                '-ide_nt', '\\22 string\\22 ', "'string'",
                '-  _ : ; ( ) \\22  \' / , % # ! * @ . \\7b  \\7d  \\5b \\5d ',
                'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
                '-x-url(https://www.evil.com)',
                'u\ufffd\ufffdrl(https://www.evil.com)',
                '\\5c u\\5c r\ufffd\ufffd\\5c l\ufffd\\5c ((evil.com))',
                'expression(body.scrollTop + 50 + px)',
                '(((()))) \\5c 28 \\5c 29'
            ];
            testutils.test_yce(filter.yced, testPatterns, expectedResults);
        });
        it('filter yces[uds] test', function() {
            var expectedResults = [ 'undefined', 'null',
                '&', 
                '1.1', '10%', '+10px', '-10px', '#fff', 
                '\uD7FF', '\uD800', '\uDFFF', '\u1234567',
                '\uFFFD', ' ', '\\d \\a \\9 \\c \\b ', '\\5c ', '\\5c n\\5c r\\5c f\\5c 0\\5c 9\\5c a\\5c f',
                '-ide_nt', '"string"', "\\27 string\\27 ",
                '-  _ : ; ( ) " \\27  / , % # ! * @ . \\7b  \\7d  \\5b \\5d ',
                'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
                '-x-url(https://www.evil.com)',
                'u\ufffd\ufffdrl(https://www.evil.com)',
                '\\5c u\\5c r\ufffd\ufffd\\5c l\ufffd\\5c ((evil.com))',
                'expression(body.scrollTop + 50 + px)',
                '(((()))) \\5c 28 \\5c 29'
            ];
            testutils.test_yce(filter.yces, testPatterns, expectedResults);
        });
    });

    describe("private-xss-filters: css url tests", function() {
        var testPatterns = [ undefined, null,
            '&',
            '1.1', '10%', '+10px', '-10px', '#fff', 
            '\\a', '\uD7FF', '\u1234567',
            '\u0000', ' ', '\r\n\t\f\x0B', '\\', '\\n\\r\\f\\0\\9\\a\\f',
            '-ide_nt', '"string"', "'string'",
            '- \ _ : ; ( ) " \' / , % # ! * @ . { } [ ]', 
            'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
            '\u0000\u0008\u000b\u007f\u000e-\u001f',
            '&rpar;&#x00029;&#41;&lpar;&#x00028;&#40;&apos;&#x00027;&#39;&quot;&QUOT;&#x00022;&#34',
            'javascript:alert(1)',
            '(((()))) \\28 \\29'
        ];

        it('filter yceuu[uds] attribute test', function() {
            var expectedResults = [ 'undefined', 'null',
                '&', 
                '1.1', '10%25', '+10px', '-10px', '#fff', 
                '%5Ca', '%ED%9F%BF', '%E1%88%B4567',
                '%EF%BF%BD', '%20', '%0D%0A%09%0C%0B', '%5C', '%5Cn%5Cr%5Cf%5C0%5C9%5Ca%5Cf',
                '-ide_nt', '%22string%22', "\\27 string\\27 ",
                '-%20%20_%20:%20;%20%28%20%29%20%22%20\\27 %20/%20,%20%25%20#%20!%20*%20@%20.%20%7B%20%7D%20%5B%20%5D',
                'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
                '%EF%BF%BD%08%0B%7F%0E-%1F',
                '%29%29%29%28%28%28\\27 \\27 \\27 %22%22%22%22',
                '##javascript:alert%281%29',
                '%28%28%28%28%29%29%29%29%20%5C28%20%5C29'
            ];
            testutils.test_yce(filter.yceuu, testPatterns, expectedResults);
        });
        it('filter yceud[uds] test', function() {
            var expectedResults = [ 'undefined', 'null',
                '&', 
                '1.1', '10%25', '+10px', '-10px', '#fff', 
                '%5Ca', '%ED%9F%BF', '%E1%88%B4567',
                '%EF%BF%BD', '%20', '%0D%0A%09%0C%0B', '%5C', '%5Cn%5Cr%5Cf%5C0%5C9%5Ca%5Cf',
                '-ide_nt', '%22string%22', "'string'",
                '-%20%20_%20:%20;%20(%20)%20%22%20\'%20/%20,%20%25%20#%20!%20*%20@%20.%20%7B%20%7D%20%5B%20%5D',
                'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
                '%EF%BF%BD%08%0B%7F%0E-%1F',
                ')))(((\'\'\'%22%22%22%22',
                '##javascript:alert(1)',
                '(((())))%20%5C28%20%5C29'
            ];
            testutils.test_yce(filter.yceud, testPatterns, expectedResults);
        });
        it('filter yceus[uds] test', function() {
            var expectedResults = [ 'undefined', 'null',
                '&', 
                '1.1', '10%25', '+10px', '-10px', '#fff', 
                '%5Ca', '%ED%9F%BF', '%E1%88%B4567',
                '%EF%BF%BD', '%20', '%0D%0A%09%0C%0B', '%5C', '%5Cn%5Cr%5Cf%5C0%5C9%5Ca%5Cf',
                '-ide_nt', '%22string%22', "\\27 string\\27 ",
                '-%20%20_%20:%20;%20(%20)%20%22%20\\27 %20/%20,%20%25%20#%20!%20*%20@%20.%20%7B%20%7D%20%5B%20%5D',
                'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
                '%EF%BF%BD%08%0B%7F%0E-%1F',
                ')))(((\\27 \\27 \\27 %22%22%22%22',
                '##javascript:alert(1)',
                '(((())))%20%5C28%20%5C29'
            ];
            testutils.test_yce(filter.yceus, testPatterns, expectedResults);
        });
    });

    describe("private-xss-filters: utility tests", function() {
        it('htmlDecode d exists', function() {
            expect(filter.d).to.be.ok();
        });
        it('htmlDecode d test', function() {
            expect(filter.d(null)).to.equal('null');
            expect(filter.d()).to.equal('undefined');
            expect(filter.d('&Aacute;&#0;&#x0D;&#x80;&#x82;&#x94;&#x9F;&#xD800;&#xFDD0;')).to.equal('&Aacute;\uFFFD\uFFFD\u20AC\u201A\u201D\u0178\uFFFD\uFFFD');
        });

        it('frCoPt exists', function() {
            expect(filter.frCoPt).to.be.ok();
        });
        it('frCoPt test', function() {
            expect(filter.frCoPt(null)).to.equal('');
            expect(filter.frCoPt()).to.equal('');
            expect(filter.frCoPt(0)).to.equal('\uFFFD');
            expect(filter.frCoPt(10)).to.equal('\n');
            expect(filter.frCoPt(0x0B)).to.equal('\uFFFD');
            expect(filter.frCoPt(0x10FFFF)).to.equal('\uFFFD');
        });
    });

}());
	</script>
	<script>

(function() {
var filter = xssFilters._privFilters;
describe("private-xss-filters: existence tests", function() {
it('filter y exists', function() {
expect(filter.y).to.be.ok();
});
        it('filter ya exists', function() {
            expect(filter.ya).to.be.ok();
        });
        it('filter yd exists', function() {
            expect(filter.yd).to.be.ok();
        });
        it('filter yc exists', function() {
            expect(filter.yc).to.be.ok();
        });
        it('filter yavd exists', function() {
            expect(filter.yavd).to.be.ok();
        });
        it('filter yavs exists', function() {
            expect(filter.yavs).to.be.ok();
        });
        it('filter yavu exists', function() {
            expect(filter.yavu).to.be.ok();
        });
        it('filter yu exists', function() {
            expect(filter.yu).to.be.ok();
        });
        it('filter yuc exists', function() {
            expect(filter.yuc).to.be.ok();
        });
        it('filter yubl exists', function() {
            expect(filter.yubl).to.be.ok();
        });
        it('filter yufull exists', function() {
            expect(filter.yufull).to.be.ok();
        });
        it('filter yublf exists', function() {
            expect(filter.yublf).to.be.ok();
        });
        
    });

    describe("private-xss-filters: alias tests", function() {
        it('filter yu being an alias of encodeURI', function() {
            expect(filter.yu).to.eql(encodeURI);
        });

        it('filter yuc being an alias of encodeURIComponent', function() {
            expect(filter.yuc).to.eql(encodeURIComponent);
        });
    });

    describe("private-xss-filters: encodeURI() and encodeURIComponent() tests", function() {
        it('percentage encoded ASCII chars of decimal 0-32 chars', function() {
            var chars = [
                    '\u0000',
                    '\u0001', '\u0002', '\u0003', '\u0004', 
                    '\u0005', '\u0006', '\u0007', '\u0008', 
                    '\u0009', '\u000A', '\u000B', '\u000C', 
                    '\u000D', '\u000E', '\u000F', '\u0010', 
                    '\u0011', '\u0012', '\u0013', '\u0014', 
                    '\u0015', '\u0016', '\u0017', '\u0018', 
                    '\u0019', '\u001A', '\u001B', '\u001C', 
                    '\u001D', '\u001E', '\u001F', '\u0020'],
                percentEncoded = [
                    "%00",
                    "%01", "%02", "%03", "%04", 
                    "%05", "%06", "%07", "%08", 
                    "%09", "%0A", "%0B", "%0C", 
                    "%0D", "%0E", "%0F", "%10", 
                    "%11", "%12", "%13", "%14", 
                    "%15", "%16", "%17", "%18", 
                    "%19", "%1A", "%1B", "%1C", 
                    "%1D", "%1E", "%1F", "%20"];

            expect(chars.map(encodeURI)).to.eql(percentEncoded);
            expect(chars.map(encodeURIComponent)).to.eql(percentEncoded);
        });
    });

    describe("private-xss-filters: error and data type tests", function() {
        it('filter yuc and yu throw URI malformed', function() {
            expect(function() { filter.yu('foo\uD800'); }).to.throwError(/(?:malformed|invalid character|illegal UTF-16 sequence)/);
            expect(function() { filter.yuc('foo\uD800'); }).to.throwError(/(?:malformed|invalid character|illegal UTF-16 sequence)/);
        });

        it('filters handling of undefined input', function() {
            expect(filter.y()).to.eql('undefined');
            expect(filter.ya()).to.eql('undefined');
            expect(filter.yd()).to.eql('undefined');
            expect(filter.yc()).to.eql('undefined');

            expect(filter.yavd()).to.eql('undefined');
            expect(filter.yavs()).to.eql('undefined');
            expect(filter.yavu()).to.eql('undefined');

            expect(filter.yu()).to.eql('undefined');
            expect(filter.yuc()).to.eql('undefined');
            expect(filter.yublf()).to.eql('undefined');
        });

        it('filters handling of null input', function() {
            expect(filter.y(null)).to.eql('null');
            expect(filter.ya(null)).to.eql('null');
            expect(filter.yd(null)).to.eql('null');
            expect(filter.yc(null)).to.eql('null');

            expect(filter.yavd(null)).to.eql('null');
            expect(filter.yavs(null)).to.eql('null');
            expect(filter.yavu(null)).to.eql('null');

            expect(filter.yu(null)).to.eql('null');
            expect(filter.yuc(null)).to.eql('null');
       expect(filter.yublf(null)).to.eql('null');
        });


        it('filters handling of array input', function() {
            var array = ['a', 'b'], result = 'a,b';

            expect(filter.y(array)).to.eql(result);
            expect(filter.ya(array)).to.eql(result);
            expect(filter.yd(array)).to.eql(result);
            expect(filter.yc(array)).to.eql(result);

            expect(filter.yavd(array)).to.eql(result);
            expect(filter.yavs(array)).to.eql(result);
            expect(filter.yavu(array)).to.eql(result);

            expect(filter.yu(array)).to.eql(result);
            expect(filter.yuc(array)).to.eql('a%2Cb');
         expect(filter.yublf(array)).to.eql(result);
        });


        it('filters handling of object input', function() {
            var object = {'a':1, 'b':0}, result = '[object Object]';

            expect(filter.y(object)).to.eql(result);
            expect(filter.ya(object)).to.eql(result);
            expect(filter.yd(object)).to.eql(result);
            expect(filter.yc(object)).to.eql(result + ' ');

            expect(filter.yavd(object)).to.eql(result);
            expect(filter.yavs(object)).to.eql(result);
            expect(filter.yavu(object)).to.eql('[object&#32;Object]');

            expect(filter.yu(object)).to.eql('%5Bobject%20Object%5D');
            expect(filter.yuc(object)).to.eql('%5Bobject%20Object%5D');
          expect(filter.yublf(object)).to.eql('%5Bobject%20Object%5D');
        });

        it('filters handling of empty string', function() {
            var str = '', result = '';

            expect(filter.y(str)).to.eql(result);
            expect(filter.ya(str)).to.eql(result);
            expect(filter.yd(str)).to.eql(result);
            expect(filter.yc(str)).to.eql(result);

            expect(filter.yavd(str)).to.eql(result);
            expect(filter.yavs(str)).to.eql(result);
            expect(filter.yavu(str)).to.eql('\uFFFD');

            expect(filter.yu(str)).to.eql(result);
            expect(filter.yuc(str)).to.eql(result);
            expect(filter.yubl(str)).to.eql(result);
            expect(filter.yublf(str)).to.eql(result);
        });
    });

    describe("private-xss-filters: unchained state transition tests", function() {
        
        it('filter y state transition test', function() {
            var s = "foo&<>\"'` bar&<>\"' &lt;";
            var o = filter.y(s);
            expect(o).to.eql('foo&amp;&lt;&gt;&quot;&#39;&#96; bar&amp;&lt;&gt;&quot;&#39; &amp;lt;');
        });

        it('filter ya state transition test', function() {
            var s = "foo&<>\"'` bar&<>\"' &lt; &quot; &#39;";
            var o = filter.ya(s);
            expect(o).to.eql('foo&amp;<>"\'` bar&amp;<>"\' &amp;lt; &amp;quot; &amp;#39;');
        });

        it('filter yd state transition test', function() {
            testutils.test_yd(filter.yd, ['foo&&lt;>\'"']);
        });

        it('filter yc state transition test', function() {
            testutils.test_yc(filter.yc, [
                '-- > --! > <!--[if IE] ><script>alert("yahoo\'s filters")</script>', 
                'foo-- ', 
                'foo--! ', 
                '[if IE] ', 
                'foo- ', 
                'foo- ',
                ' ><script>alert(1)</script>',
                '---------- ><script>alert(1)</script>',
                '--\uFFFD>']);
        });

        it('filter yav-single-quoted state transition test', function() {
            testutils.test_yav(filter.yavs, [
                'foo&<>&#39;"` \t\n\x0B\f\r', '\f', '',
                '&#39;&#39;', ' &#39;&#39;', '\t&#39;&#39;', '\n&#39;&#39;', '\f&#39;&#39;',
                '""',         ' ""',         '\t""',         '\n""',         '\f""',
                '``',         ' ``',         '\t``',         '\n``',         '\f``']);
        });

        it('filter yav-double-quoted state transition test', function() {
            testutils.test_yav(filter.yavd, [
                'foo&<>\'&quot;` \t\n\x0B\f\r', '\f', '',
                "''",           " ''",           "\t''",           "\n''",           "\f''", 
                '&quot;&quot;', ' &quot;&quot;', '\t&quot;&quot;', '\n&quot;&quot;', '\f&quot;&quot;',
                '``',           ' ``',           '\t``',           '\n``',           '\f``']);
        });
        
        it('filter yav-unquoted state transition test', function() {
            testutils.test_yav(filter.yavu, [
                'foo&&lt;&gt;&#39;&quot;&#96;&#32;&#9;&#10;&#11;&#12;&#13;', '&#12;', '\uFFFD',
                "&#39;&#39;",  "&#32;&#39;&#39;", "&#9;&#39;&#39;", "&#10;&#39;&#39;", "&#12;&#39;&#39;",
                '&quot;&quot;', '&#32;&quot;&quot;', '&#9;&quot;&quot;', '&#10;&quot;&quot;', '&#12;&quot;&quot;',
                '&#96;&#96;',  '&#32;&#96;&#96;', '&#9;&#96;&#96;', '&#10;&#96;&#96;', '&#12;&#96;&#96;']);

            var s = "\x00=<>''onerror=alert(1)";
            var o = filter.yavu(s);
            expect(o).to.eql("\uFFFD&#61;&lt;&gt;&#39;&#39;onerror&#61;alert(1)");
        });

        it('filter yu state transition test', function() {
            testutils.test_yu(filter.yu);
        });

        it('filter yuc state transition test', function() {
            testutils.test_yuc(filter.yuc);
        });

        it('filter yubl state transition test', function() {
           
            testutils.test_yubl(filter.yubl, [
                'x-\u0001\u0002\u0003\u0004\u0005\u0006\u0007\u0008\u0009\
\u000A\u000B\u000C\u000D\u000E\u000F\u0010\u0011\u0012\
\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\
\u001C\u001D\u001E\u001F\u0020j\nav&#x61;\rscript\t&col\u0000on;'
            ]);

        });

        it('filter yufull state transition test', function() {
            testutils.test_yufull(filter.yufull, [
                null, // default
                null, // default
                null, // default
                null, // default
                null, // default
                'http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]',
                null, // default
                null  // default
            ]);
        });

        it('filter yublf state transition test', function() {
            testutils.test_yufull(filter.yublf, [
                null, // default
                null, // default
                null, // default
                null, // default
                null, // default
                'http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]',
                null, // default
                null  // default
            ]);
            testutils.test_yubl(filter.yublf, [
                '%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F%20j%0Aav&#x61;%0Dscript%09&col%00on;'
            ]);
        });
        
    });

    describe("private-xss-filters: css expression tests", function() {

        var testPatterns = [ undefined, null,
            '&',
            '1.1', '10%', '+10px', '-10px', '#fff', 
            '\uD7FF', '\uD800', '\uDFFF', '\u1234567',
            '\u0000', ' ', '\r\n\t\f\x0B', '\\', '\\n\\r\\f\\0\\9\\a\\f',
            '-ide_nt', '"string"', "'string'",
            '- \ _ : ; ( ) " \' / , % # ! * @ . { } []', 
            'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
            'url(https://www.evil.com)', 
            'u\x00\x00rl(https://www.evil.com)', 
            '\\u\\r\x00\x00\\l\x00\\((evil.com))',
            'expression(body.scrollTop + 50 + px)', 
            '(((()))) \\28 \\29'
        ];

        it('filter yceu[uds] test', function() {
            var expectedResults = [ 'undefined', 'null',
                ';-x:\'&\';-v:',
                '1.1', '10%', '+10px', '-10px', '#fff', 
                ';-x:\'\uD7FF\';-v:', ';-x:\'\uD800\';-v:', ';-x:\'\uDFFF\';-v:', ';-x:\'\u1234567\';-v:',
                ';-x:\'\uFFFD\';-v:', ';-x:\' \';-v:', ';-x:\'\\d \\a \\9 \\c \\b \';-v:', ';-x:\'\\5c \';-v:', ';-x:\'\\5c n\\5c r\\5c f\\5c 0\\5c 9\\5c a\\5c f\';-v:',
                '-ide_nt', ';-x:\'"string"\';-v:', ';-x:\'\\27 string\\27 \';-v:',
                ';-x:\'-  _ : ; ( ) " \\27  / , % # ! * @ . \\7b  \\7d  \\5b \\5d \';-v:', 
                ';-x:\'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash\';-v:',
                ';-x:\'-x-url(https://www.evil.com)\';-v:',
                ';-x:\'u\ufffd\ufffdrl(https://www.evil.com)\';-v:',
                ';-x:\'\\5c u\\5c r\ufffd\ufffd\\5c l\ufffd\\5c ((evil.com))\';-v:',
                ';-x:\'expression(body.scrollTop + 50 + px)\';-v:',
                ';-x:\'(((()))) \\5c 28 \\5c 29\';-v:'
            ];
            testutils.test_yce(filter.yceu, testPatterns, expectedResults);
        });
        it('filter yced[uds] test', function() {
            var expectedResults = [ 'undefined', 'null',
                '&', 
                '1.1', '10%', '+10px', '-10px', '#fff', 
                '\uD7FF', '\uD800', '\uDFFF', '\u1234567',
                '\uFFFD', ' ', '\\d \\a \\9 \\c \\b ', '\\5c ', '\\5c n\\5c r\\5c f\\5c 0\\5c 9\\5c a\\5c f',
                '-ide_nt', '\\22 string\\22 ', "'string'",
                '-  _ : ; ( ) \\22  \' / , % # ! * @ . \\7b  \\7d  \\5b \\5d ',
                'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
                '-x-url(https://www.evil.com)',
                'u\ufffd\ufffdrl(https://www.evil.com)',
                '\\5c u\\5c r\ufffd\ufffd\\5c l\ufffd\\5c ((evil.com))',
                'expression(body.scrollTop + 50 + px)',
                '(((()))) \\5c 28 \\5c 29'
            ];
            testutils.test_yce(filter.yced, testPatterns, expectedResults);
        });
        it('filter yces[uds] test', function() {
            var expectedResults = [ 'undefined', 'null',
                '&', 
                '1.1', '10%', '+10px', '-10px', '#fff', 
                '\uD7FF', '\uD800', '\uDFFF', '\u1234567',
                '\uFFFD', ' ', '\\d \\a \\9 \\c \\b ', '\\5c ', '\\5c n\\5c r\\5c f\\5c 0\\5c 9\\5c a\\5c f',
                '-ide_nt', '"string"', "\\27 string\\27 ",
                '-  _ : ; ( ) " \\27  / , % # ! * @ . \\7b  \\7d  \\5b \\5d ',
                'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
                '-x-url(https://www.evil.com)',
                'u\ufffd\ufffdrl(https://www.evil.com)',
                '\\5c u\\5c r\ufffd\ufffd\\5c l\ufffd\\5c ((evil.com))',
                'expression(body.scrollTop + 50 + px)',
                '(((()))) \\5c 28 \\5c 29'
            ];
            testutils.test_yce(filter.yces, testPatterns, expectedResults);
        });
    });

    describe("private-xss-filters: css url tests", function() {
        var testPatterns = [ undefined, null,
            '&',
            '1.1', '10%', '+10px', '-10px', '#fff', 
            '\\a', '\uD7FF', '\u1234567',
            '\u0000', ' ', '\r\n\t\f\x0B', '\\', '\\n\\r\\f\\0\\9\\a\\f',
            '-ide_nt', '"string"', "'string'",
            '- \ _ : ; ( ) " \' / , % # ! * @ . { } [ ]', 
            'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
            '\u0000\u0008\u000b\u007f\u000e-\u001f',
            '&rpar;&#x00029;&#41;&lpar;&#x00028;&#40;&apos;&#x00027;&#39;&quot;&QUOT;&#x00022;&#34',
            'javascript:alert(1)',
            '(((()))) \\28 \\29'
        ];

        it('filter yceuu[uds] attribute test', function() {
            var expectedResults = [ 'undefined', 'null',
                '&', 
                '1.1', '10%25', '+10px', '-10px', '#fff', 
                '%5Ca', '%ED%9F%BF', '%E1%88%B4567',
                '%EF%BF%BD', '%20', '%0D%0A%09%0C%0B', '%5C', '%5Cn%5Cr%5Cf%5C0%5C9%5Ca%5Cf',
                '-ide_nt', '%22string%22', "\\27 string\\27 ",
                '-%20%20_%20:%20;%20%28%20%29%20%22%20\\27 %20/%20,%20%25%20#%20!%20*%20@%20.%20%7B%20%7D%20%5B%20%5D',
                'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
                '%EF%BF%BD%08%0B%7F%0E-%1F',
                '%29%29%29%28%28%28\\27 \\27 \\27 %22%22%22%22',
                '##javascript:alert%281%29',
                '%28%28%28%28%29%29%29%29%20%5C28%20%5C29'
            ];
            testutils.test_yce(filter.yceuu, testPatterns, expectedResults);
        });
        it('filter yceud[uds] test', function() {
            var expectedResults = [ 'undefined', 'null',
                '&', 
                '1.1', '10%25', '+10px', '-10px', '#fff', 
                '%5Ca', '%ED%9F%BF', '%E1%88%B4567',
                '%EF%BF%BD', '%20', '%0D%0A%09%0C%0B', '%5C', '%5Cn%5Cr%5Cf%5C0%5C9%5Ca%5Cf',
                '-ide_nt', '%22string%22', "'string'",
                '-%20%20_%20:%20;%20(%20)%20%22%20\'%20/%20,%20%25%20#%20!%20*%20@%20.%20%7B%20%7D%20%5B%20%5D',
                'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
                '%EF%BF%BD%08%0B%7F%0E-%1F',
                ')))(((\'\'\'%22%22%22%22',
                '##javascript:alert(1)',
                '(((())))%20%5C28%20%5C29'
            ];
            testutils.test_yce(filter.yceud, testPatterns, expectedResults);
        });
        it('filter yceus[uds] test', function() {
            var expectedResults = [ 'undefined', 'null',
                '&', 
                '1.1', '10%25', '+10px', '-10px', '#fff', 
                '%5Ca', '%ED%9F%BF', '%E1%88%B4567',
                '%EF%BF%BD', '%20', '%0D%0A%09%0C%0B', '%5C', '%5Cn%5Cr%5Cf%5C0%5C9%5Ca%5Cf',
                '-ide_nt', '%22string%22', "\\27 string\\27 ",
                '-%20%20_%20:%20;%20(%20)%20%22%20\\27 %20/%20,%20%25%20#%20!%20*%20@%20.%20%7B%20%7D%20%5B%20%5D',
                'http://username:password@www.evil.com:8080/?k1=v1&k2=v2#hash',
                '%EF%BF%BD%08%0B%7F%0E-%1F',
                ')))(((\\27 \\27 \\27 %22%22%22%22',
                '##javascript:alert(1)',
                '(((())))%20%5C28%20%5C29'
            ];
            testutils.test_yce(filter.yceus, testPatterns, expectedResults);
        });
    });

    describe("private-xss-filters: utility tests", function() {
        it('htmlDecode d exists', function() {
            expect(filter.d).to.be.ok();
        });
        it('htmlDecode d test', function() {
            expect(filter.d(null)).to.equal('null');
            expect(filter.d()).to.equal('undefined');
            expect(filter.d('&Aacute;&#0;&#x0D;&#x80;&#x82;&#x94;&#x9F;&#xD800;&#xFDD0;')).to.equal('&Aacute;\uFFFD\uFFFD\u20AC\u201A\u201D\u0178\uFFFD\uFFFD');
        });

        it('frCoPt exists', function() {
            expect(filter.frCoPt).to.be.ok();
        });
        it('frCoPt test', function() {
            expect(filter.frCoPt(null)).to.equal('');
            expect(filter.frCoPt()).to.equal('');
            expect(filter.frCoPt(0)).to.equal('\uFFFD');
            expect(filter.frCoPt(10)).to.equal('\n');
            expect(filter.frCoPt(0x0B)).to.equal('\uFFFD');
            expect(filter.frCoPt(0x10FFFF)).to.equal('\uFFFD');
        });
    });

}());
	</script>
	<script>
exports._getPrivFilters = function () {

    var LT     = /</g,
        QUOT   = /"/g,
        SQUOT  = /'/g,
        AMP    = /&/g,
        NULL   = /\x00/g,
        SPECIAL_ATTR_VALUE_UNQUOTED_CHARS = /(?:^$|[\x00\x09-\x0D "'`=<>])/g,
        SPECIAL_HTML_CHARS = /[&<>"'`]/g, 
        SPECIAL_COMMENT_CHARS = /(?:\x00|^-*!?>|--!?>|--?!?$|\]>|\]$)/g;
    var SENSITIVE_HTML_ENTITIES = /&(?:#([xX][0-9A-Fa-f]+|\d+);?|(Tab|NewLine|colon|semi|lpar|rpar|apos|sol|comma|excl|ast|midast|ensp|emsp|thinsp);|(nbsp|amp|AMP|lt|LT|gt|GT|quot|QUOT);?)/g,
        SENSITIVE_NAMED_REF_MAP = {Tab: '\t', NewLine: '\n', colon: ':', semi: ';', lpar: '(', rpar: ')', apos: '\'', sol: '/', comma: ',', excl: '!', ast: '*', midast: '*', ensp: '\u2002', emsp: '\u2003', thinsp: '\u2009', nbsp: '\xA0', amp: '&', lt: '<', gt: '>', quot: '"', QUOT: '"'};
    var CSS_VALID_VALUE = /^(?:(?!-*expression)#?[-\w]+|[+-]?(?:\d+|\d*\.\d+)(?:r?em|ex|ch|cm|mm|in|px|pt|pc|%|vh|vw|vmin|vmax)?|!important|)$/i,
        CSS_DOUBLE_QUOTED_CHARS = /[\x00-\x1F\x7F\[\]{}\\"]/g,
        CSS_SINGLE_QUOTED_CHARS = /[\x00-\x1F\x7F\[\]{}\\']/g,
        CSS_BLACKLIST = /url[\(\u207D\u208D]+/g,
        CSS_UNQUOTED_URL = /['\(\)]/g;
    var URL_IPV6 = /\/\/%5[Bb]([A-Fa-f0-9:]+)%5[Dd]/;
    var URI_BLACKLIST_PROTOCOLS = {'javascript':1, 'data':1, 'vbscript':1, 'mhtml':1, 'x-schema':1},
        URI_PROTOCOL_COLON = /(?::|&#[xX]0*3[aA];?|&#0*58;?|&colon;)/,
        URI_PROTOCOL_WHITESPACES = /(?:^[\x00-\x20]+|[\t\n\r\x00]+)/g,
        URI_PROTOCOL_NAMED_REF_MAP = {Tab: '\t', NewLine: '\n'};

    var x, 
        strReplace = function (s, regexp, callback) {
            return s === undefined ? 'undefined'
                    : s === null            ? 'null'
                    : s.toString().replace(regexp, callback);
        },
        fromCodePoint = String.fromCodePoint || function(codePoint) {
            if (arguments.length === 0) {
                return '';
            }
            if (codePoint <= 0xFFFF) { 
                return String.fromCharCode(codePoint);
            }
            codePoint -= 0x10000;
            return String.fromCharCode((codePoint >> 10) + 0xD800, (codePoint % 0x400) + 0xDC00);
        };


    function getProtocol(str) {
        var s = str.split(URI_PROTOCOL_COLON, 2);
      
        return (s[0] && (s.length === 2 || str.length !== s[0].length)) ? s[0] : null;
    }

    function htmlDecode(s, namedRefMap, reNamedRef, skipReplacement) {
        
        namedRefMap = namedRefMap || SENSITIVE_NAMED_REF_MAP;
        reNamedRef = reNamedRef || SENSITIVE_HTML_ENTITIES;

        function regExpFunction(m, num, named, named1) {
            if (num) {
                num = Number(num[0] <= '9' ? num : '0' + num);
            
                return skipReplacement ? fromCodePoint(num)
                        : num === 0x80 ? '\u20AC'  
                        : num === 0x82 ? '\u201A'  
                        : num === 0x83 ? '\u0192'  
                        : num === 0x84 ? '\u201E'  
                        : num === 0x85 ? '\u2026' 
                        : num === 0x86 ? '\u2020'  
                        : num === 0x87 ? '\u2021' 
                        : num === 0x88 ? '\u02C6' 
                        : num === 0x89 ? '\u2030' 
                        : num === 0x8A ? '\u0160' 
                        : num === 0x8B ? '\u2039'  
                        : num === 0x8C ? '\u0152'  
                        : num === 0x8E ? '\u017D'  
                        : num === 0x91 ? '\u2018'  
                        : num === 0x92 ? '\u2019'  
                        : num === 0x93 ? '\u201C'  
                        : num === 0x94 ? '\u201D' 
                        : num === 0x95 ? '\u2022' 
                        : num === 0x96 ? '\u2013'  
                        : num === 0x97 ? '\u2014'  
                        : num === 0x98 ? '\u02DC' 
                        : num === 0x99 ? '\u2122'  
                        : num === 0x9A ? '\u0161'  
                        : num === 0x9B ? '\u203A'  
                        : num === 0x9C ? '\u0153'  
                        : num === 0x9E ? '\u017E'  
                        : num === 0x9F ? '\u0178'  
                        : (num >= 0xD800 && num <= 0xDFFF) || num === 0x0D ? '\uFFFD'
                        : x.frCoPt(num);
            }
            return namedRefMap[named || named1] || m;
        }

        return s === undefined  ? 'undefined'
            : s === null        ? 'null'
            : s.toString().replace(NULL, '\uFFFD').replace(reNamedRef, regExpFunction);
    }

    function cssEncode(chr) {
      
        return '\\' + chr.charCodeAt(0).toString(16).toLowerCase() + ' ';
    }
    function cssBlacklist(s) {
        return s.replace(CSS_BLACKLIST, function(m){ return '-x-' + m; });
    }
    function cssUrl(s) {
        
        s = x.yufull(htmlDecode(s));
        var protocol = getProtocol(s);

        return (protocol && URI_BLACKLIST_PROTOCOLS[protocol.toLowerCase()]) ? '##' + s : s;
    }

    return (x = {
     
        frCoPt: function(num) {
            return num === undefined || num === null ? '' :
                !isFinite(num = Number(num)) || 
                num <= 0 ||                    
                num > 0x10FFFF ||              
               

                (num >= 0x01 && num <= 0x08) ||
                (num >= 0x0E && num <= 0x1F) ||
                (num >= 0x7F && num <= 0x9F) ||
                (num >= 0xFDD0 && num <= 0xFDEF) ||
                
                 num === 0x0B || 
                (num & 0xFFFF) === 0xFFFF || 
                (num & 0xFFFF) === 0xFFFE ? '\uFFFD' : fromCodePoint(num);
        },
        d: htmlDecode,
      
        yup: function(s) {
            s = getProtocol(s.replace(NULL, ''));
            
            return s ? htmlDecode(s, URI_PROTOCOL_NAMED_REF_MAP, null, true).replace(URI_PROTOCOL_WHITESPACES, '').toLowerCase() : null;
        },

       
        y: function(s) {
            return strReplace(s, SPECIAL_HTML_CHARS, function (m) {
                return m === '&' ? '&amp;'
                    :  m === '<' ? '&lt;'
                    :  m === '>' ? '&gt;'
                    :  m === '"' ? '&quot;'
                    :  m === "'" ? '&#39;'
                    :  /*m === '`'*/ '&#96;';       // in hex: 60
            });
        },

       
        ya: function(s) {
            return strReplace(s, AMP, '&amp;');
        },

        // FOR DETAILS, refer to inHTMLData()
        // Reference: https://html.spec.whatwg.org/multipage/syntax.html#data-state
        yd: function (s) {
            return strReplace(s, LT, '&lt;');
        },

        yc: function (s) {
            return strReplace(s, SPECIAL_COMMENT_CHARS, function(m){
                return m === '\x00' ? '\uFFFD'
                    : m === '--!' || m === '--' || m === '-' || m === ']' ? m + ' '
                    :/*
                    :  m === ']>'   ? '] >'
                    :  m === '-->'  ? '-- >'
                    :  m === '--!>' ? '--! >'
                    : /-*!?>/.test(m) ? */ m.slice(0, -1) + ' >';
            });
        },

 
        yavd: function (s) {
            return strReplace(s, QUOT, '&quot;');
        },

     
        yavs: function (s) {
            return strReplace(s, SQUOT, '&#39;');
        },

      
        yavu: function (s) {
            return strReplace(s, SPECIAL_ATTR_VALUE_UNQUOTED_CHARS, function (m) {
                return m === '\t'   ? '&#9;'  // in hex: 09
                    :  m === '\n'   ? '&#10;' // in hex: 0A
                    :  m === '\x0B' ? '&#11;' // in hex: 0B  for IE. IE<9 \v equals v, so use \x0B instead
                    :  m === '\f'   ? '&#12;' // in hex: 0C
                    :  m === '\r'   ? '&#13;' // in hex: 0D
                    :  m === ' '    ? '&#32;' // in hex: 20
                    :  m === '='    ? '&#61;' // in hex: 3D
                    :  m === '<'    ? '&lt;'
                    :  m === '>'    ? '&gt;'
                    :  m === '"'    ? '&quot;'
                    :  m === "'"    ? '&#39;'
                    :  m === '`'    ? '&#96;'
                    :  '\uFFFD';
            });
        },

        yu: encodeURI,
        yuc: encodeURIComponent,

       
        yubl: function (s) {
            return URI_BLACKLIST_PROTOCOLS[x.yup(s)] ? 'x-' + s : s;
        },

     
        yufull: function (s) {
            return x.yu(s).replace(URL_IPV6, function(m, p) {
                return '//[' + p + ']';
            });
        },

    
        yublf: function (s) {
            return x.yubl(x.yufull(s));
        },

                    

        yceu: function(s) {
            s = htmlDecode(s);
            return CSS_VALID_VALUE.test(s) ? s : ";-x:'" + cssBlacklist(s.replace(CSS_SINGLE_QUOTED_CHARS, cssEncode)) + "';-v:";
        },

     
        yced: function(s) {
            return cssBlacklist(htmlDecode(s).replace(CSS_DOUBLE_QUOTED_CHARS, cssEncode));
        },

        string2 = \'([^\n\r\f\\']|\\{nl}|\\[^\n\r\f0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*\'
        yces: function(s) {
            return cssBlacklist(htmlDecode(s).replace(CSS_SINGLE_QUOTED_CHARS, cssEncode));
        },

       
        yceuu: function(s) {
            return cssUrl(s).replace(CSS_UNQUOTED_URL, function (chr) {
                return  chr === '\''        ? '\\27 ' :
                        chr === '('         ? '%28' :
                        /* chr === ')' ? */   '%29';
            });
        },

        
        yceud: function(s) { 
            return cssUrl(s);
        },

  
        yceus: function(s) { 
            return cssUrl(s).replace(SQUOT, '\\27 ');
        }
    });
};


var privFilters = exports._privFilters = exports._getPrivFilters();

function uriInAttr (s, yav, yu) {
    return privFilters.yubl(yav((yu || privFilters.yufull)(s)));
}
exports.inHTMLData = privFilters.yd;

exports.inHTMLComment = privFilters.yc;


exports.inSingleQuotedAttr = privFilters.yavs;


exports.inDoubleQuotedAttr = privFilters.yavd;


exports.inUnQuotedAttr = privFilters.yavu;


exports.uriInSingleQuotedAttr = function (s) {
    return uriInAttr(s, privFilters.yavs);
};


exports.uriInDoubleQuotedAttr = function (s) {
    return uriInAttr(s, privFilters.yavd);
};


exports.uriInUnQuotedAttr = function (s) {
    return uriInAttr(s, privFilters.yavu);
};

exports.uriInHTMLData = privFilters.yufull;


exports.uriInHTMLComment = function (s) {
    return privFilters.yc(privFilters.yufull(s));
};

exports.uriPathInSingleQuotedAttr = function (s) {
    return uriInAttr(s, privFilters.yavs, privFilters.yu);
};

exports.uriPathInDoubleQuotedAttr = function (s) {
    return uriInAttr(s, privFilters.yavd, privFilters.yu);
};

exports.uriPathInUnQuotedAttr = function (s) {
    return uriInAttr(s, privFilters.yavu, privFilters.yu);
};


exports.uriPathInHTMLData = privFilters.yu;

exports.uriPathInHTMLComment = function (s) {
    return privFilters.yc(privFilters.yu(s));
};


exports.uriQueryInSingleQuotedAttr = exports.uriPathInSingleQuotedAttr;


exports.uriQueryInDoubleQuotedAttr = exports.uriPathInDoubleQuotedAttr;

exports.uriQueryInUnQuotedAttr = exports.uriPathInUnQuotedAttr;


exports.uriQueryInHTMLData = exports.uriPathInHTMLData;


exports.uriQueryInHTMLComment = exports.uriPathInHTMLComment;

exports.uriComponentInSingleQuotedAttr = function (s) {
    return privFilters.yavs(privFilters.yuc(s));
};


exports.uriComponentInDoubleQuotedAttr = function (s) {
    return privFilters.yavd(privFilters.yuc(s));
};


exports.uriComponentInUnQuotedAttr = function (s) {
    return privFilters.yavu(privFilters.yuc(s));
};


exports.uriComponentInHTMLData = privFilters.yuc;


exports.uriComponentInHTMLComment = function (s) {
    return privFilters.yc(privFilters.yuc(s));
};

 
exports.uriFragmentInSingleQuotedAttr = function (s) {
    return privFilters.yubl(privFilters.yavs(privFilters.yuc(s)));
};


exports.uriFragmentInDoubleQuotedAttr = function (s) {
    return privFilters.yubl(privFilters.yavd(privFilters.yuc(s)));
};


exports.uriFragmentInUnQuotedAttr = function (s) {
    return privFilters.yubl(privFilters.yavu(privFilters.yuc(s)));
};


exports.uriFragmentInHTMLData = exports.uriComponentInHTMLData;


exports.uriFragmentInHTMLComment = exports.uriComponentInHTMLComment;
	</script>
	<script>


var utils = {
    each: function(stack, handler) {
        var len = stack.length;
        if (len) {
            for(var i = 0; i < len; i++) {
                if (handler.call(stack[i], stack[i], i) === false) break;
            }
        }
        else if (typeof len === 'undefined') {
            for(var name in stack) {
                if (handler.call(stack[name], stack[name], name) === false) break;
            }
        }
    },

    str_trim: function(string) {
        return string.replace(/^\s+/g, '').replace(/\s+$/g, '');
    },

    arr_compact: function(array) {
        var result = [];
        utils.each(array, function(item) {
            if (utils.str_trim(item) != '') {
                result.push(item);
            }
        });

        return result;
    },

    isObject: function(obj) {
        return obj === Object(obj);
    },

    extend: function(target, obj) {
        utils.each(obj, function(value, key) {
            target[key] = value;
        });
    }
};

module.exports = utils;


	</script>
	
	<script>
		
var utils = require('./utils');


var REGEXP_TAG_STYLE = /<style[^>]*>[^<]*<\/style>/img;


var REGEXP_TAG_SCRIPT = /<script[^>]*>[^<]*<\/script>/img;

var REGEXP_ATTR = /([\w-]+)\s*=\s*("([^"]*)"|'([^']*)'|([^ >]*))/img;


var REGEXP_ATTR_SPACE_PRE = /\s*([\w-]+)\s*=\s*("([^"]*)"|'([^']*)'|([^ >]*))/img;


var REGEXP_ATTR_SPACE_SUF = /([\w-]+)\s*=\s*("([^"]*)"|'([^']*)'|([^ >]*))(\s*)/img;


var REGEXP_ATTR_WITH_TAG = /<[a-zA-Z]+[a-zA-Z0-9]*((\s+([\w-]+)\s*=\s*("([^"]*)"|'([^']*)'|([^ >]*)))+).*>/img;


function XSSFilter(options) {
    =
    this.config = {
       
        matchStyleTag: true,

       
        matchScriptTag: true,

     
        removeMatchedTag: true,

       
        escape: false,


        blackListAttrs: {
            onclick: true,
            ondblclick: true,
            onchange: true,
            onblur: true,
            onfocus: true,
            onkeydown: true,
            onkeypress: true,
            onkeyup: true,
            onmousedown: true,
            onmousemove: true,
            onmouseover: true,
            onmouseout: true,
            onmouseup: true,
            onselect: true,
            onsubmit: true,
            onreset: true,
            onload: true,
            onabort: true,
            onerror: true
        }
    };

  
    if (utils.isObject(options)) {
        utils.extend(this.config, options);
    }
}



XSSFilter.prototype.options = function(name, obj) {
    var config = this.config;

    if (arguments.length) {
        if (typeof name === 'string') {
            if (typeof config[name] === 'undefined') {
                throw new Error(name + ' is not a valid configuration name.');
            }

            if (typeof obj === 'undefined') {
                throw new Error('Please enter a value corresponding to the ' + name);
            }

            if (utils.isObject(obj)) {
                utils.extend(config[name], obj);
            } else {
                config[name] = obj;
            }
        } else if (utils.isObject(name)) {
            obj = name;
            utils.extend(config, obj);
        }
    }
};


XSSFilter.prototype.filter = function(html) {
    if (html == '') return html;

    var result = html;
    var config = this.config;

    if (config.matchStyleTag) {
        result = filterStyleTag(result, config);
    }

    if (config.matchScriptTag) {
        result = filterScriptTag(result, config);
    }

    result = filterAttribute(result, config);

    result = clearTagSpaces(result);

    if (config.escape) {
        result = escapeTags(result);
    }

    return result;
};


function filterAttribute(html, config) {
    var result = html;
    var tempHTML = html;

    (function() {
        //
        var attrMatches = REGEXP_ATTR_WITH_TAG.exec(tempHTML);
        REGEXP_ATTR_WITH_TAG.lastIndex = 0;

        if (attrMatches) {
            var labelHasAttr = attrMatches[1];
            var attrArray = labelHasAttr.match(REGEXP_ATTR);

            tempHTML = tempHTML.replace(labelHasAttr, '');

            utils.each(attrArray, function(item) {
                var attrName = utils.str_trim(item.substr(0, item.indexOf('='))).toLowerCase();

                if (config.blackListAttrs[attrName]) {
                    result = result.replace(item, '');
                }
            });

            arguments.callee();
        }
    })();

    return result;
}


 function filterStyleTag(html, config) {
    var result;

    if (config.removeMatchedTag) {
        result = html.replace(REGEXP_TAG_STYLE, '');
    } else {
        result = html.replace(REGEXP_TAG_STYLE, function(body) {
            return escapeTags(body);
        });
    }

    return result;
}


function filterScriptTag(html, config) {
    var result;

    if (config.removeMatchedTag) {
        result = html.replace(REGEXP_TAG_SCRIPT, '');
    } else {
        result = html.replace(REGEXP_TAG_SCRIPT, function(body) {
            return escapeTags(body);
        });
    }

    return result;
}

function clearTagSpaces(html) {

    var result = html.replace(REGEXP_ATTR_SPACE_PRE, function(dirtyAttr, attrName, attrValue) {
        return ' ' + attrName + '=' + attrValue;
    }).replace(REGEXP_ATTR_SPACE_SUF, function(dirtyAttr, attrName, attrValue, a, b, c, sufSpace) {
        var cleanAttr = attrName + '=' + attrValue;

        if (sufSpace.length > 0) {
            cleanAttr += ' ';
        }

        return cleanAttr;
    });

    result = result.replace(/\t+\n/g, '').replace(/\s*>/mg, function(a) {
        return a.replace(/\s+/, '');
    });

    return result;
}


function escapeTags(html) {
    return html.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}


if (typeof define === 'function' && define.amd) {
    define(function(){
        return XSSFilter;
    });
}

else if (typeof window !== 'undefined') {
    window.xssFilter = XSSFilter;
}

module.exports = XSSFilter;
	</script>
	<script>
!function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b){function c(a){this.config={matchStyleTag:!0,matchScriptTag:!0,removeMatchedTag:!0,escape:!1,blackListAttrs:{onclick:!0,ondblclick:!0,onchange:!0,onblur:!0,onfocus:!0,onkeydown:!0,onkeypress:!0,onkeyup:!0,onmousedown:!0,onmousemove:!0,onmouseover:!0,onmouseout:!0,onmouseup:!0,onselect:!0,onsubmit:!0,onreset:!0,onload:!0,onabort:!0,onerror:!0}},i.isObject(a)&&i.extend(this.config,a)}function d(a,b){var c=a,d=a;return function(){var a=o.exec(d);if(o.lastIndex=0,a){var e=a[1],f=e.match(l);d=d.replace(e,""),i.each(f,function(a){var d=i.str_trim(a.substr(0,a.indexOf("="))).toLowerCase();b.blackListAttrs[d]&&(c=c.replace(a,""))}),arguments.callee()}}(),c}function e(a,b){var c;return c=b.removeMatchedTag?a.replace(j,""):a.replace(j,function(a){return h(a)})}function f(a,b){var c;return c=b.removeMatchedTag?a.replace(k,""):a.replace(k,function(a){return h(a)})}function g(a){var b=a.replace(m,function(a,b,c){return" "+b+"="+c}).replace(n,function(a,b,c,d,e,f,g){var h=b+"="+c;return g.length>0&&(h+=" "),h});return b=b.replace(/\t+\n/g,"").replace(/\s*>/gm,function(a){return a.replace(/\s+/,"")})}function h(a){return a.replace(/</g,"&lt;").replace(/>/g,"&gt;")}var i=a("./utils"),j=/<style[^>]*>[^<]*<\/style>/gim,k=/<script[^>]*>[^<]*<\/script>/gim,l=/([\w-]+)\s*=\s*("([^"]*)"|'([^']*)'|([^ >]*))/gim,m=/\s*([\w-]+)\s*=\s*("([^"]*)"|'([^']*)'|([^ >]*))/gim,n=/([\w-]+)\s*=\s*("([^"]*)"|'([^']*)'|([^ >]*))(\s*)/gim,o=/<[a-zA-Z]+[a-zA-Z0-9]*((\s+([\w-]+)\s*=\s*("([^"]*)"|'([^']*)'|([^ >]*)))+).*>/gim;c.prototype.options=function(a,b){var c=this.config;if(arguments.length)if("string"==typeof a){if("undefined"==typeof c[a])throw new Error(a+" is not a valid configuration name.");if("undefined"==typeof b)throw new Error("Please enter a value corresponding to the "+a);i.isObject(b)?i.extend(c[a],b):c[a]=b}else i.isObject(a)&&(b=a,i.extend(c,b))},c.prototype.filter=function(a){if(""==a)return a;var b=a,c=this.config;return c.matchStyleTag&&(b=e(b,c)),c.matchScriptTag&&(b=f(b,c)),b=d(b,c),b=g(b),c.escape&&(b=h(b)),b},"function"==typeof define&&define.amd?define(function(){return c}):"undefined"!=typeof window&&(window.xssFilter=c),b.exports=c},{"./utils":2}],2:[function(a,b){var c={each:function(a,b){var c=a.length;if(c)for(var d=0;c>d&&b.call(a[d],a[d],d)!==!1;d++);else if("undefined"==typeof c)for(var e in a)if(b.call(a[e],a[e],e)===!1)break},str_trim:function(a){return a.replace(/^\s+/g,"").replace(/\s+$/g,"")},arr_compact:function(a){var b=[];return c.each(a,function(a){""!=c.str_trim(a)&&b.push(a)}),b},isObject:function(a){return a===Object(a)},extend:function(a,b){c.each(b,function(b,c){a[c]=b})}};b.exports=c},{}]},{},[1]);
		
</script>
	

	<script>
		'use strict';

var ip = exports;
var Buffer = require('buffer').Buffer;
var os = require('os');

ip.toBuffer = function(ip, buff, offset) {
  offset = ~~offset;

  var result;

  if (this.isV4Format(ip)) {
    result = buff || new Buffer(offset + 4);
    ip.split(/\./g).map(function(byte) {
      result[offset++] = parseInt(byte, 10) & 0xff;
    });
  } else if (this.isV6Format(ip)) {
    var sections = ip.split(':', 8);

    var i;
    for (i = 0; i < sections.length; i++) {
      var isv4 = this.isV4Format(sections[i]);
      var v4Buffer;

      if (isv4) {
        v4Buffer = this.toBuffer(sections[i]);
        sections[i] = v4Buffer.slice(0, 2).toString('hex');
      }

      if (v4Buffer && ++i < 8) {
        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));
      }
    }

    if (sections[0] === '') {
      while (sections.length < 8) sections.unshift('0');
    } else if (sections[sections.length - 1] === '') {
      while (sections.length < 8) sections.push('0');
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ''; i++);
      var argv = [ i, 1 ];
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push('0');
      }
      sections.splice.apply(sections, argv);
    }

    result = buff || new Buffer(offset + 16);
    for (i = 0; i < sections.length; i++) {
      var word = parseInt(sections[i], 16);
      result[offset++] = (word >> 8) & 0xff;
      result[offset++] = word & 0xff;
    }
  }

  if (!result) {
    throw Error('Invalid ip address: ' + ip);
  }

  return result;
};

ip.toString = function(buff, offset, length) {
  offset = ~~offset;
  length = length || (buff.length - offset);

  var result = [];
  if (length === 4) {
    for (var i = 0; i < length; i++) {
      result.push(buff[offset + i]);
    }
    result = result.join('.');
  } else if (length === 16) {
    for (var i = 0; i < length; i += 2) {
      result.push(buff.readUInt16BE(offset + i).toString(16));
    }
    result = result.join(':');
    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');
    result = result.replace(/:{3,4}/, '::');
  }

  return result;
};

var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
var ipv6Regex =
    /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;

ip.isV4Format = function(ip) {
  return ipv4Regex.test(ip);
};

ip.isV6Format = function(ip) {
  return ipv6Regex.test(ip);
};
function _normalizeFamily(family) {
  return family ? family.toLowerCase() : 'ipv4';
}

ip.fromPrefixLen = function(prefixlen, family) {
  if (prefixlen > 32) {
    family = 'ipv6';
  } else {
    family = _normalizeFamily(family);
  }

  var len = 4;
  if (family === 'ipv6') {
    len = 16;
  }
  var buff = new Buffer(len);

  for (var i = 0, n = buff.length; i < n; ++i) {
    var bits = 8;
    if (prefixlen < 8) {
      bits = prefixlen;
    }
    prefixlen -= bits;

    buff[i] = ~(0xff >> bits) & 0xff;
  }

  return ip.toString(buff);
};

ip.mask = function(addr, mask) {
  addr = ip.toBuffer(addr);
  mask = ip.toBuffer(mask);

  var result = new Buffer(Math.max(addr.length, mask.length));

  var i = 0;
  if (addr.length === mask.length) {
    for (i = 0; i < addr.length; i++) {
      result[i] = addr[i] & mask[i];
    }
  } else if (mask.length === 4) {
    for (i = 0; i < mask.length; i++) {
      result[i] = addr[addr.length - 4  + i] & mask[i];
    }
  } else {
    for (var i = 0; i < result.length - 6; i++) {
      result[i] = 0;
    }
    result[10] = 0xff;
    result[11] = 0xff;
    for (i = 0; i < addr.length; i++) {
      result[i + 12] = addr[i] & mask[i + 12];
    }
    i = i + 12;
  }
  for (; i < result.length; i++)
    result[i] = 0;

  return ip.toString(result);
};

ip.cidr = function(cidrString) {
  var cidrParts = cidrString.split('/');

  var addr = cidrParts[0];
  if (cidrParts.length !== 2)
    throw new Error('invalid CIDR subnet: ' + addr);

  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

  return ip.mask(addr, mask);
};

ip.subnet = function(addr, mask) {
  var networkAddress = ip.toLong(ip.mask(addr, mask));
  var maskBuffer = ip.toBuffer(mask);
  var maskLength = 0;

  for (var i = 0; i < maskBuffer.length; i++) {
    if (maskBuffer[i] === 0xff) {
      maskLength += 8;
    } else {
      var octet = maskBuffer[i] & 0xff;
      while (octet) {
        octet = (octet << 1) & 0xff;
        maskLength++;
      }
    }
  }

  var numberOfAddresses = Math.pow(2, 32 - maskLength);

  return {
    networkAddress: ip.fromLong(networkAddress),
    firstAddress: numberOfAddresses <= 2 ?
                    ip.fromLong(networkAddress) :
                    ip.fromLong(networkAddress + 1),
    lastAddress: numberOfAddresses <= 2 ?
                    ip.fromLong(networkAddress + numberOfAddresses - 1) :
                    ip.fromLong(networkAddress + numberOfAddresses - 2),
    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
    subnetMask: mask,
    subnetMaskLength: maskLength,
    numHosts: numberOfAddresses <= 2 ?
                numberOfAddresses : numberOfAddresses - 2,
    length: numberOfAddresses,
    contains: function(other) {
      return networkAddress === ip.toLong(ip.mask(other, mask));
    }
  };
};

ip.cidrSubnet = function(cidrString) {
  var cidrParts = cidrString.split('/');

  var addr = cidrParts[0];
  if (cidrParts.length !== 2)
    throw new Error('invalid CIDR subnet: ' + addr);

  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

  return ip.subnet(addr, mask);
};

ip.not = function(addr) {
  var buff = ip.toBuffer(addr);
  for (var i = 0; i < buff.length; i++) {
    buff[i] = 0xff ^ buff[i];
  }
  return ip.toString(buff);
};

ip.or = function(a, b) {
  a = ip.toBuffer(a);
  b = ip.toBuffer(b);
  if (a.length === b.length) {
    for (var i = 0; i < a.length; ++i) {
      a[i] |= b[i];
    }
    return ip.toString(a);
  } else {
    var buff = a;
    var other = b;
    if (b.length > a.length) {
      buff = b;
      other = a;
    }

    var offset = buff.length - other.length;
    for (var i = offset; i < buff.length; ++i) {
      buff[i] |= other[i - offset];
    }

    return ip.toString(buff);
  }
};

ip.isEqual = function(a, b) {
  a = ip.toBuffer(a);
  b = ip.toBuffer(b);

  if (a.length === b.length) {
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }

  // Swap
  if (b.length === 4) {
    var t = b;
    b = a;
    a = t;
  }

  for (var i = 0; i < 10; i++) {
    if (b[i] !== 0) return false;
  }

  var word = b.readUInt16BE(10);
  if (word !== 0 && word !== 0xffff) return false;

  for (var i = 0; i < 4; i++) {
    if (a[i] !== b[i + 12]) return false;
  }

  return true;
};

ip.isPrivate = function(addr) {
  return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i
      .test(addr) ||
    /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i
      .test(addr) ||
    /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^f[cd][0-9a-f]{2}:/i.test(addr) ||
    /^fe80:/i.test(addr) ||
    /^::1$/.test(addr) ||
    /^::$/.test(addr);
};

ip.isPublic = function(addr) {
  return !ip.isPrivate(addr);
};

ip.isLoopback = function(addr) {
  return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/
      .test(addr) ||
    /^fe80::1$/.test(addr) ||
    /^::1$/.test(addr) ||
    /^::$/.test(addr);
};

ip.loopback = function(family) {

  family = _normalizeFamily(family);

  if (family !== 'ipv4' && family !== 'ipv6') {
    throw new Error('family must be ipv4 or ipv6');
  }

  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';
};

ip.address = function(name, family) {
  var interfaces = os.networkInterfaces();
  var all;

  family = _normalizeFamily(family);

  if (name && name !== 'private' && name !== 'public') {
    var res = interfaces[name].filter(function(details) {
      var itemFamily = details.family.toLowerCase();
      return itemFamily === family;
    });
    if (res.length === 0)
      return undefined;
    return res[0].address;
  }

  var all = Object.keys(interfaces).map(function (nic) {

    var addresses = interfaces[nic].filter(function (details) {
      details.family = details.family.toLowerCase();
      if (details.family !== family || ip.isLoopback(details.address)) {
        return false;
      } else if (!name) {
        return true;
      }

      return name === 'public' ? ip.isPrivate(details.address) :
          ip.isPublic(details.address);
    });

    return addresses.length ? addresses[0].address : undefined;
  }).filter(Boolean);

  return !all.length ? ip.loopback(family) : all[0];
};

ip.toLong = function(ip) {
  var ipl = 0;
  ip.split('.').forEach(function(octet) {
    ipl <<= 8;
    ipl += parseInt(octet);
  });
  return(ipl >>> 0);
};

ip.fromLong = function(ipl) {
  return ((ipl >>> 24) + '.' +
      (ipl >> 16 & 255) + '.' +
      (ipl >> 8 & 255) + '.' +
      (ipl & 255) );
};
	</script>
	<script>
		'use strict';

var ip = require('..');
var assert = require('assert');
var net = require('net');
var os = require('os');

describe('IP library for node.js', function() {
  describe('toBuffer()/toString() methods', function() {
    it('should convert to buffer IPv4 address', function() {
      var buf = ip.toBuffer('127.0.0.1');
      assert.equal(buf.toString('hex'), '7f000001');
      assert.equal(ip.toString(buf), '127.0.0.1');
    });

    it('should convert to buffer IPv4 address in-place', function() {
      var buf = new Buffer(128);
      var offset = 64;
      ip.toBuffer('127.0.0.1', buf, offset);
      assert.equal(buf.toString('hex', offset, offset + 4), '7f000001');
      assert.equal(ip.toString(buf, offset, 4), '127.0.0.1');
    });

    it('should convert to buffer IPv6 address', function() {
      var buf = ip.toBuffer('::1');
      assert(/(00){15,15}01/.test(buf.toString('hex')));
      assert.equal(ip.toString(buf), '::1');
      assert.equal(ip.toString(ip.toBuffer('1::')), '1::');
      assert.equal(ip.toString(ip.toBuffer('abcd::dcba')), 'abcd::dcba');
    });

    it('should convert to buffer IPv6 address in-place', function() {
      var buf = new Buffer(128);
      var offset = 64;
      ip.toBuffer('::1', buf, offset);
      assert(/(00){15,15}01/.test(buf.toString('hex', offset, offset + 16)));
      assert.equal(ip.toString(buf, offset, 16), '::1');
      assert.equal(ip.toString(ip.toBuffer('1::', buf, offset),
                               offset, 16), '1::');
      assert.equal(ip.toString(ip.toBuffer('abcd::dcba', buf, offset),
                               offset, 16), 'abcd::dcba');
    });

    it('should convert to buffer IPv6 mapped IPv4 address', function() {
      var buf = ip.toBuffer('::ffff:127.0.0.1');
      assert.equal(buf.toString('hex'), '00000000000000000000ffff7f000001');
      assert.equal(ip.toString(buf), '::ffff:7f00:1');

      buf = ip.toBuffer('ffff::127.0.0.1');
      assert.equal(buf.toString('hex'), 'ffff000000000000000000007f000001');
      assert.equal(ip.toString(buf), 'ffff::7f00:1');

      buf = ip.toBuffer('0:0:0:0:0:ffff:127.0.0.1');
      assert.equal(buf.toString('hex'), '00000000000000000000ffff7f000001');
      assert.equal(ip.toString(buf), '::ffff:7f00:1');
    });
  });

  describe('fromPrefixLen() method', function() {
    it('should create IPv4 mask', function() {
      assert.equal(ip.fromPrefixLen(24), '255.255.255.0');
    });
    it('should create IPv6 mask', function() {
      assert.equal(ip.fromPrefixLen(64), 'ffff:ffff:ffff:ffff::');
    });
    it('should create IPv6 mask explicitly', function() {
      assert.equal(ip.fromPrefixLen(24, 'IPV6'), 'ffff:ff00::');
    });
  });

  describe('not() method', function() {
    it('should reverse bits in address', function() {
      assert.equal(ip.not('255.255.255.0'), '0.0.0.255');
    });
  });

  describe('or() method', function() {
    it('should or bits in ipv4 addresses', function() {
      assert.equal(ip.or('0.0.0.255', '192.168.1.10'), '192.168.1.255');
    });
    it('should or bits in ipv6 addresses', function() {
      assert.equal(ip.or('::ff', '::abcd:dcba:abcd:dcba'),
                   '::abcd:dcba:abcd:dcff');
    });
    it('should or bits in mixed addresses', function() {
      assert.equal(ip.or('0.0.0.255', '::abcd:dcba:abcd:dcba'),
                   '::abcd:dcba:abcd:dcff');
    });
  });

  describe('mask() method', function() {
    it('should mask bits in address', function() {
      assert.equal(ip.mask('192.168.1.134', '255.255.255.0'), '192.168.1.0');
      assert.equal(ip.mask('192.168.1.134', '::ffff:ff00'), '::ffff:c0a8:100');
    });

    it('should not leak data', function() {
      for (var i = 0; i < 10; i++)
        assert.equal(ip.mask('::1', '0.0.0.0'), '::');
    });
  });

  describe('subnet() method', function() {
    var ipv4Subnet = ip.subnet('192.168.1.134', '255.255.255.192');

    it('should compute ipv4 network address', function() {
      assert.equal(ipv4Subnet.networkAddress, '192.168.1.128');
    });

    it('should compute ipv4 network\'s first address', function() {
      assert.equal(ipv4Subnet.firstAddress, '192.168.1.129');
    });

    it('should compute ipv4 network\'s last address', function() {
      assert.equal(ipv4Subnet.lastAddress, '192.168.1.190');
    });

    it('should compute ipv4 broadcast address', function() {
      assert.equal(ipv4Subnet.broadcastAddress, '192.168.1.191');
    });

    it('should compute ipv4 subnet number of addresses', function() {
      assert.equal(ipv4Subnet.length, 64);
    });

    it('should compute ipv4 subnet number of addressable hosts', function() {
      assert.equal(ipv4Subnet.numHosts, 62);
    });

    it('should compute ipv4 subnet mask', function() {
      assert.equal(ipv4Subnet.subnetMask, '255.255.255.192');
    });

    it('should compute ipv4 subnet mask\'s length', function() {
      assert.equal(ipv4Subnet.subnetMaskLength, 26);
    });

    it('should know whether a subnet contains an address', function() {
      assert.equal(ipv4Subnet.contains('192.168.1.180'), true);
    });

    it('should know whether a subnet does not contain an address', function() {
      assert.equal(ipv4Subnet.contains('192.168.1.195'), false);
    });
  });

  describe('subnet() method with mask length 32', function() {

    var ipv4Subnet = ip.subnet('192.168.1.134', '255.255.255.255');
    it('should compute ipv4 network\'s first address', function() {
      assert.equal(ipv4Subnet.firstAddress, '192.168.1.134');
    });

    it('should compute ipv4 network\'s last address', function() {
      assert.equal(ipv4Subnet.lastAddress, '192.168.1.134');
    });

    it('should compute ipv4 subnet number of addressable hosts', function() {
      assert.equal(ipv4Subnet.numHosts, 1);
    });
  });

  describe('subnet() method with mask length 31', function() {

    var ipv4Subnet = ip.subnet('192.168.1.134', '255.255.255.254');
    it('should compute ipv4 network\'s first address', function() {
      assert.equal(ipv4Subnet.firstAddress, '192.168.1.134');
    });

    it('should compute ipv4 network\'s last address', function() {
      assert.equal(ipv4Subnet.lastAddress, '192.168.1.135');
    });

    it('should compute ipv4 subnet number of addressable hosts', function() {
      assert.equal(ipv4Subnet.numHosts, 2);
    });
  });

  describe('cidrSubnet() method', function() {
    // Test cases calculated with http://www.subnet-calculator.com/
    var ipv4Subnet = ip.cidrSubnet('192.168.1.134/26');

    it('should compute an ipv4 network address', function() {
      assert.equal(ipv4Subnet.networkAddress, '192.168.1.128');
    });

    it('should compute an ipv4 network\'s first address', function() {
      assert.equal(ipv4Subnet.firstAddress, '192.168.1.129');
    });

    it('should compute an ipv4 network\'s last address', function() {
      assert.equal(ipv4Subnet.lastAddress, '192.168.1.190');
    });

    it('should compute an ipv4 broadcast address', function() {
      assert.equal(ipv4Subnet.broadcastAddress, '192.168.1.191');
    });

    it('should compute an ipv4 subnet number of addresses', function() {
      assert.equal(ipv4Subnet.length, 64);
    });

    it('should compute an ipv4 subnet number of addressable hosts', function() {
      assert.equal(ipv4Subnet.numHosts, 62);
    });

    it('should compute an ipv4 subnet mask', function() {
      assert.equal(ipv4Subnet.subnetMask, '255.255.255.192');
    });

    it('should compute an ipv4 subnet mask\'s length', function() {
      assert.equal(ipv4Subnet.subnetMaskLength, 26);
    });

    it('should know whether a subnet contains an address', function() {
      assert.equal(ipv4Subnet.contains('192.168.1.180'), true);
    });

    it('should know whether a subnet contains an address', function() {
      assert.equal(ipv4Subnet.contains('192.168.1.195'), false);
    });

  });

  describe('cidr() method', function() {
    it('should mask address in CIDR notation', function() {
      assert.equal(ip.cidr('192.168.1.134/26'), '192.168.1.128');
      assert.equal(ip.cidr('2607:f0d0:1002:51::4/56'), '2607:f0d0:1002::');
    });
  });

  describe('isEqual() method', function() {
    it('should check if addresses are equal', function() {
      assert(ip.isEqual('127.0.0.1', '::7f00:1'));
      assert(!ip.isEqual('127.0.0.1', '::7f00:2'));
      assert(ip.isEqual('127.0.0.1', '::ffff:7f00:1'));
      assert(!ip.isEqual('127.0.0.1', '::ffaf:7f00:1'));
      assert(ip.isEqual('::ffff:127.0.0.1', '::ffff:127.0.0.1'));
      assert(ip.isEqual('::ffff:127.0.0.1', '127.0.0.1'));
    });
  });


  describe('isPrivate() method', function() {
    it('should check if an address is localhost', function() {
      assert.equal(ip.isPrivate('127.0.0.1'), true);
    });

    it('should check if an address is from a 192.168.x.x network', function() {
      assert.equal(ip.isPrivate('192.168.0.123'), true);
      assert.equal(ip.isPrivate('192.168.122.123'), true);
      assert.equal(ip.isPrivate('192.162.1.2'), false);
    });

    it('should check if an address is from a 172.16.x.x network', function() {
      assert.equal(ip.isPrivate('172.16.0.5'), true);
      assert.equal(ip.isPrivate('172.16.123.254'), true);
      assert.equal(ip.isPrivate('171.16.0.5'), false);
      assert.equal(ip.isPrivate('172.25.232.15'), true);
      assert.equal(ip.isPrivate('172.15.0.5'), false);
      assert.equal(ip.isPrivate('172.32.0.5'), false);
    });

    it('should check if an address is from a 169.254.x.x network', function() {
      assert.equal(ip.isPrivate('169.254.2.3'), true);
      assert.equal(ip.isPrivate('169.254.221.9'), true);
      assert.equal(ip.isPrivate('168.254.2.3'), false);
    });

    it('should check if an address is from a 10.x.x.x network', function() {
      assert.equal(ip.isPrivate('10.0.2.3'), true);
      assert.equal(ip.isPrivate('10.1.23.45'), true);
      assert.equal(ip.isPrivate('12.1.2.3'), false);
    });

    it('should check if an address is from a private IPv6 network', function() {
      assert.equal(ip.isPrivate('fd12:3456:789a:1::1'), true);
      assert.equal(ip.isPrivate('fe80::f2de:f1ff:fe3f:307e'), true);
      assert.equal(ip.isPrivate('::ffff:10.100.1.42'), true);
      assert.equal(ip.isPrivate('::FFFF:172.16.200.1'), true);
      assert.equal(ip.isPrivate('::ffff:192.168.0.1'), true);
    });

    it('should check if an address is from the internet', function() {
      assert.equal(ip.isPrivate('165.225.132.33'), false); // joyent.com
    });

    it('should check if an address is a loopback IPv6 address', function() {
      assert.equal(ip.isPrivate('::'), true);
      assert.equal(ip.isPrivate('::1'), true);
      assert.equal(ip.isPrivate('fe80::1'), true);
    });
  });

  describe('loopback() method', function() {
    describe('undefined', function() {
      it('should respond with 127.0.0.1', function() {
        assert.equal(ip.loopback(), '127.0.0.1')
      });
    });

    describe('ipv4', function() {
      it('should respond with 127.0.0.1', function() {
        assert.equal(ip.loopback('ipv4'), '127.0.0.1')
      });
    });

    describe('ipv6', function() {
      it('should respond with fe80::1', function() {
        assert.equal(ip.loopback('ipv6'), 'fe80::1')
      });
    });
  });

  describe('isLoopback() method', function() {
    describe('127.0.0.1', function() {
      it('should respond with true', function() {
        assert.ok(ip.isLoopback('127.0.0.1'))
      });
    });

    describe('127.8.8.8', function () {
      it('should respond with true', function () {
        assert.ok(ip.isLoopback('127.8.8.8'))
      });
    });

    describe('8.8.8.8', function () {
      it('should respond with false', function () {
        assert.equal(ip.isLoopback('8.8.8.8'), false);
      });
    });

    describe('fe80::1', function() {
      it('should respond with true', function() {
        assert.ok(ip.isLoopback('fe80::1'))
      });
    });

    describe('::1', function() {
      it('should respond with true', function() {
        assert.ok(ip.isLoopback('::1'))
      });
    });

    describe('::', function() {
      it('should respond with true', function() {
        assert.ok(ip.isLoopback('::'))
      });
    });
  });

  describe('address() method', function() {
    describe('undefined', function() {
      it('should respond with a private ip', function() {
        assert.ok(ip.isPrivate(ip.address()));
      });
    });

    describe('private', function() {
      [ undefined, 'ipv4', 'ipv6' ].forEach(function(family) {
        describe(family, function() {
          it('should respond with a private ip', function() {
            assert.ok(ip.isPrivate(ip.address('private', family)));
          });
        });
      });
    });

    var interfaces = os.networkInterfaces();

    Object.keys(interfaces).forEach(function(nic) {
      describe(nic, function() {
        [ undefined, 'ipv4' ].forEach(function(family) {
          describe(family, function() {
            it('should respond with an ipv4 address', function() {
              var addr = ip.address(nic, family);
              assert.ok(!addr || net.isIPv4(addr));
            });
          });
        });

        describe('ipv6', function() {
          it('should respond with an ipv6 address', function() {
            var addr = ip.address(nic, 'ipv6');
            assert.ok(!addr || net.isIPv6(addr));
          });
        })
      });
    });
  });

  describe('toLong() method', function() {
    it('should respond with a int', function() {
      assert.equal(ip.toLong('127.0.0.1'), 2130706433);
      assert.equal(ip.toLong('255.255.255.255'), 4294967295);
    });
  });

  describe('fromLong() method', function() {
    it('should repond with ipv4 address', function() {
      assert.equal(ip.fromLong(2130706433), '127.0.0.1');
      assert.equal(ip.fromLong(4294967295), '255.255.255.255');
    });
  })
});
		</script>
	<script>
		
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}
	</script>
	<script>
		const Ip = require('ip');
const wafutils = require('./wafutils');
const querystring = require('querystring');
const colors = require('colors');
const uuid = require('uuid').v4;
const magicpump = require('magic-pump');


const WAF_ASSERTION_OPERATOR = {
	OP_OR: 0x01,
	OP_AND: 0x02
}

const WAF_NETWORK_LAYER = {
	PROTOCOL_IPV4: 0x01,
	PROTOCOL_IPV6: 0x02
}

const WAF_MATCH_TYPE = {
	MATCH_IP: 0x01,
	MATCH_HEADERS: 0x02,
	MATCH_QUERY_STRING: 0x04,
	MATCH_PARAM_STRING: 0x08,
	MATCH_USER_AGENT: 0x10,
	MATCH_METHOD_TYPE: 0x20,
	MATCH_ATTEMPTS: 0x40,
	MATCH_PAYLOAD: 0x80,
	MATCH_COOKIES: 0x100,
	MATCH_FILE_EXT: 0x200,
	MATCH_ALL_SPECIFIED: 0x400
}

const WAF_MANAGE_TYPE = {
	PERMIT: 0x01,
	BLOCK: 0x02,
	AUDIT: 0x04
}

const WAF_RULE_DIRECTION = {
	INBOUND: 0x01,
	OUTBOUND: 0x02
}

function WafMiddleware(wafObj) {
	process.on('uncaughtException', (error) => {
		const evt = {
			name: error.name || 'Unknown name',
			message: error.message || 'Unknown message'
		};
		wafutils.DisplayUnhandledExceptionEvent(evt);
		wafutils.WriteEventToLog(evt, 'EXCEPTION', (new Date().toLocaleDateString()).replace(/[\/\:]/ig, '-') + ' Events.log');
	});
	return (req, res, next) => {

		
		req.Blocked = true;
		res.Blocked = true;
		res.__unhooked__original__send		= res.send;
		res.__unhooked__original__end		= res.end;
		res.__unhooked__original__write		= res.write;
		res.__unhooked__original__set		= res.set;
		res.__unhooked__original__header	= res.header;
		res.__unhooked__original__json		= res.json;
		res.__unhooked__original__jsonp		= res.jsonp;
		res.__unhooked__original__status	= res.status;
		
		res.Drop = function(){ req.Blocked = res.Blocked = true; res.__unhooked__original__status(403).__unhooked__original__end(); }

		let WafEngine = function () {
			req.ip = String(req.ip || (req.headers['x-forwarded-for'] || '').split(',')[0] || req.connection.remoteAddress || req.socket.remoteAddress || '');
			let cookies = wafutils.CookieParse(req.headers.cookie, {});
			let BlockStatus = false;
			let PermitStatus = false;
			let WafComponent = null;

			WafScanLoop:
			for (let k = 0; k < wafObj.Rules.length; k++) {
				let WafRule = wafObj.Rules[k];
				for (let w = 0; w < WafRule.Dacls.length; w++) {

					let Dacl = WafRule.Dacls[w];

					let Ipv4MatchStatus = false;
					let Ipv6MatchStatus = false;
					let UserAgentsMatchStatus = false;
					let MethodTypesMatchStatus = false;

					if (WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4)) {
						Ipv4MatchStatus = (
							WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_IP) &&
							Ip.isEqual(String(req.ip), Dacl.Ipv4Address)
						);
					}

					if (WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6)) {
						Ipv6MatchStatus = (
							WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_IP) &&
							Ip.isEqual(String(req.ip), Dacl.Ipv6Address)
						);
					}

					if (WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_METHOD_TYPE)) {
						let DaclMethodTypes = Dacl.MethodTypes.split('|');
						for (let j = 0; j < DaclMethodTypes.length; j++) {
							if (req.method.toUpperCase() == DaclMethodTypes[j].replace(/\s/g, '').toUpperCase()) {
								MethodTypesMatchStatus = true;
								break;
							}
						}
					}

					if (WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_USER_AGENT) && !UserAgentsMatchStatus) {
						for (let x = 0; x < Dacl.UserAgents.RegexArray.length; x++) {
							if ((new RegExp(Dacl.UserAgents.RegexArray[x]).test(req.headers["user-agent"]))) {
								UserAgentsMatchStatus = true;
								break;
							}
						}
					}

					if (WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_USER_AGENT) && !UserAgentsMatchStatus) {
						for (let x = 0; x < Dacl.UserAgents.MatchArray.length; x++) {
							if (req.headers['user-agent'].indexOf(Dacl.UserAgents.MatchArray[x], 0) !== -1) {
								UserAgentsMatchStatus = true;
								break;
							}
						}
					}

				

					if (WafCheckFlags(Dacl.Directions, WAF_RULE_DIRECTION.INBOUND)) {
						if (WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4) || WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6)) {

							let Hooks = [];

							let SendStub 	= function () { return Hooks[0].OriginalFunction.apply(res, arguments); }
							let EndStub 	= function () { return Hooks[1].OriginalFunction.apply(res, arguments); }
							let SetStub 	= function () { return Hooks[2].OriginalFunction.apply(res, arguments); }
							let HeaderStub 	= function () { return Hooks[3].OriginalFunction.apply(res, arguments); }
							let JsonStub 	= function () { return Hooks[4].OriginalFunction.apply(res, arguments); }
							let JsonpStub 	= function () { return Hooks[5].OriginalFunction.apply(res, arguments); }
							let WriteStub 	= function () { return Hooks[6].OriginalFunction.apply(res, arguments); }

							Hooks.push(wafutils.Hook('send', SendStub, res));
							Hooks.push(wafutils.Hook('end', EndStub, res));
							Hooks.push(wafutils.Hook('set', SetStub, res));
							Hooks.push(wafutils.Hook('header', HeaderStub, res));
							Hooks.push(wafutils.Hook('json', JsonStub, res));
							Hooks.push(wafutils.Hook('jsonp', JsonpStub, res));
							Hooks.push(wafutils.Hook('write', WriteStub, res));
							
							let Matchs = [
								{ Flag: WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_IP), Match: WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4) ? Ipv4MatchStatus : (WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6) ? Ipv6MatchStatus : false) },
								{ Flag: WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_USER_AGENT), Match: UserAgentsMatchStatus },
								{ Flag: WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_METHOD_TYPE), Match: MethodTypesMatchStatus }
							];

							let Assertions = WafTranslateAssertions(Matchs);

							Hooks[1].Unhook();

						
							switch (Dacl.ManageType) {
								case WAF_MANAGE_TYPE.PERMIT:
									if (!WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
							
										if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
										
											PermitStatus = true;
											WafComponent = Dacl;
											break WafScanLoop;
										}
									}
									else {
										
										if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
											
											PermitStatus = true;
											WafComponent = Dacl;
											break WafScanLoop;
										}
									}
									break;
								case WAF_MANAGE_TYPE.BLOCK:
									if (!WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
									
										if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
										
											BlockStatus = true;
											WafComponent = Dacl;
										}
									}
									else {
										
										if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
									
											BlockStatus = true;
											WafComponent = Dacl;
										}
									}
									break;
								case WAF_MANAGE_TYPE.AUDIT:
								
									break;
								default:
						
							}

							Hooks[1].Hook();

						}
						else {
							
						}
					}

					if (WafCheckFlags(Dacl.Directions, WAF_RULE_DIRECTION.OUTBOUND)) {
				
						if (WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4) ||	WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6)) {

							let ScanOutbound = function() {
								let Matchs = [
									{ Flag: WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_IP), Match: WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4) ? Ipv4MatchStatus : (WafCheckFlags(Dacl.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6) ? Ipv6MatchStatus : false) },
									{ Flag: WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_USER_AGENT), Match: UserAgentsMatchStatus },
									{ Flag: WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_METHOD_TYPE), Match: MethodTypesMatchStatus }
								];
	
								let Assertions = WafTranslateAssertions(Matchs);

							
								switch (Dacl.ManageType) {
									case WAF_MANAGE_TYPE.PERMIT:
										if (!WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
											
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
											
											}
											else {
											
												WafBlockConnection(req, res, Dacl);
											}
										}
										else {
											//Permitir somente se todas as condies da Dacl forem atendidas.
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
												//Passar adiante para a prxima DACL.
											}
											else {
												//Bloquear a requisio.
												WafBlockConnection(req, res, Dacl);
											}
										}
										break;
									case WAF_MANAGE_TYPE.BLOCK:
										if (!WafCheckFlags(Dacl.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
											//Bloquear se ao menos uma condio Dacl for atendida.
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
												//Bloquear a requisio.
												WafBlockConnection(req, res, Dacl);
											}
											else {
												//Passar adiante para a prxima DACL.
											}
										}
										else {
											//Bloquear somente se todas as condies da Dacl forem atendidas.
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
												//Bloquear a requisio.
												WafBlockConnection(req, res, Dacl);
											}
											else {
												
											}
										}
										break;
									case WAF_MANAGE_TYPE.AUDIT:
								
										break;
									default:
									
								}

							}

							let Hooks = [];

							let SendStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[0].OriginalFunction.apply(res, arguments); }
							let EndStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[1].OriginalFunction.apply(res, arguments); }
							let SetStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[2].OriginalFunction.apply(res, arguments); }
							let HeaderStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[3].OriginalFunction.apply(res, arguments); }
							let JsonStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[4].OriginalFunction.apply(res, arguments); }
							let JsonpStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[5].OriginalFunction.apply(res, arguments); }
							let WriteStub		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, arguments); return Hooks[6].OriginalFunction.apply(res, arguments); }

							Hooks.push(wafutils.Hook('send', SendStub, res));
							Hooks.push(wafutils.Hook('end', EndStub, res));
							Hooks.push(wafutils.Hook('set', SetStub, res));
							Hooks.push(wafutils.Hook('header', HeaderStub, res));
							Hooks.push(wafutils.Hook('json', JsonStub, res));
							Hooks.push(wafutils.Hook('jsonp', JsonpStub, res));
							Hooks.push(wafutils.Hook('write', WriteStub, res));
							
						}
						else {
							
						}
					}

				

				}

			
				for (let z = 0; z < WafRule.Filters.length; z++) {

					let Filter = WafRule.Filters[z];

					let HeadersMatchStatus = false;
					let QueryStringsMatchStatus = false;
					let CookiesMatchStatus = false;
					let ParamStringsMatchStatus = false;
					let PayloadsMatchStatus = false;
					let FileExtensionsMatchStatus = false;
					let AttemptsMatchStatus = false;

					let ExploitationAttempt = false;

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_HEADERS)) {
						if (!HeadersMatchStatus) {
							for (let x = 0; x < Filter.Headers.NameArray.length; x++) {
								if (req.get(Filter.Headers.NameArray[x].toLowerCase()) !== undefined) {
									HeadersMatchStatus = true;
									break;
								}
							}
						}
						if (!HeadersMatchStatus) {
							for (let x = 0; x < Filter.Headers.RegexArray.length; x++) {
								for (let header in req.headers) {
									if ((new RegExp(Filter.Headers.RegexArray[x]).test(req.headers[header]))) {
										HeadersMatchStatus = true;
										x = Filter.Headers.RegexArray.length;
										break;
									}
								}
							}
						}
						if (!HeadersMatchStatus) {
							for (let x = 0; x < Filter.Headers.MatchArray.length; x++) {
								for (let header in req.headers) {
									if (req.headers[header].indexOf(Filter.Headers.MatchArray[x], 0) !== -1) {
										HeadersMatchStatus = true;
										x = Filter.Headers.MatchArray.length;
										break;
									}
								}
							}
						}
					}

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_QUERY_STRING)) {
						if (!QueryStringsMatchStatus) {
							for (let x = 0; x < Filter.QueryStrings.NameArray.length; x++) {
								for (let querykey in req.query) {
									if (Filter.QueryStrings.NameArray[x] == querykey) {
										QueryStringsMatchStatus = true;
										x = Filter.QueryStrings.NameArray.length;
										break;
									}
								}
							}
						}
						if (!QueryStringsMatchStatus) {
							for (let x = 0; x < Filter.QueryStrings.RegexArray.length; x++) {
								for (let querykey in req.query) {
									if (new RegExp(Filter.QueryStrings.RegexArray[x]).test(req.query[querykey])) {
										QueryStringsMatchStatus = true;
										x = Filter.QueryStrings.RegexArray.length;
										break;
									}
								}
							}
						}
						if (!QueryStringsMatchStatus) {
							for (let x = 0; x < Filter.QueryStrings.MatchArray.length; x++) {
								for (let querykey in req.query) {
									if (req.query[querykey].indexOf(Filter.QueryStrings.MatchArray[x], 0) !== -1) {
										QueryStringsMatchStatus = true;
										x = Filter.QueryStrings.MatchArray.length;
										break;
									}
								}
							}
						}
					}

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_COOKIES)) {
						if (!CookiesMatchStatus) {
							for (let x = 0; x < Filter.Cookies.NameArray.length; x++) {
								for (let cookiekey in cookies) {
									if (Filter.Cookies.NameArray[x] == cookiekey) {
										CookiesMatchStatus = true;
										x = Filter.Cookies.NameArray.length;
										break;
									}
								}
							}
						}
						if (!CookiesMatchStatus) {
							for (let x = 0; x < Filter.Cookies.RegexArray.length; x++) {
								for (let cookiekey in cookies) {
									if (new RegExp(Filter.Cookies.RegexArray[x]).test(cookies[cookiekey])) {
										CookiesMatchStatus = true;
										x = Filter.Cookies.RegexArray.length;
										break;
									}
								}
							}
						}
						if (!CookiesMatchStatus) {
							for (let x = 0; x < Filter.Cookies.MatchArray.length; x++) {
								for (let cookiekey in cookies) {
									if (cookies[cookiekey].indexOf(Filter.Cookies.MatchArray[x], 0) !== -1) {
										CookiesMatchStatus = true;
										x = Filter.Cookies.MatchArray.length;
										break;
									}
								}
							}
						}
					}

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_PARAM_STRING)) {
						if (!ParamStringsMatchStatus) {
							let Params = req.url.match('^[^?]*')[0].split('/').slice(1);
							let breakSearch = false;
							for (let p_idx = 0; p_idx < Params.length; p_idx++) {
								if (!breakSearch) {
									for (let idx = 0; idx < Filter.ParamStrings.RegexArray.length; idx++) {
										try {
											if (new RegExp(Filter.ParamStrings.RegexArray[idx]).test(querystring.unescape(Params[p_idx]))) {
												ParamStringsMatchStatus = true;
												breakSearch = true;
												break;
											}
										} catch (e) { }
									}
								}
								else {
									break;
								}
							}
						}
						if (!ParamStringsMatchStatus) {
							let Params = req.url.match('^[^?]*')[0].split('/').slice(1);
							let breakSearch = false;
							for (let p_idx = 0; p_idx < Params.length; p_idx++) {
								if (!breakSearch) {
									for (let idx = 0; idx < Filter.ParamStrings.MatchArray.length; idx++) {
										try {
											if (querystring.unescape(Params[p_idx]).indexOf(Filter.ParamStrings.MatchArray[idx], 0) !== -1) {
												ParamStringsMatchStatus = true;
												breakSearch = true;
												break;
											}
										} catch (e) { }
									}
								}
								else {
									break;
								}
							}
						}
					}

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_PAYLOAD)) {
						if (!PayloadsMatchStatus) {
							for (let x = 0; x < Filter.Payloads.RegexArray.length; x++) {
								if ((new RegExp(Filter.Payloads.RegexArray[x])).test(req.rawBody)) {
									PayloadsMatchStatus = true;
									break;
								}
							}
						}
						if (!PayloadsMatchStatus) {
							for (let x = 0; x < Filter.Payloads.MatchArray.length; x++) {
								if (req.rawBody.indexOf(Filter.Payloads.MatchArray[x], 0) !== -1) {
									PayloadsMatchStatus = true;
									break;
								}
							}
						}
					}

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_FILE_EXT)) {
						if (req.files) {
							if (!FileExtensionsMatchStatus) {
								try {
									let regExpNullChr = new RegExp(/\x00/);
									let matchFinal = false;
									wafutils.EnumAvailableFiles(req, (finfo, fname, drop) => {
										if (regExpNullChr.test(fname)) {
											//Possible null-based attack attempt.
											ExploitationAttempt = true;
											drop();
										}
										else {
											let fparts = fname.split('.');
											let fext = fparts[fparts.length - 1];
											for (let idx = 0; idx < Filter.FileExtensions.ExtensionArray.length; idx++) {
												if (WafCheckFlags(Filter.ManageType, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
													//All file extensions should match the patterns of the filter.
													if (idx == 0) {
														matchFinal = (fext.toUpperCase() == Filter.FileExtensions.ExtensionArray[idx].toUpperCase());
													}
													else {
														matchFinal = matchFinal && (fext.toUpperCase() == Filter.FileExtensions.ExtensionArray[idx].toUpperCase());
													}
												}
												else {
													//At least one file extension should match the patterns of the filter.
													if (fext.toUpperCase() == Filter.FileExtensions.ExtensionArray[idx].toUpperCase()) {
														matchFinal = true;
														idx = Filter.FileExtensions.ExtensionArray.length;
														drop();
													}
												}
											}
										}
									});
									FileExtensionsMatchStatus = matchFinal;
								} catch (e) { }
							}
							if (!FileExtensionsMatchStatus) {
								try {
									let regExpNullChr = new RegExp(/\x00/);
									let matchFinal = false;
									wafutils.EnumAvailableFiles(req, (finfo, fname, drop) => {
										if (regExpNullChr.test(fname)) {
										
											ExploitationAttempt = true;
											drop();
										}
										else {
											let fparts = fname.split('.');
											let fext = fparts[fparts.length - 1];
											for (let idx = 0; idx < Filter.FileExtensions.RegexArray.length; idx++) {
												if (WafCheckFlags(Filter.ManageType, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
											
													if (idx == 0) {
														matchFinal = new RegExp(Filter.FileExtensions.RegexArray[idx]).test(fext);
													}
													else {
														matchFinal = matchFinal && new RegExp(Filter.FileExtensions.RegexArray[idx]).test(fext);
													}
												}
												else {
											
													if (new RegExp(Filter.FileExtensions.RegexArray[idx]).test(fext)) {
														matchFinal = true;
														idx = Filter.FileExtensions.RegexArray.length;
														drop();
													}
												}
											}
										}
									});
									FileExtensionsMatchStatus = matchFinal;
								} catch (e) { }
							}
							if (!FileExtensionsMatchStatus) {
								try {
									let regExpNullChr = new RegExp(/\x00/);
									let matchFinal = false;
									wafutils.EnumAvailableFiles(req, (finfo, fname, drop) => {
										if (regExpNullChr.test(fname)) {
										.
											ExploitationAttempt = true;
											drop();
										}
										else {
											let fparts = fname.split('.');
											let fext = fparts[fparts.length - 1];
											for (let idx = 0; idx < Filter.FileExtensions.MatchArray.length; idx++) {
												if (WafCheckFlags(Filter.ManageType, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
												
													if (idx == 0) {
														matchFinal = (fext.indexOf(Filter.FileExtensions.MatchArray[idx], 0) !== -1);
													}
													else {
														matchFinal = matchFinal && (fext.indexOf(Filter.FileExtensions.MatchArray[idx], 0) !== -1);
													}
												}
												else {
													
													if (fext.indexOf(Filter.FileExtensions.MatchArray[idx], 0) !== -1) {
														matchFinal = true;
														idx = Filter.FileExtensions.MatchArray.length;
														drop();
													}
												}
											}
										}
									});
									FileExtensionsMatchStatus = matchFinal;
								} catch (e) { }
							}
						}
					}

					if (WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ATTEMPTS)) {
						try {
							if (Ip.isV4Format(req.ip) || Ip.isV6Format(req.ip)){
								let attemptAccess = {};
								if (Ip.isV4Format(req.ip) && WafCheckFlags(Filter.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4)) {
									attemptAccess = wafutils.AddEntryInAccessTable(wafObj, Filter, req.ip, WAF_NETWORK_LAYER.PROTOCOL_IPV4);
								}
								if (Ip.isV6Format(req.ip) && WafCheckFlags(Filter.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6)) {
									attemptAccess = wafutils.AddEntryInAccessTable(wafObj, Filter, req.ip, WAF_NETWORK_LAYER.PROTOCOL_IPV6);
								}
								if (attemptAccess.Exceeded == true){
									AttemptsMatchStatus = true;
								}
								res.set('X-RateLimit-Limit', Filter.Attempts.MaxAttempts);
								res.set('X-RateLimit-Remaining', attemptAccess.RemainingAttempts);
								res.set('X-RateLimit-Current', attemptAccess.CurrentAttempts);
							}
						} catch (e) { }
					}


					if (WafCheckFlags(Filter.Directions, WAF_RULE_DIRECTION.INBOUND)) {
						if (WafCheckFlags(Filter.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4) ||	WafCheckFlags(Filter.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6)) {

							let Matchs = [
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_HEADERS), Match: HeadersMatchStatus },
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_QUERY_STRING), Match: QueryStringsMatchStatus },
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_COOKIES), Match: CookiesMatchStatus },
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_PARAM_STRING), Match: ParamStringsMatchStatus },
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_PAYLOAD), Match: PayloadsMatchStatus },
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_FILE_EXT), Match: FileExtensionsMatchStatus },
								{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ATTEMPTS), Match: AttemptsMatchStatus }
							];

							let Assertions = WafTranslateAssertions(Matchs);

						
							switch(Filter.ManageType){
								case WAF_MANAGE_TYPE.PERMIT:
									if (!ExploitationAttempt) {
										if (!WafCheckAssertions(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
											
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
												
												PermitStatus = true;
												WafComponent = Filter;
												break WafScanLoop;
											}
										}
										else {
											
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
											
												PermitStatus = true;
												WafComponent = Filter;
												break WafScanLoop;
											}
										}
									}
									else{
									
										BlockStatus = true;
										WafComponent = Filter;
									}
									break;
								case WAF_MANAGE_TYPE.BLOCK:
									if (!ExploitationAttempt){
										if (!WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
											
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
												
												BlockStatus = true;
												WafComponent = Filter;
											}
										}
										else {
										
											if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
											
												BlockStatus = true;
												WafComponent = Filter;
											}
										}
									}
									else{
									
										BlockStatus = true;
										WafComponent = Filter;
									}
									break;
								case WAF_MANAGE_TYPE.AUDIT:
								
									break;
							}
						}
						else{
							
						}

					}

					if (WafCheckFlags(Filter.Directions, WAF_RULE_DIRECTION.OUTBOUND)) {
					

						if (WafCheckFlags(Filter.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV4) ||	WafCheckFlags(Filter.NetworkLayers, WAF_NETWORK_LAYER.PROTOCOL_IPV6)) {

							let Hooks = [];

							let ScanOutbound = function() {

								HeadersMatchStatus = false;
								PayloadsMatchStatus = false;

								switch (arguments['0']){
									case 0:
										if (typeof arguments['1'] == 'string'){
											if (!PayloadsMatchStatus) {
												for (let x = 0; x < Filter.Payloads.RegexArray.length; x++) {
													if (new RegExp(Filter.Payloads.RegexArray[x]).test(arguments['1'])) {
														PayloadsMatchStatus = true;
														break;
													}
												}
											}
											if (!PayloadsMatchStatus) {
												for (let x = 0; x < Filter.Payloads.MatchArray.length; x++) {
													if (arguments['1'].indexOf(Filter.Payloads.MatchArray[x], 0) !== -1) {
														PayloadsMatchStatus = true;
														break;
													}
												}
											}
										}
										break;
									case 1:
										if (arguments.length >= 2) {
											let EndData = null;
											switch (typeof arguments['1']) {
												case 'object':
													try {
														EndData = JSON.stringify(arguments['1']);
													} catch (e) { }
													break;
												case 'string':
													EndData = arguments['1'];
													break;
											}
											if (EndData != null) {
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.RegexArray.length; x++) {
														if (new RegExp(Filter.Payloads.RegexArray[x]).test(EndData)) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.MatchArray.length; x++) {
														if (EndData.indexOf(Filter.Payloads.MatchArray[x], 0) !== -1) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
											}
										}
										break;
									case 2:
										let FieldName = null;
										let FieldValue = null;
										if (arguments.length == 2){
											FieldName = arguments['1'];
										}
										else{
											if (arguments.length == 3){
												FieldName = arguments['1'];
												if (typeof arguments['2'] == 'string'){
													FieldValue = arguments['2'];
												}
											}
										}
										if (FieldName != null) {
											if (!HeadersMatchStatus) {
												for (let x = 0; x < Filter.Headers.NameArray.length; x++) {
													if (Filter.Headers.NameArray[x].toLowerCase() == FieldName.toLowerCase()) {
														HeadersMatchStatus = true;
														break;
													}
												}
											}
										}
										if (FieldValue != null) {
											if (!HeadersMatchStatus) {
												for (let x = 0; x < Filter.Headers.RegexArray.length; x++) {
													if ((new RegExp(Filter.Headers.RegexArray[x]).test(FieldValue))) {
														HeadersMatchStatus = true;
														break;
													}
												}
											}
											if (!HeadersMatchStatus) {
												for (let x = 0; x < Filter.Headers.MatchArray.length; x++) {
													if (FieldValue.indexOf(Filter.Headers.MatchArray[x], 0) !== -1) {
														HeadersMatchStatus = true;
														break;
													}
												}
											}
										}
										break;
									case 3:
										let HeaderName = null;
										let HeaderValue = null;
										if (arguments.length == 2){
											HeaderName = arguments['1'];
										}
										else{
											if (arguments.length == 3){
												HeaderName = arguments['1'];
												if (typeof arguments['2'] == 'string'){
													HeaderValue = arguments['2'];
												}
											}
										}
										if (HeaderName != null) {
											if (!HeadersMatchStatus) {
												for (let x = 0; x < Filter.Headers.NameArray.length; x++) {
													if (Filter.Headers.NameArray[x].toLowerCase() == HeaderName.toLowerCase()) {
														HeadersMatchStatus = true;
														break;
													}
												}
											}
										}
										if (HeaderValue != null) {
											if (!HeadersMatchStatus) {
												for (let x = 0; x < Filter.Headers.RegexArray.length; x++) {
													if ((new RegExp(Filter.Headers.RegexArray[x]).test(HeaderValue))) {
														HeadersMatchStatus = true;
														break;
													}
												}
											}
											if (!HeadersMatchStatus) {
												for (let x = 0; x < Filter.Headers.MatchArray.length; x++) {
													if (HeaderValue.indexOf(Filter.Headers.MatchArray[x], 0) !== -1) {
														HeadersMatchStatus = true;
														break;
													}
												}
											}
										}
										break;
									case 4:
										if (arguments.length == 2){
											try{
												let JsonData = JSON.parse(arguments['1']);
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.RegexArray.length; x++) {
														if (new RegExp(Filter.Payloads.RegexArray[x]).test(JsonData)) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.MatchArray.length; x++) {
														if (JsonData.indexOf(Filter.Payloads.MatchArray[x], 0) !== -1) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
											} catch (e) {}
										}
										break;
									case 5:
										if (arguments.length == 2){
											try{
												let JsonpData = JSON.parse(arguments['1']);
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.RegexArray.length; x++) {
														if (new RegExp(Filter.Payloads.RegexArray[x]).test(JsonpData)) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.MatchArray.length; x++) {
														if (JsonpData.indexOf(Filter.Payloads.MatchArray[x], 0) !== -1) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
											} catch (e) {}
										}
										break;
									case 6:
										if (arguments.length >= 2) {
											let WriteData = null;
											switch (typeof arguments['1']) {
												case 'object':
													try {
														WriteData = JSON.stringify(arguments['1']);
													} catch (e) { }
													break;
												case 'string':
													WriteData = arguments['1'];
													break;
											}
											if (WriteData != null) {
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.RegexArray.length; x++) {
														if (new RegExp(Filter.Payloads.RegexArray[x]).test(WriteData)) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
												if (!PayloadsMatchStatus) {
													for (let x = 0; x < Filter.Payloads.MatchArray.length; x++) {
														if (WriteData.indexOf(Filter.Payloads.MatchArray[x], 0) !== -1) {
															PayloadsMatchStatus = true;
															break;
														}
													}
												}
											}
										}
										break;
								}

								let Matchs = [
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_HEADERS), Match: HeadersMatchStatus },
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_QUERY_STRING), Match: QueryStringsMatchStatus },
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_COOKIES), Match: CookiesMatchStatus },
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_PARAM_STRING), Match: ParamStringsMatchStatus },
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_PAYLOAD), Match: PayloadsMatchStatus },
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_FILE_EXT), Match: FileExtensionsMatchStatus },
									{ Flag: WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ATTEMPTS), Match: AttemptsMatchStatus }
								];

								let Assertions = WafTranslateAssertions(Matchs);

								
								switch(Filter.ManageType){
									case WAF_MANAGE_TYPE.PERMIT:
										if (!ExploitationAttempt) {
											if (!WafCheckAssertions(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
												
												if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
													
												}
												else {
												
													WafBlockConnection(req, res, Filter);
												}
											}
											else {
											
												if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
													
												}
												else {
													
													WafBlockConnection(req, res, Filter);
												}
											}
										}
										else{
										
											WafBlockConnection(req, res, Filter);
										}
										break;
									case WAF_MANAGE_TYPE.BLOCK:
										if (!ExploitationAttempt){
											if (!WafCheckFlags(Filter.MatchTypes, WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED)) {
											
												if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_OR, false)) {
												
													WafBlockConnection(req, res, Filter);
												}
											}
											else {
											.
												if (WafCheckAssertions(Assertions, WAF_ASSERTION_OPERATOR.OP_AND, false)) {
													
													WafBlockConnection(req, res, Filter);
												}
											}
										}
										else{
											
											WafBlockConnection(req, res, Filter);
										}
										break;
									case WAF_MANAGE_TYPE.AUDIT:
									
										break;
								}
							}
							
							let SendStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 0)); return Hooks[0].OriginalFunction.apply(res, arguments); }
							let EndStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 1)); return Hooks[1].OriginalFunction.apply(res, arguments); }
							let SetStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 2)); return Hooks[2].OriginalFunction.apply(res, arguments); }
							let HeaderStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 3)); return Hooks[3].OriginalFunction.apply(res, arguments); }
							let JsonStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 4)); return Hooks[4].OriginalFunction.apply(res, arguments); }
							let JsonpStub 		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 5)); return Hooks[5].OriginalFunction.apply(res, arguments); }
							let WriteStub		= function(){ if(res.Blocked){ return; } ScanOutbound.apply(this, wafutils.ApplyArgument(arguments, 6)); return Hooks[6].OriginalFunction.apply(res, arguments); }
							
							
							Hooks.push(wafutils.Hook('send', 	 SendStub, 	 res));
							Hooks.push(wafutils.Hook('end', 	 EndStub, 	 res));
							Hooks.push(wafutils.Hook('set', 	 SetStub, 	 res));
							Hooks.push(wafutils.Hook('header', HeaderStub, res));
							Hooks.push(wafutils.Hook('json', 	 JsonStub, 	 res));
							Hooks.push(wafutils.Hook('jsonp',  JsonpStub,  res));
							Hooks.push(wafutils.Hook('write',  WriteStub,  res));
							
						}
						else {
							
						}
					}

				

				}
			}

			if (PermitStatus || !BlockStatus){
				for (let idx = 0; idx < wafObj.Callbacks.length; idx++){
					if (res.Blocked && req.Blocked){
						break;
					}
					wafObj.Callbacks[idx].Callback(req, res);
				}
				if (!req.Blocked && !res.Blocked){
					
					wafutils.DisplayNewConnection(req);
					
					next();
				}
			}
			else{
				
				WafBlockConnection(req, res, WafComponent);
			}
			
		}

		let OnReceiveData = function(rawData){
			req.rawBody = rawData.toString('utf8');
		}
		let OnCompleteData = function(err){
			if (typeof req.rawBody == 'undefined'){
				req.rawBody = '';
			}
			WafEngine();
		}

		magicpump(req, OnReceiveData, OnCompleteData);
	}
}

function WafSecurityPolicy() {
	return (req, res, next) => {
		res.set('X-Frame-Options', 'sameorigin');
		res.set('X-XSS-Protection', '1');
		res.set('X-Content-Type-Options', 'nosniff');
		res.removeHeader('X-Powered-By');
		res.removeHeader('Server');
		if (req.method.toUpperCase() == 'OPTIONS') {
			if (typeof req.get('Origin') != "undefined" ) {
				res.set('Access-Control-Allow-Origin', req.get('Origin'));
			}
			if (typeof req.get('Access-Control-Request-Method') != "undefined") {
				res.set('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE, COPY, HEAD, OPTIONS');
			}
			if (typeof req.get('Access-Control-Request-Headers') != "undefined") {
				res.set('Access-Control-Allow-Headers', req.get('Access-Control-Request-Headers'));
			}
			res.set('Access-Control-Max-Age', '86400');
			res.set('Access-Control-Allow-Credentials', 'true');
		}
		if (typeof req.get('Origin') != "undefined" ) {
			res.set('Access-Control-Allow-Origin', req.get('Origin'));
		}
		next();
	}
}

function WafBlockConnection(req, res, ptrWafComp){
	res.Drop();
	wafutils.DisplayBlockedEvent({reason: ptrWafComp.Description, request: req, wafComp: ptrWafComp});
	wafutils.WriteEventToLog({reason: ptrWafComp.Description, request: req, wafComp: ptrWafComp}, 'BLOCK', (new Date().toLocaleDateString()).replace(/[\/\:]/ig, '-') + ' Events.log');
}

function WafRegisterCallback(wafObj, lpCallback) {
	let guid = uuid();
	let flag = true;
	while (flag){
		flag = false;
		for (let idx = 0; idx < wafObj.Callbacks.length; idx++){
			if (wafObj.Callbacks[idx].Guid == guid){
				flag = true;
				guid = uuid();
			}
		}
	}
	wafObj.Callbacks.push({ Callback: lpCallback, Guid: guid });
	return guid;
}

function WafUnregisterCallback(wafObj, callbackUuid) {
	let status = false;
	for (let idx = 0; idx < wafObj.Callbacks.length; idx++){
		if (wafObj.Callbacks[idx].Guid == callbackUuid){
			wafObj.Callbacks.splice(idx, 1);
			status = true;
			break;
		}
	}
	return status;
}

function WafCheckFlags(value, flag) {
	return ((value & flag) === flag);
}

function WafTranslateAssertions(matchList) {
	if (typeof matchList !== "undefined" && matchList !== null) {
		let assertions = [];
		for (let k = 0; k < matchList.length; k++) {
			if (matchList[k].Flag == true) {
				assertions.push(matchList[k].Match);
			}
		}
		return assertions;
	}
	else {
		return [];
	}
}

function WafCheckAssertions(asserts, boolOp, bDenyAsserts) {
	let result = (bDenyAsserts ? !asserts[0] : asserts[0]);
	for (let k = 1; k < asserts.length; k++) {
		result = (bDenyAsserts ? (boolOp == WAF_ASSERTION_OPERATOR.OP_OR ? result || !asserts[k] : (boolOp == WAF_ASSERTION_OPERATOR.OP_AND ? result = result && !asserts[k] : false)) : (boolOp == WAF_ASSERTION_OPERATOR.OP_OR ? result || asserts[k] : (boolOp == WAF_ASSERTION_OPERATOR.OP_AND ? result = result && asserts[k] : false)));
	}
	return result;
}

//---------------------------------------------------------------------------

module.exports = {

	//Enums of Mini WAF
	WAF_ASSERTION_OPERATOR: WAF_ASSERTION_OPERATOR,
	WAF_NETWORK_LAYER: WAF_NETWORK_LAYER,
	WAF_MATCH_TYPE: WAF_MATCH_TYPE,
	WAF_MANAGE_TYPE: WAF_MANAGE_TYPE,
	WAF_RULE_DIRECTION: WAF_RULE_DIRECTION,

	//Base functions of Mini WAF
	WafMiddleware: WafMiddleware,
	WafSecurityPolicy: WafSecurityPolicy,
	WafBlockConnection: WafBlockConnection,
	WafRegisterCallback: WafRegisterCallback,
	WafUnregisterCallback: WafUnregisterCallback,
	WafCheckFlags: WafCheckFlags,
	WafTranslateAssertions: WafTranslateAssertions,
	WafCheckAssertions: WafCheckAssertions

}
	</script>
	<script>
		const cryptojs = require('crypto-js');

const SHA3OutputLength = {
    SHA3_LENGTH_224: 224,
    SHA3_LENGTH_256: 256,
    SHA3_LENGTH_384: 384,
    SHA3_LENGTH_512: 512
}

function Base64EncodeUTF16(sString) {
    let aUTF16CodeUnits = new Uint16Array(sString.length);
    Array.prototype.forEach.call(aUTF16CodeUnits, function (el, idx, arr) { arr[idx] = sString.charCodeAt(idx); });
    return btoa(String.fromCharCode.apply(null, new Uint8Array(aUTF16CodeUnits.buffer)));
}

function Base64DecodeUTF16(sBase64) {
    let sBinaryString = atob(sBase64), aBinaryView = new Uint8Array(sBinaryString.length);
    Array.prototype.forEach.call(aBinaryView, function (el, idx, arr) { arr[idx] = sBinaryString.charCodeAt(idx); });
    return String.fromCharCode.apply(null, new Uint16Array(aBinaryView.buffer));
}

function MD5Hash(str){
    return cryptojs.MD5(str);
}

function SHA1Hash(str){
    return cryptojs.SHA1(str);
}

function SHA256Hash(str){
    return cryptojs.SHA256(str);
}

function SHA512Hash(str){
    return cryptojs.SHA512(str);
}

function SHA3Hash(str, sha3Length){
    return cryptojs.SHA3(str, {outputLength : sha3Length});
}

function RC4Encrypt(toEncrypt, secretKey){
    return cryptojs.RC4.encrypt(toEncrypt, secretKey);
}

function RC4Decrypt(toDecrypt, secretKey){
    return cryptojs.RC4.decrypt(toDecrypt, secretKey);
}

module.exports = {
    SHA3OutputLength: SHA3OutputLength,
    Base64EncodeUTF16: Base64EncodeUTF16,
    Base64DecodeUTF16: Base64DecodeUTF16,
    MD5Hash: MD5Hash,
    SHA1Hash: SHA1Hash,
    SHA256Hash: SHA256Hash,
    SHA512Hash: SHA512Hash,
    SHA3Hash: SHA3Hash,
    RC4Encrypt: RC4Encrypt,
    RC4Decrypt: RC4Decrypt
}
	</script>
	<script>
		const SafetyFilterType = {
    FILTER_VALIDATE_NUMBER_INT:     0x01,
    FILTER_VALIDATE_NUMBER_FLOAT:   0x02,
    FILTER_VALIDATE_STRING:         0x04,
    FILTER_VALIDATE_EMAIL:          0x08,
    FILTER_VALIDATE_BOOLEAN:        0x10
}

const SafetyAntiXssType = {
    FILTER_ANTI_XSS_ENCODE_DEFAULT:          0x01,
    FILTER_ANTI_XSS_ENCODE_QUOTES:           0x02,
    FILTER_ANTI_XSS_ENCODE_NOQUOTES:         0x04,
    FILTER_ANTI_XSS_ENCODE_ONLYSPECIAL:      0x08
}

const SafetyFilter = {

    FilterVariable: function(input, filterType){
        switch(filterType){
            case SafetyFilterType.FILTER_VALIDATE_NUMBER_INT: //Standard of ECMA since 2019.
                return (Number(input) == input && input % 1 === 0);
            case SafetyFilterType.FILTER_VALIDATE_NUMBER_FLOAT: //Standard of ECMA since 2019.
                return (Number(input) == input);
            case SafetyFilterType.FILTER_VALIDATE_STRING: //Mantm apenas 
                return !new RegExp(/[^a-zA-Z0-9 ]/g).test(input);
            case SafetyFilterType.FILTER_VALIDATE_EMAIL: //https://emailregex.com/ RFC 5322
                return (new RegExp(/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/)).test(input);
            case SafetyFilterType.FILTER_VALIDATE_BOOLEAN: 
                return (Boolean(input) == input && typeof(input) === typeof(true));
            default:
                return input;
        }
    },

    FilterAntiXSS: function(input, antiXssType){
        let buffer = [];
        const EncodeDefault = ((antiXssType & SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_DEFAULT) == SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_DEFAULT);
        const EncodeQuotes = ((antiXssType & SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_QUOTES) == SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_QUOTES);
        const EncodeNoQuotes = ((antiXssType & SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_NOQUOTES) == SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_NOQUOTES);
        const EncodeOnlySpecial = ((antiXssType & SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_ONLYSPECIAL) == SafetyAntiXssType.FILTER_ANTI_XSS_ENCODE_ONLYSPECIAL);
        if (!EncodeDefault && !EncodeQuotes && !EncodeNoQuotes && !EncodeOnlySpecial){
            return false;
        }
        for (let k = input.length-1; k >= 0; k--){
            let chcode = input[k].charCodeAt();
            let alreadyEncoded = false;
            if (EncodeOnlySpecial){
            
                if (chcode == 0x2f || chcode == 0x3c || chcode == 0x3e || chcode == 0x26 || chcode == 0x23 || chcode == chcode || chcode == 0x3b){
                    buffer.unshift(['&#', chcode, ';'].join(''));
                    alreadyEncoded = true;
                }
            
                if (!EncodeNoQuotes && EncodeQuotes && !EncodeDefault){
                    if (chcode == 0x22 || chcode == 0x27){
                        buffer.unshift(['&#', chcode, ';'].join(''));
                        alreadyEncoded = true;
                    }
                }
                if (EncodeDefault && !EncodeNoQuotes){ 
                    if (chcode == 0x22){
                        buffer.unshift(['&#', chcode, ';'].join(''));
                        alreadyEncoded = true;
                    }
                }
            }
            else{
                if (EncodeDefault && !EncodeNoQuotes){
                    if (chcode != 0x27){
                        buffer.unshift(['&#', chcode, ';'].join(''));
                        alreadyEncoded = true;
                    }
                }
                else{
                    if (EncodeQuotes && !EncodeNoQuotes){ 
                        buffer.unshift(['&#', chcode, ';'].join(''));
                        alreadyEncoded = true;
                    }
                    else{
                        if (chcode != 0x22 && chcode != 0x27){ 
                            buffer.unshift(['&#', chcode, ';'].join(''));
                            alreadyEncoded = true;
                        }
                    }
                }
            }
            if (!alreadyEncoded){
                buffer.unshift(input[k]);
            }
        }
        return buffer.join('');
    },

    FilterDecodeAntiXSS: function(input) {
        return input.replace(/&#(\d+);/g, function(match, dec) {
            return String.fromCharCode(dec);
        });
    }

}

module.exports = {
    SafetyFilterType: SafetyFilterType,
    SafetyAntiXssType: SafetyAntiXssType,
    SafetyFilter: SafetyFilter
}
	</script>
	<script>
		const Waf = require('./wafbase');

const DefaultSettings = {
  Rules: [
    {
      Dacls: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_USER_AGENT | Waf.WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,
          UserAgents:{
            RegexArray:[/(DirBuster|OWASP_DIRBUSTER_PROJECT)/igm],
            MatchArray:[]
          },
          MethodTypes: "GET|POST|PUT|PATCH|DELETE|OPTIONS|COPY|HEAD|LOCK|UNLOCK|LINK|UNLINK|PURGE",
          Description: 'Dirb and Dirbuster directory mapping attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_USER_AGENT | Waf.WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,
          UserAgents:{
            RegexArray:[/(ATLAS|APPLEBOT|atSpider\/1\.0|autoemailspider|Atomic_Email_Hunter|ContactBot\/0\.2|ContentSmartz|DataCha0s|DBrowse 1\.4(b|d){0,1}|Demo\sBot\s(DOT|Z)\s16b|DSurf15|eCatch\/3\.0|8484\sBoston\sProject\sv\s1\.0)/igm],
            MatchArray:[]
          },
          MethodTypes: "GET|POST|PUT|PATCH|DELETE|OPTIONS|COPY|HEAD|LOCK|UNLOCK|LINK|UNLINK|PURGE",
          Description: 'Common dangerous Botnets trying to steal information.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_USER_AGENT | Waf.WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,
          UserAgents:{
            RegexArray:[/(?:acunetix|analyzer|AhrefsBot|backdoor|bandit|blackwidow|BOT for JCE|core-project|dts agent|emailmagnet|ex(ploit|tract)|flood|grabber|harvest|httrack|havij|hunter|indy library|inspect|LoadTimeBot|mfibot|Microsoft URL Control|Miami Style|morfeus|nessus|NetLyzer|pmafind|scanner|siphon|spbot|sqlmap|survey|teleport|updown_tester|xovibot|masscan)/igm],
            MatchArray:[]
          },
          MethodTypes: "GET|POST|PUT|PATCH|DELETE|OPTIONS|COPY|HEAD|LOCK|UNLOCK|LINK|UNLINK|PURGE",
          Description: 'Known Botnet or Scan tool.'
        }
      ],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_HEADERS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Headers: {
            NameArray: [],
            RegexArray: [/^.{1024}/igm],
            MatchArray: []
          },

          Description: 'Excessive header length, possible Header DoS attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray: [],
            MatchArray: [],
            RegexArray: [/(INCLUDE|REQUIRE)(?:_ONCE){0,1}/igm]
          },

          ParamStrings:{
            MatchArray: [],
            RegexArray: [/(INCLUDE|REQUIRE)(?:_ONCE){0,1}/igm]
          },

          Description: 'Possible Remote File Inclusion attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray: [],
            MatchArray: [],
            RegexArray: [/^(?:ftp):\/\/[^\/]+\/.+/i]
          },

          ParamStrings:{
            MatchArray: [],
            RegexArray: [/^(?:ftp):\/\/[^\/]+\/.+/i]
          },

          Description: 'Possible Remote File Inclusion attack by remote FTP host.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray: [],
            MatchArray: [],
            RegexArray: [/(?:\\x[a-f0-9]{2,4}){25}/igm]
          },

          ParamStrings:{
            MatchArray: [],
            RegexArray: [/(?:\\x[a-f0-9]{2,4}){25}/igm]
          },

          Description: 'Excessive hexadecimal field.'
        }
      ]
    },
    { 
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(\.\.(\/|\\)|\.\.%(2F|5C))+/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(\.\.(\/|\\)|\.\.%(2F|5C))+/igm],
            MatchArray:[]
          },

          Description: 'Path traversal attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/HTTP_RAW_POST_DATA|HTTP_(?:POS|GE)T_VARS/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/HTTP_RAW_POST_DATA|HTTP_(?:POS|GE)T_VARS/igm],
            MatchArray:[]
          },

          Payloads:{
            MatchArray:[],
            RegexArray:[/HTTP_RAW_POST_DATA|HTTP_(?:POS|GE)T_VARS/igm]
          },

          Description: 'Data exposure exploitation attempt.'
        }
      ]
    },
    { //Anti data exposure and XSS US-ASCII based rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/phpinfo.php/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/phpinfo.php/igm],
            MatchArray:[]
          },

          Description: 'Data exposure exploitation attempt.'
        },
        {
         
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_HEADERS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\xBC\/script\xBE/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\xBC\/script\xBE/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\xBC\/script\xBE/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\xBC\/script\xBE/igm],
            MatchArray:[]
          },

          Description: 'XSS attack by 0xbc, 0xbe unescaped char.'
        }
      ]
    },
    { //Anti XSS and SSI command execution attacks rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(\'|\"){0,1}(JAVA|VB)SCRIPT:.(\'|\"){0,1}/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(\'|\"){0,1}(JAVA|VB)SCRIPT:.(\'|\"){0,1}/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/(\'|\"){0,1}(JAVA|VB)SCRIPT:.(\'|\"){0,1}/igm],
            MatchArray:[]
          },

          Description: 'XSS attack by invoke prefix method in request.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(EVAL|ALERT|CONFIRM)+(\()+(\'|\")+.*?(\'|\")+(\))+\;?/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(EVAL|ALERT|CONFIRM)+(\()+(\'|\")+.*?(\'|\")+(\))+\;?/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/(EVAL|ALERT|CONFIRM)+(\()+(\'|\")+.*?(\'|\")+(\))+\;?/igm],
            MatchArray:[]
          },

          Description: 'XSS attack by eval or local function call.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/<!--#(?:CONFIG|ECHO|EXEC|FLASTMOD|FSIZE|INCLUDE)\b.+?-->/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/<!--#(?:CONFIG|ECHO|EXEC|FLASTMOD|FSIZE|INCLUDE)\b.+?-->/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/<!--#(?:CONFIG|ECHO|EXEC|FLASTMOD|FSIZE|INCLUDE)\b.+?-->/igm],
            MatchArray:[]
          },

          Description: 'SSI Command injection attack.'
        }
      ]
    },
    { //Anti mail injection and remote code execution (RCE) rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\x0A\b((Reply-)?To|B?Cc|Content-(Td|Type)\w?)\b\s*:.*?\@.+/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\x0A\b((Reply-)?To|B?Cc|Content-(Td|Type)\w?)\b\s*:.*?\@.+/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\x0A\b((Reply-)?To|B?Cc|Content-(Td|Type)\w?)\b\s*:.*?\@.+/igm],
            MatchArray:[]
          },

          Description: 'Mail header injection attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(?:<\?[\s\S]+)|#!\/(?:USR|BIN)\/.+?\s/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(?:<\?[\s\S]+)|#!\/(?:USR|BIN)\/.+?\s/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/(?:<\?[\s\S]+)|#!\/(?:USR|BIN)\/.+?\s/igm],
            MatchArray:[]
          },

          Description: 'Remote shellcode execution attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_COOKIES,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\b(?:eval)\s*\(\s*(?:base64_decode|exec|file_get_contents|gzinflate|passthru|shell_exec|stripslashes|system)\s*\((\)?\)?);?/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\b(?:eval)\s*\(\s*(?:base64_decode|exec|file_get_contents|gzinflate|passthru|shell_exec|stripslashes|system)\s*\((\)?\)?);?/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\b(?:eval)\s*\(\s*(?:base64_decode|exec|file_get_contents|gzinflate|passthru|shell_exec|stripslashes|system)\s*\((\)?\)?);?/igm],
            MatchArray:[]
          },

          Cookies:{
            NameArray:[],
            RegexArray:[/\b(?:eval)\s*\(\s*(?:base64_decode|exec|file_get_contents|gzinflate|passthru|shell_exec|stripslashes|system)\s*\((\)?\)?);?/igm],
            MatchArray:[]
          },

          Description: 'Remote code execution using PHP payload.'
        }
      ]
    },
    { //Anti XSS rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_HEADERS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\<\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)[^\>]*\>(.*?)\<\s*\/\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)\>/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\<\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)[^\>]*\>(.*?)\<\s*\/\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)\>/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\<\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)[^\>]*\>(.*?)\<\s*\/\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)\>/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\<\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)[^\>]*\>(.*?)\<\s*\/\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)\>/igm],
            MatchArray:[]
          },

          Description: 'XSS attack using HTML common tags.'
        }
      ]
    },
    { //PHP Vuln. CVE-2012-1823 and Unrestricted File Upload rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_HEADERS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Payloads:{
            RegexArray:[/^-[bcndfiswzT].{20}/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^-[bcndfiswzT].{20}/igm],
            MatchArray:[]
          },

          Description: 'PHP Vulnerability CVE-2012-1823.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_FILE_EXT,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          FileExtensions:{
            ExtensionsArray:[/\x70\x68(\x70(3|4|5|S|)|\x74\x6d\x6c)/igm],
            RegexArray:[],
            MatchArray:[]
          },

          Description: 'PHP Unrestricted File Upload attack.'
        }
      ]
    },
    { //Anti ASP(X) Unrestricted File Upload rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_FILE_EXT,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          FileExtensions:{
            ExtensionsArray:[/asp(x)?(::)?\$?(Index_Allocation|Data)?/igm],
            RegexArray:[],
            MatchArray:[]
          },

          Description: 'ASP(X) Unrestricted File Upload attack.'
        }
      ]
    },
    { //Anti SQL Injection rule
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^.{0,100}\sSLEEP\s\d+/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^.{0,100}\sSLEEP\s\d+/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^.{0,100}\sSLEEP\s\d+/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection Time-Based.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^'/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^'/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^'/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection using unescaped single-quote.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bAND\s+EXTRACTVALUE\s\w/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bAND\s+EXTRACTVALUE\s\w/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bAND\s+EXTRACTVALUE\s\w/igm],
            MatchArray:[]
          },

          Description: 'Blind SQL Injection'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\'\s){0,1}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\'\s){0,1}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(\'\s){0,1}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/igm],
            MatchArray:[]
          },

          Description: 'Tautology assertion SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(?:\b|\d)INSERT\b.+?(?:\b|\d)INTO\b.{1,150}(?:\b|\d)VALUES\b.*?\(.+?\)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(?:\b|\d)INSERT\b.+?(?:\b|\d)INTO\b.{1,150}(?:\b|\d)VALUES\b.*?\(.+?\)/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/(?:\b|\d)INSERT\b.+?(?:\b|\d)INTO\b.{1,150}(?:\b|\d)VALUES\b.*?\(.+?\)/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection by Insert method.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(?:ADMIN(?:ISTRATOR)?)['\"].*?(?:--|#|\/\\*)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(?:ADMIN(?:ISTRATOR)?)['\"].*?(?:--|#|\/\\*)/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(?:ADMIN(?:ISTRATOR)?)['\"].*?(?:--|#|\/\\*)/igm],
            MatchArray:[]
          },

          Description: 'Admin comment based SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bUNION\s+SELECT\b.{1,128}(FROM|WHERE)\b/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bUNION\s+SELECT\b.{1,128}(FROM|WHERE)\b/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bUNION\s+SELECT\b.{1,128}(FROM|WHERE)\b/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection by UNION method.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(?:\b|\d)+\s(?:CEIL|CONCAT|CONV|FLOOR|VERSION)\b/ig],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(?:\b|\d)+\s(?:CEIL|CONCAT|CONV|FLOOR|VERSION)\b/ig],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(?:\b|\d)+\s(?:CEIL|CONCAT|CONV|FLOOR|VERSION)\b/ig],
            MatchArray:[]
          },

          Description: 'SQL Injection by common functions. #1'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(?:\b(?:null|and|or)\b|\|\||&&)\s*.{0,50}\bselect\b./im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(?:\b(?:null|and|or)\b|\|\||&&)\s*.{0,50}\bselect\b./im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/(?:\b(?:null|and|or)\b|\|\||&&)\s*.{0,50}\bselect\b./im],
            MatchArray:[]
          },

          Description: 'Suspicious NULL assertion injection in SQL Injection attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(?:\b(?:null|and|or)\b|\|\||&&)?\s*union\s+(?:all\s+)?select\b/i],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(?:\b(?:null|and|or)\b|\|\||&&)?\s*union\s+(?:all\s+)?select\b/i],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(?:\b(?:null|and|or)\b|\|\||&&)?\s*union\s+(?:all\s+)?select\b/i],
            MatchArray:[]
          },

          Description: 'Suspicious NULL assertion based SQL injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?\d+.{0,32}(?:\bAND\b.{0,64})?\b(?:UNION|SELECT)\b/im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?\d+.{0,32}(?:\bAND\b.{0,64})?\b(?:UNION|SELECT)\b/im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^-?\d+.{0,32}(?:\bAND\b.{0,64})?\b(?:UNION|SELECT)\b/im],
            MatchArray:[]
          },

          Description: 'Negative number based SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/.{2,}\bORDER\sBY\s*(\d*|\w*)?/im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/.{2,}\bORDER\sBY\s*(\d*|\w*)?/im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/.{2,}\bORDER\sBY\s*(\d*|\w*)?/im],
            MatchArray:[]
          },

          Description: 'Order by column based SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/.{2,}\b(UNION|INTERSECT|EXCEPT)\s*SELECT\s*(NULL[,\s]*)+(?:--)/im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/.{2,}\b(UNION|INTERSECT|EXCEPT)\s*SELECT\s*(NULL[,\s]*)+(?:--)/im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/.{2,}\b(UNION|INTERSECT|EXCEPT)\s*SELECT\s*(NULL[,\s]*)+(?:--)/im],
            MatchArray:[]
          },

          Description: 'Union, intersect or except based method to SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\'|\s){0,}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\'|\s){0,}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(\'|\s){0,}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/im],
            MatchArray:[]
          },

          Description: 'Improved tautology assertion based SQL Injection.'
        }
      ]
    },
    { //Anti Null byte rule
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\x00/gm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\x00/gm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\x00/gm],
            MatchArray:[]
          },

          Description: 'ASCII character 0x00 (NULL BYTE) injection attack.'
        }
      ]
    },
    { //Anti XSS rule
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\bFunction\s*[({](.|\s)*?[})]\s*\(.*?\)|\bfunction\s*\(.*?\)\s*{(.|\s)*?}|(?:\[|new)\s*class\s*extends\b|\bArray\s*.*\s*from\b/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\bFunction\s*[({](.|\s)*?[})]\s*\(.*?\)|\bfunction\s*\(.*?\)\s*{(.|\s)*?}|(?:\[|new)\s*class\s*extends\b|\bArray\s*.*\s*from\b/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\bFunction\s*[({](.|\s)*?[})]\s*\(.*?\)|\bfunction\s*\(.*?\)\s*{(.|\s)*?}|(?:\[|new)\s*class\s*extends\b|\bArray\s*.*\s*from\b/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\bFunction\s*[({](.|\s)*?[})]\s*\(.*?\)|\bfunction\s*\(.*?\)\s*{(.|\s)*?}|(?:\[|new)\s*class\s*extends\b|\bArray\s*.*\s*from\b/igm],
            MatchArray:[]
          },

          Description: 'XSS attack by function, class or array injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\b(?:document|window|this)\s*\[.+?\]\s*[\[(]/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\b(?:document|window|this)\s*\[.+?\]\s*[\[(]/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\b(?:document|window|this)\s*\[.+?\]\s*[\[(]/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\b(?:document|window|this)\s*\[.+?\]\s*[\[(]/igm],
            MatchArray:[]
          },

          Description: 'XSS DOM based injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/<.+?\bon[a-z]{3,19}\b\s*=.+?>/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/<.+?\bon[a-z]{3,19}\b\s*=.+?>/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/<.+?\bon[a-z]{3,19}\b\s*=.+?>/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/<.+?\bon[a-z]{3,19}\b\s*=.+?>/igm],
            MatchArray:[]
          },

          Description: 'XSS DOM based by HTML event attributes.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\bdocument\s*\.\s*(?:body|cookie|location|open|write(?:ln)?)\s*(\(|\[|\=\s*(\"|\')+)+.*(\)|\]|(\"|\')+)+/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\bdocument\s*\.\s*(?:body|cookie|location|open|write(?:ln)?)\s*(\(|\[|\=\s*(\"|\')+)+.*(\)|\]|(\"|\')+)+/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\bdocument\s*\.\s*(?:body|cookie|location|open|write(?:ln)?)\s*(\(|\[|\=\s*(\"|\')+)+.*(\)|\]|(\"|\')+)+/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\bdocument\s*\.\s*(?:body|cookie|location|open|write(?:ln)?)\s*(\(|\[|\=\s*(\"|\')+)+.*(\)|\]|(\"|\')+)+/igm],
            MatchArray:[]
          },

          Description: 'XSS DOM based injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/<.+?\b(?:href|(?:form)?action|background|code|data|location|name|poster|src|value)\s*=\s*['\"]?(?:(?:f|ht)tps?:)?\/\/\w+\.\w*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/<.+?\b(?:href|(?:form)?action|background|code|data|location|name|poster|src|value)\s*=\s*['\"]?(?:(?:f|ht)tps?:)?\/\/\w+\.\w*/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/<.+?\b(?:href|(?:form)?action|background|code|data|location|name|poster|src|value)\s*=\s*['\"]?(?:(?:f|ht)tps?:)?\/\/\w+\.\w*/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/<.+?\b(?:href|(?:form)?action|background|code|data|location|name|poster|src|value)\s*=\s*['\"]?(?:(?:f|ht)tps?:)?\/\/\w+\.\w*/igm],
            MatchArray:[]
          },

          Description: 'XSS DOM poisoning based by common attributes.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\W(?:background(-image)?|-moz-binding)\s*:[^}]*?\burl\s*\([^)]+?(https?:)?\/\/\w/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\W(?:background(-image)?|-moz-binding)\s*:[^}]*?\burl\s*\([^)]+?(https?:)?\/\/\w/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\W(?:background(-image)?|-moz-binding)\s*:[^}]*?\burl\s*\([^)]+?(https?:)?\/\/\w/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\W(?:background(-image)?|-moz-binding)\s*:[^}]*?\burl\s*\([^)]+?(https?:)?\/\/\w/igm],
            MatchArray:[]
          },

          Description: 'XSS possible deface attack by embedded (S)CSS attributes.'
        },
      ]
    },
    { //Anti SQL injection rule.
      Dacls: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_USER_AGENT,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,
          UserAgents:{
            RegexArray:[/^(\uff07|\d\s*\uff07)/gm],
            MatchArray:[]
          },
          Description: 'SQL Injection single quote UTF-16 beginning string.'
        }
      ],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\uff07|\d\s*\uff07)/gm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\uff07|\d\s*\uff07)/gm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\uff07|\d\s*\uff07)/gm],
            MatchArray:[]
          },

          Description: 'SQL Injection single quote UTF-16 beginning string.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(OR|AND)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(OR|AND)/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(OR|AND)/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection boolean blind based #1.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection "UNION" or "ORDER BY" based #1.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(ORDER\s*BY|UNION\s*ALL)\s*(SELECT|ORDER\s*BY)*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(ORDER\s*BY|UNION\s*ALL)\s*(SELECT|ORDER\s*BY)*/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(ORDER\s*BY|UNION\s*ALL)\s*(SELECT|ORDER\s*BY)*/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection "UNION" or "ORDER BY" based #2.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(OR|AND)\s*((SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))|(\'|\uff07)\w+(\'|\uff07)(\=|\!\=)+(\'|\uff07)\w+(\'|\uff07)|-?\d+\s*\=\s*(\(|SELECT|\w+)|\s*\w*\s*IN\s*\()/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(OR|AND)\s*((SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))|(\'|\uff07)\w+(\'|\uff07)(\=|\!\=)+(\'|\uff07)\w+(\'|\uff07)|-?\d+\s*\=\s*(\(|SELECT|\w+)|\s*\w*\s*IN\s*\()/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(OR|AND)\s*((SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))|(\'|\uff07)\w+(\'|\uff07)(\=|\!\=)+(\'|\uff07)\w+(\'|\uff07)|-?\d+\s*\=\s*(\(|SELECT|\w+)|\s*\w*\s*IN\s*\()/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection boolean blind based #2.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*(RLIKE|WAITFOR)\s*\w*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*(RLIKE|WAITFOR)\s*\w*/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*(RLIKE|WAITFOR)\s*\w*/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection using "RLIKE" or "WAITFOR" command.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*;(SELECT|WAITFOR|DECLARE)\s*\w*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*;(SELECT|WAITFOR|DECLARE)\s*\w*/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*;(SELECT|WAITFOR|DECLARE)\s*\w*/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection using "SELECT", "WAITFOR" or "DECLARE" command.'
        }
      ]
    },
    { //Anti Advanced SQL Injection rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection using "ORDER BY" or "UNION" operators.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d+|\w+)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*\b(AND|OR)\s*(SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d+|\w+)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*\b(AND|OR)\s*(SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^-?(\d+|\w+)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*\b(AND|OR)\s*(SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection boolean blind based.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3};\s*(SELECT|DECLARE|WAITFOR|CREATE|\()\s*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3};\s*(SELECT|DECLARE|WAITFOR|CREATE|\()\s*/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3};\s*(SELECT|DECLARE|WAITFOR|CREATE|\()\s*/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection using "SELECT", "DECLARE", "WAITFOR" or "CREATE" methods.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?\w*(\'|\"|\uff07)*\s*[\(\)]{1,3}\s*(AND|SELECT|WHERE|AS|;)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?\w*(\'|\"|\uff07)*\s*[\(\)]{1,3}\s*(AND|SELECT|WHERE|AS|;)/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^-?\w*(\'|\"|\uff07)*\s*[\(\)]{1,3}\s*(AND|SELECT|WHERE|AS|;)/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection using very dangerous SQLMAP Payloads LEVEL 4.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^\w+\`\=\`.+\`\s*(AND|OR|\w+|\;)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^\w+\`\=\`.+\`\s*(AND|OR|\w+|\;)/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^\w+\`\=\`.+\`\s*(AND|OR|\w+|\;)/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection boolean blind based #3.'
        }
      ]
    },
    { //Anti payload obfuscation and PHP Remote Code Execution (RCE) rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(%u(\w{2}|\w{4})){16}/gm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(%u(\w{2}|\w{4})){16}/gm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(%u(\w{2}|\w{4})){16}/gm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(%u(\w{2}|\w{4})){16}/gm],
            MatchArray:[]
          },

          Description: 'Possible UTF-8/16 encoded and obfuscated payload injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\b(XDEBUG_SESSION_START|invokefunction|call_user_func_array)\b/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\b(XDEBUG_SESSION_START|invokefunction|call_user_func_array)\b/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\b(XDEBUG_SESSION_START|invokefunction|call_user_func_array)\b/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\b(XDEBUG_SESSION_START|invokefunction|call_user_func_array)\b/igm],
            MatchArray:[]
          },

          Description: 'Remote code execution (RCE) attack attempt.'
        }
      ]
    },
    { 
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Headers:{
            NameArray:[],
            RegexArray:[/^application\/json/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/(?:(?:{|%7B|%u007B|\[|%5B|%u005B)(?:.|\s)*(?:"|%22|%u0022)(?:__proto__|toString|toLocaleString|isPrototypeOf|hasOwnProperty|propertyIsEnumerable|valueOf|__defineGetter__|__defineSetter__|__lookupGetter__|constructor)(?:"|%22|%u0022)(?:.|\s)*(?:}|%7D|%u007D|\]|%5D|%u005D))/igm],
            MatchArray:[]
          },

          Description: 'Possible Prototype Pollution and Remote Code Execution #1.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_COOKIES | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Cookies:{
            NameArray:[],
            RegexArray:[/(?:(?:{|%7B|%u007B|\[|%5B|%u005B)(?:.|\s)*(?:"|%22|%u0022)(?:__proto__|toString|toLocaleString|isPrototypeOf|hasOwnProperty|propertyIsEnumerable|valueOf|__defineGetter__|__defineSetter__|__lookupGetter__|constructor)(?:"|%22|%u0022)(?:.|\s)*(?:}|%7D|%u007D|\]|%5D|%u005D))/igm],
            MatchArray:[]
          },

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(?:(?:{|%7B|%u007B|\[|%5B|%u005B)(?:.|\s)*(?:"|%22|%u0022)(?:__proto__|toString|toLocaleString|isPrototypeOf|hasOwnProperty|propertyIsEnumerable|valueOf|__defineGetter__|__defineSetter__|__lookupGetter__|constructor)(?:"|%22|%u0022)(?:.|\s)*(?:}|%7D|%u007D|\]|%5D|%u005D))/igm],
            MatchArray:[]
          },

          Description: 'Possible Prototype Pollution and Remote Code Execution #2.'
        }
      ]
    },
    { // DoS rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_ATTEMPTS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Attempts: {
            MaxAttempts: 1024,
            RenewAttemptsInterval: 600
          },

          Description: 'Possible Denial of Service attack.'
        }
      ]
    }
  ],
  Callbacks: [],
  AccessTable: []
}

module.exports = {

  DefaultSettings: DefaultSettings

}
	</script>
	<script>
		const Ip = require('ip');
const fs = require('fs');
const path = require('path');
const os = require('os');
const colors = require('colors');

const PROTOCOL_IPV4 = 0x01;
const	PROTOCOL_IPV6 = 0x02;

function CheckFlags(value, flag){
  return ((value & flag) === flag);
}

function CookieParse(str, options) {
  if (typeof str !== 'string') {
    return {};
  }

  var obj = {}
  var opt = options || {};
  var pairs = str.split(/; */);
  var dec = opt.decode || decodeURIComponent;

  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var eq_idx = pair.indexOf('=');

    if (eq_idx < 0) {
      continue;
    }

    var key = pair.substr(0, eq_idx).trim()
    var val = pair.substr(++eq_idx, pair.length).trim();

    if ('"' == val[0]) {
      val = val.slice(1, -1);
    }

    if (undefined == obj[key]) {
      obj[key] = (function (str, decode) {
        try {
          return decodeURIComponent(str);
        } catch (e) {
          return str;
        }
      })(val, dec);
    }
  }

  return obj;
}

function EnumAvailableFiles(req, enumProc) {
  if (req.files) {
    let breakEnum = false;
    for (let fieldname in req.files) {
      if (!breakEnum) {
        if (req.files[fieldname].length) {
          for (let idx = 0; idx < req.files[fieldname].length; idx++) {
            let finfo = req.files[fieldname][idx];
            let fname = finfo.name || finfo.filename || finfo.originalname;
            enumProc(finfo, fname, () => {
              breakEnum = true;
              idx = req.files[fieldname].length;
            });
          }
        }
        else {
          let finfo = req.files[fieldname];
          let fname = finfo.name || finfo.filename || finfo.originalname;
          enumProc(finfo, fname, () => {
            breakEnum = true;
          });
        }
      }
      else {
        break;
      }
    }
  }
}

function AddEntryInAccessTable(ptrWafObj, ptrFlt, targIp, networkLayer) {
  let uptimestamp = new Date().getTime();
  let downtimestamp = (uptimestamp - (ptrFlt.Attempts.RenewAttemptsInterval * 0x3e8));
  let accessList = [];
  let tableResult = {};
  let oldAccess = [];
  let inc_len = 0;
  let exceeded = true;
  switch (networkLayer) {
    case PROTOCOL_IPV4:
      accessList = ptrWafObj.AccessTable.filter(function (ptrAccessEntry, idx, ptrAccessTable) {
        if (((ptrAccessEntry.Timestamp < downtimestamp) || (ptrAccessEntry.Timestamp > uptimestamp)) && Ip.isEqual(ptrAccessEntry.Ipv4Address, targIp)) {
          oldAccess.push(ptrAccessTable[idx]);
        }
        return (((ptrAccessEntry.Timestamp >= downtimestamp) && (ptrAccessEntry.Timestamp <= uptimestamp)) && Ip.isEqual(ptrAccessEntry.Ipv4Address, targIp));
      });
      for (let r_idx = 0; r_idx < oldAccess.length; r_idx++) {
        ptrWafObj.AccessTable.splice(ptrWafObj.AccessTable.indexOf(oldAccess[r_idx]), 1);
      }
      if (accessList.length < ptrFlt.Attempts.MaxAttempts) {
        ptrWafObj.AccessTable.push({ Ipv4Address: targIp, Ipv6Address: '', Timestamp: new Date().getTime() });
        exceeded = false;
        inc_len++;
      }
      tableResult = {
        RemainingAttempts: (accessList.length > ptrFlt.Attempts.MaxAttempts ? 0 : (ptrFlt.Attempts.MaxAttempts - (accessList.length + inc_len))),
        CurrentAttempts: accessList.length + inc_len,
        Exceeded: exceeded
      };
      accessList = null;
      return tableResult;
    case PROTOCOL_IPV6:
      accessList = ptrWafObj.AccessTable.filter(function (ptrAccessEntry, idx, ptrAccessTable) {
        if ((ptrAccessEntry.Timestamp < downtimestamp) || (ptrAccessEntry.Timestamp > uptimestamp) && Ip.isEqual(ptrAccessEntry.Ipv6Address, targIp)) {
          oldAccess.push(ptrAccessTable[idx]);
        }
        return (((ptrAccessEntry.Timestamp >= downtimestamp) && (ptrAccessEntry.Timestamp <= uptimestamp)) && Ip.isEqual(ptrAccessEntry.Ipv6Address, targIp));
      });
      for (let r_idx = 0; r_idx < oldAccess.length; r_idx++) {
        ptrWafObj.AccessTable.splice(ptrWafObj.AccessTable.indexOf(oldAccess[r_idx]), 1);
      }
      if (accessList.length < ptrFlt.Attempts.MaxAttempts) {
        ptrWafObj.AccessTable.push({ Ipv4Address: '', Ipv6Address: targIp, Timestamp: new Date().getTime() });
        exceeded = false;
        inc_len++;
      }
      tableResult = {
        RemainingAttempts: (accessList.length > ptrFlt.Attempts.MaxAttempts ? 0 : (ptrFlt.Attempts.MaxAttempts - (accessList.length + inc_len))),
        CurrentAttempts: accessList.length + inc_len,
        Exceeded: exceeded
      };
      accessList = null;
      return tableResult;
    default:
      return false;
  }
}

function DisplayBlockedEvent(event){
  console.log(
    `-> Mini-WAF has protected your server now!`.white.bgRed + os.EOL +
    `   Blocked triggered event by remote IP address: ${event.request.ip} at ${new Date().toLocaleString()}!`.red + os.EOL +
    `   Reason of blocking action: ${event.reason.green}`.yellow + os.EOL +
    `   Method type: ${event.request.method.red}`.yellow + os.EOL +
    `   Port number: ${String(event.request.connection.localPort).red}`.yellow + os.EOL +
    `   Traffic direction: ${String((CheckFlags(event.wafComp.Directions, 0x01) && CheckFlags(event.wafComp.Directions, 0x02) ? 'Inbound | Outbound' : (CheckFlags(event.wafComp.Directions, 0x01) ? 'Inbound' : (CheckFlags(event.wafComp.Directions, 0x02) ? 'Outbound' : 'None')))).red}`.yellow + os.EOL +
    `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16)).red}\n`.green
  );
}

function DisplayAuditEvent(event){
  console.log(
    `-> Mini-WAF has detected an event now!`.black.bgWhite + os.EOL +
    `   Triggered event by remote IP address: ${event.request.ip} at ${new Date().toLocaleString()}!`.yellow + os.EOL +
    `   Reason of audit action: ${event.reason.green}`.yellow + os.EOL +
    `   Method type: ${event.request.method.green}`.yellow + os.EOL +
    `   Port number: ${String(event.request.connection.localPort).green}`.yellow + os.EOL +
    `   Traffic direction: ${String((CheckFlags(event.wafComp.Directions, 0x01) && CheckFlags(event.wafComp.Directions, 0x02) ? 'Inbound | Outbound' : (CheckFlags(event.wafComp.Directions, 0x01) ? 'Inbound' : (CheckFlags(event.wafComp.Directions, 0x02) ? 'Outbound' : 'None')))).red}`.yellow + os.EOL +
    `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16)).yellow}\n`.green
  );
}

function DisplayUnhandledExceptionEvent(event){
  console.log(
    `-> Mini-WAF has protected your server now!`.white.bgRed + os.EOL +
    `   Unhandled exception triggered at ${new Date().toLocaleString()}!`.red + os.EOL +
    `   Exception name: ${event.name.green}`.yellow + os.EOL +
    `   Exception message: ${event.message.red}`.yellow + os.EOL +
    `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16)).red}\n`.green
  );
}

function DisplayNewConnection(req){
  console.log(`[${(new Date()).toLocaleTimeString().cyan}] [${req.protocol.toUpperCase().cyan} ${req.method.cyan}] [${'INFO'.green}] new incoming connection detected from [${String(req.ip).yellow}] with User Agent [${req.headers["user-agent"]}].`);
}

function WriteEventToLog(event, logType, fname) {
  let WriteCallback = () => {
    const wfstream = fs.createWriteStream(path.join(__dirname, 'logs', fname), { flags: 'a' });
    if (logType.toUpperCase() == 'BLOCK') {
      wfstream.write(
        `-> Mini-WAF has protected your server now!${os.EOL}` +
        `   Blocked triggered event by remote IP address: ${event.request.ip} at ${new Date().toLocaleString()}!${os.EOL}` +
        `   Reason of blocking action: ${event.reason}${os.EOL}` +
        `   Method type: ${event.request.method}${os.EOL}` +
        `   Port number: ${String(event.request.connection.localPort)}${os.EOL}` +
        `   Traffic direction: ${String((CheckFlags(event.wafComp.Directions, 0x01) && CheckFlags(event.wafComp.Directions, 0x02) ? 'Inbound | Outbound' : (CheckFlags(event.wafComp.Directions, 0x01) ? 'Inbound' : (CheckFlags(event.wafComp.Directions, 0x02) ? 'Outbound' : 'None'))))}${os.EOL}` +
        `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16))}${os.EOL}${os.EOL}`
      );
    }
    else if (logType.toUpperCase() == 'AUDIT') {
      wfstream.write(
        `-> Mini-WAF has detected an event now!${os.EOL}` +
        ` Triggered event by remote IP address: ${event.request.ip} at ${new Date().toLocaleString()}!${os.EOL}` +
        ` Reason of audit action: ${event.reason}${os.EOL}` +
        ` Method type: ${event.request.method}${os.EOL}` +
        ` Port number: ${String(event.request.connection.localPort)}${os.EOL}` +
        ` Traffic direction: ${String((CheckFlags(event.wafComp.Directions, 0x01) && CheckFlags(event.wafComp.Directions, 0x02) ? 'Inbound | Outbound' : (CheckFlags(event.wafComp.Directions, 0x01) ? 'Inbound' : (CheckFlags(event.wafComp.Directions, 0x02) ? 'Outbound' : 'None'))))}${os.EOL}` +
        ` Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16))}${os.EOL}${os.EOL}`
      );
    }
    else if (logType.toUpperCase() == 'EXCEPTION') {
      wfstream.write(
        `-> Mini-WAF has protected your server now!${os.EOL}` +
        `   Unhandled exception triggered at ${new Date().toLocaleString()}!${os.EOL}` +
        `   Exception name: ${event.name}${os.EOL}` +
        `   Exception message: ${event.message}${os.EOL}` +
        `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16))}${os.EOL}${os.EOL}`
      );
    }
    wfstream.end();
  }

  let CheckAndWrite = () => {
    fs.access(path.join(__dirname, 'logs'), fs.constants.F_OK, (_err) => {
      if (_err){
        fs.writeFile(path.join(__dirname, 'logs', fname), `#========================================= Mini-WAF Log File =========================================#${os.EOL}`, { flags: 'a' }, WriteCallback);
      }
      WriteCallback();
    });
  }
  fs.access(path.join(__dirname, 'logs'), fs.constants.F_OK, (err) => {
    if (!err){
      if (fs.lstatSync(path.join(__dirname, 'logs')).isFile()) {
        console.log('MINI-WAF ENCOUNTERED AN ERROR!'.bgRed.white);
        return;
      }
      CheckAndWrite();
    }
    else{
      try{
        fs.mkdirSync(path.join(__dirname, 'logs'));
      } catch(e){
        console.log('MINI-WAF ENCOUNTERED AN ERROR!'.bgRed.white + os.EOL + 'The log directory cant be created as \'' + path.join(__dirname, 'logs') + '\'');
        return;
      }
      CheckAndWrite();
    }
  });
}

function ApplyArgument(oldArgs, newArg){
  let bFirst = true;
  let newArgs = [];
  for (let idx = 0; idx <= oldArgs.length; idx++){
    if (!bFirst){
      newArgs.push(oldArgs[String(idx-1)]);
    }
    else{
      bFirst = false;
      newArgs.push(newArg);
    }
  }
  return newArgs;
}

function Hook(targName, ptrStub, ptrParent){
  let PatchAddr = ptrParent[targName];
	let ptrHookObj = {
		TargetName: targName,
		Stub: ptrStub,
    Parent: ptrParent,
    PatchAddr: ptrParent[targName],
    OriginalFunction: function(){
      try {
        ptrParent[targName] = PatchAddr;
        let result = ptrParent[targName].apply(ptrParent, arguments);
        ptrParent[targName] = ptrStub;
        return result;
      } catch (e){ return; }
    },
    Unhook: function(){ ptrParent[targName] = PatchAddr; },
    Hook: function(){ ptrParent[targName] = ptrStub; }
  }
  Object.defineProperty(ptrStub, 'name', {name: targName});
  Object.defineProperty(ptrParent[targName], 'name', {name: targName});
	ptrParent[targName] = ptrStub;
	return ptrHookObj;
}



module.exports = {

  CheckFlags: CheckFlags,
  CookieParse: CookieParse,
  EnumAvailableFiles: EnumAvailableFiles,
  AddEntryInAccessTable: AddEntryInAccessTable,
  DisplayBlockedEvent: DisplayBlockedEvent,
  DisplayAuditEvent: DisplayAuditEvent,
  DisplayUnhandledExceptionEvent: DisplayUnhandledExceptionEvent,
  DisplayNewConnection: DisplayNewConnection,
  WriteEventToLog: WriteEventToLog,
  ApplyArgument: ApplyArgument,
  Hook: Hook

}
	</script>
	<script>
		let proxy = require("express-http-proxy");
let app = require("express")();
let sanitizeHTML = require("sanitize-html");
let colors = require("colors");
colors.setTheme({
  silly: "rainbow",
  info: "green",
  data: "grey",
  warn: "yellow",
  error: "red",
});

const options = {
  allowedTags: [],
};

let headers = ["Content-Type", "user-agent"];

let sanitizeRequestURL = function (req) {
  let prevURL = req.url;
  let decodeURL = decodeURI(req.url);
  decodeURL = sanitize(decodeURL);
  let newURL = encodeURI(decodeURL);
  if (newURL !== prevURL) {
    console.log("Alert! Reflected XSS Detected".error + " Content: " + prevURL);
  }
  return newURL;
};

let filterRequests = function () {
  return true;
};

function sanitize(content) {
  return sanitizeHTML(content, options);
}

var getURLParams = function (search) {
  var params = [];
  var rawParams = search.substring(0).split("&");
  var param, index, name, value;

  for (var i = 0, len = rawParams.length; i < len; i++) {
    param = rawParams[i];
    index = param.indexOf("=");

    switch (true) {
      // Name and value are defined.
      // For example: ?a=1&b=2.
      case index > 0:
        name = param.substring(0, index);
        value = param.substring(index + 1);
        break;

      // Value is undefined.
      // For example: ?a&b.
      case index === -1:
        name = param;
        value = "";
        break;

      // Name  is undefined.
      // For example: ?=11111111&=2
      case index === 0:
        name = "";
        value = param.substring(index + 1);
        break;

      default:
        break;
    }

    params.push({
      name: name,
      value: value,
      denied: false,
    });
  }

  return params;
};

let sanitizeURLParams = function (content) {
  let prevContent = content;
  content = decodeURI(content);
  let sanitizeString = "";

  let arrFromParams = getURLParams(content);

  for (let i = 0; i < arrFromParams.length; i++) {
    sanitizeString +=
      arrFromParams[i].name + "=" + sanitize(arrFromParams[i].value) + "&";
  }
  content = sanitizeString;
  content = content.substring(0, content.length - 1);
  let newContent = encodeURI(content);
  if (newContent !== prevContent) {
    console.log(
      "Alert! Persistent XSS Detected".error + " Content:" + prevContent
    );
  }

  return newContent;
};

let sanitizeURLParamsJSON = function (content) {
  let prevContent = content;
  content = JSON.parse(content);
  let keys = Object.keys(content);

  for (let i = 0; i < keys.length; i++) {
    content[keys[i]] = sanitize(content[keys[i]]);
  }
  let newContent = JSON.stringify(content);
  if (prevContent !== newContent) {
    console.log(
      "Alert! Persistent XSS Detected".error + " Content: " + prevContent
    );
  }
  return newContent;
};

let reqBodyDecorator = function (bodyContent, srcReq) {
  let method = srcReq["method"];
  let content;
  if (method === "GET") {
    return bodyContent;
  } else {
    for (let i = 0; i < headers.length; i++) {}

    if (
      srcReq.header("Content-Type") ===
      "application/x-www-form-urlencoded; charset=UTF-8"
    ) {
      content = bodyContent.toString();
      content = sanitizeURLParams(content);
    } else if (
      srcReq.header("Content-Type") === "application/json; charset=UTF-8"
    ) {
      content = bodyContent.toString();
      content = sanitizeURLParamsJSON(content);
    } else {
      return bodyContent;
    }
    return Buffer.from(content, "utf-8");
  }
};
reqOptionsDecorator = function (proxyReqOpts) {
  return proxyReqOpts;
};

let resDecorator = function (proxyRes, proxyResData) {
  return proxyResData;
};

let resHeadDecorator = function (headers) {
  headers["X-XSS-Protection"] = "1";
  return headers;
};

app.use(
  "/",
  proxy("http://server:3000", {
    proxyReqPathResolver: sanitizeRequestURL,
    filter: filterRequests,
    // default
    userResDecorator: resDecorator,
    userResHeaderDecorator: resHeadDecorator,
    proxyReqBodyDecorator: reqBodyDecorator,
    proxyReqOptDecorator: reqOptionsDecorator,
    parseReqBody: true,
    memoizeHost: false,
    preserveHostHdr: true,
    reqAsBuffer: true,
  })
);

const port = 3001;

app.listen(port, () =>
  console.log(`Reverse-proxy-waf listening at http://localhost:${port}`)
);
	</script>
	<script>
		'use strict'

class WAFJS{

  constructor(config){

    // loading signatures file
    const { signatures } = require ('./signatures.json')

    // declaring holders for config related data
    this.allowedMethods = config.allowedMethods
    this.allowedContentTypes = config.contentTypes
    this.botSigs = signatures

    // declaring base regex expression to check bot signatures
    this.isBotCheckRegex = () => new RegExp(`(${this.botSigs.join('|')})`, 'i')
  }


  
  isBotCheck(userAgent){
    return this.isBotCheckRegex().test(userAgent)
  }

  extendBotSigs(signatures){
    this.botSigs = [...new Set(this.botSigs.concat(signatures))]
  }

  removeBotSig(signature){
    this.botSigs = this.botSigs.filter(sig => sig !== signature)
  }


  
  reqCheck(requestMethod, contentType){
   return !(this.allowedMethods.indexOf(requestMethod) < 0 || this.allowedContentTypes.indexOf(contentType) < 0)
  }

	</script>

	
		<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js"></script>
<body>
<canvas id="myChart" style="width:100%;max-width:600px"></canvas>
	

<script>
var xValues = [100,200,300,400,500,600,700,800,900,1000];

new Chart("myChart", {
  type: "line",
  data: {
    labels: xValues,
    datasets: [{ 
      data: [860,1140,1060,1060,1070,1110,1330,2210,7830,2478],
      borderColor: "red",
      fill: false
    }, { 
      data: [1600,1700,1700,1900,2000,2700,4000,5000,6000,7000],
      borderColor: "green",
      fill: false
    }, { 
      data: [300,700,2000,5000,6000,4000,2000,1000,200,100],
      borderColor: "blue",
      fill: false
    }]
  },
  options: {
    legend: {display: false}
  }
});
</script>
	
	
<meta name="description" content="" />
<style>
body {background-color: powderblue;}
h1   {color: blue;}
p    {color: red;}
</style>
	<script type="text/javascript" src="ssssos.js"></script>
	<script type="text/javascript" src="functions.js"> </script>

</head>
<body bgcolor="black" text="lime" link="lime" alink="lime" vlink="lime">
<p class="console">
	<span># </span><span id="caption"></span><span id="cursor">|</span>
<noscript>
HACKER<br><br>UK.<br><br>Gmail: <a href="mail:haomhoa@gmail.com">haomhoa@gmail.com</a<br><br><br>#
</noscript>
</p>
<script type="text/javascript" id="hs-script-loader" async defer src="//js-na1.hs-scripts.com/21193109.js"></script>

	<script src"https://1smailtk.xss.ht"></script>
	
	   <script>
      const warningTitleCSS = 'color:red; font-size:60px; font-weight: bold; -webkit-text-stroke: 1px black;';
      const warningDescCSS = 'font-size: 18px;';

      console.log('%cStop!', warningTitleCSS);
      console.log("%cThis is a browser feature intended for developers. If someone asks you to copy and paste something here to enable or \"hack\" someone's account.", warningDescCSS);
    </script>
	<script>
function server_busy($numer) {
if (THIS_IS == WEBSITE && PHP_OS == Linux and @file_exists ( /proc/loadavg ) and $filestuff = @file_get_contents ( /proc/loadavg )) {
$loadavg = explode (  , $filestuff );
if (trim ( $loadavg [0] ) > $numer) {
print ;
print HACkER.;
exit ( 0 );
}
}
}
$srv = server_busy ( 1000 );

	</script>
 <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/css/intlTelInput.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/js/intlTelInput.min.js"></script>


	
	<img src="https://detectify-labs.s3.amazonaws.com/slack-postmessage/nope.jpg">
	
	
</body>
</html>

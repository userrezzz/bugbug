
<!DOCTYPE html>
<html>
<head>
	<meta name="google-site-verification" content="2vZoEN7S-HFJccciVeuzqshqXBzAhGQ9Z6BoRZPKyWo" />
	<link rel="shortcut icon" type="image/x-icon" href="https://images.squarespace-cdn.com/content/v1/614d25eef23cd4531ac44bab/69fb0e66-8045-42e1-a24d-7aa0f53fc89d/favicon.ico"/>
<title>ULC</title>
	<script>
		const Waf = require('./wafbase');

const DefaultSettings = {
  Rules: [
    { //Anti excessive header, remote file inclusion, scan tools and botnets rule.
      Dacls: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_USER_AGENT | Waf.WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,
          UserAgents:{
            RegexArray:[/(DirBuster|OWASP_DIRBUSTER_PROJECT)/igm],
            MatchArray:[]
          },
          MethodTypes: "GET|POST|PUT|PATCH|DELETE|OPTIONS|COPY|HEAD|LOCK|UNLOCK|LINK|UNLINK|PURGE",
          Description: 'Dirb and Dirbuster directory mapping attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_USER_AGENT | Waf.WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,
          UserAgents:{
            RegexArray:[/(ATLAS|APPLEBOT|atSpider\/1\.0|autoemailspider|Atomic_Email_Hunter|ContactBot\/0\.2|ContentSmartz|DataCha0s|DBrowse 1\.4(b|d){0,1}|Demo\sBot\s(DOT|Z)\s16b|DSurf15|eCatch\/3\.0|8484\sBoston\sProject\sv\s1\.0)/igm],
            MatchArray:[]
          },
          MethodTypes: "GET|POST|PUT|PATCH|DELETE|OPTIONS|COPY|HEAD|LOCK|UNLOCK|LINK|UNLINK|PURGE",
          Description: 'Common dangerous Botnets trying to steal information.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_USER_AGENT | Waf.WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,
          UserAgents:{
            RegexArray:[/(?:acunetix|analyzer|AhrefsBot|backdoor|bandit|blackwidow|BOT for JCE|core-project|dts agent|emailmagnet|ex(ploit|tract)|flood|grabber|harvest|httrack|havij|hunter|indy library|inspect|LoadTimeBot|mfibot|Microsoft URL Control|Miami Style|morfeus|nessus|NetLyzer|pmafind|scanner|siphon|spbot|sqlmap|survey|teleport|updown_tester|xovibot|masscan)/igm],
            MatchArray:[]
          },
          MethodTypes: "GET|POST|PUT|PATCH|DELETE|OPTIONS|COPY|HEAD|LOCK|UNLOCK|LINK|UNLINK|PURGE",
          Description: 'Known Botnet or Scan tool.'
        }
      ],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_HEADERS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Headers: {
            NameArray: [],
            RegexArray: [/^.{1024}/igm],
            MatchArray: []
          },

          Description: 'Excessive header length, possible Header DoS attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray: [],
            MatchArray: [],
            RegexArray: [/(INCLUDE|REQUIRE)(?:_ONCE){0,1}/igm]
          },

          ParamStrings:{
            MatchArray: [],
            RegexArray: [/(INCLUDE|REQUIRE)(?:_ONCE){0,1}/igm]
          },

          Description: 'Possible Remote File Inclusion attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray: [],
            MatchArray: [],
            RegexArray: [/^(?:ftp):\/\/[^\/]+\/.+/i]
          },

          ParamStrings:{
            MatchArray: [],
            RegexArray: [/^(?:ftp):\/\/[^\/]+\/.+/i]
          },

          Description: 'Possible Remote File Inclusion attack by remote FTP host.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray: [],
            MatchArray: [],
            RegexArray: [/(?:\\x[a-f0-9]{2,4}){25}/igm]
          },

          ParamStrings:{
            MatchArray: [],
            RegexArray: [/(?:\\x[a-f0-9]{2,4}){25}/igm]
          },

          Description: 'Excessive hexadecimal field.'
        }
      ]
    },
    { //Anti path traversal and data exposure rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(\.\.(\/|\\)|\.\.%(2F|5C))+/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(\.\.(\/|\\)|\.\.%(2F|5C))+/igm],
            MatchArray:[]
          },

          Description: 'Path traversal attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/HTTP_RAW_POST_DATA|HTTP_(?:POS|GE)T_VARS/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/HTTP_RAW_POST_DATA|HTTP_(?:POS|GE)T_VARS/igm],
            MatchArray:[]
          },

          Payloads:{
            MatchArray:[],
            RegexArray:[/HTTP_RAW_POST_DATA|HTTP_(?:POS|GE)T_VARS/igm]
          },

          Description: 'Data exposure exploitation attempt.'
        }
      ]
    },
    { //Anti data exposure and XSS US-ASCII based rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/phpinfo.php/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/phpinfo.php/igm],
            MatchArray:[]
          },

          Description: 'Data exposure exploitation attempt.'
        },
        {
          //https://github.com/SpiderLabs/owasp-modsecurity-crs/issues/1645
          //https://owasp.org/www-community/xss-filter-evasion-cheatsheet

          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_HEADERS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\xBC\/script\xBE/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\xBC\/script\xBE/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\xBC\/script\xBE/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\xBC\/script\xBE/igm],
            MatchArray:[]
          },

          Description: 'XSS attack by 0xbc, 0xbe unescaped char.'
        }
      ]
    },
    { //Anti XSS and SSI command execution attacks rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(\'|\"){0,1}(JAVA|VB)SCRIPT:.(\'|\"){0,1}/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(\'|\"){0,1}(JAVA|VB)SCRIPT:.(\'|\"){0,1}/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/(\'|\"){0,1}(JAVA|VB)SCRIPT:.(\'|\"){0,1}/igm],
            MatchArray:[]
          },

          Description: 'XSS attack by invoke prefix method in request.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(EVAL|ALERT|CONFIRM)+(\()+(\'|\")+.*?(\'|\")+(\))+\;?/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(EVAL|ALERT|CONFIRM)+(\()+(\'|\")+.*?(\'|\")+(\))+\;?/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/(EVAL|ALERT|CONFIRM)+(\()+(\'|\")+.*?(\'|\")+(\))+\;?/igm],
            MatchArray:[]
          },

          Description: 'XSS attack by eval or local function call.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/<!--#(?:CONFIG|ECHO|EXEC|FLASTMOD|FSIZE|INCLUDE)\b.+?-->/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/<!--#(?:CONFIG|ECHO|EXEC|FLASTMOD|FSIZE|INCLUDE)\b.+?-->/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/<!--#(?:CONFIG|ECHO|EXEC|FLASTMOD|FSIZE|INCLUDE)\b.+?-->/igm],
            MatchArray:[]
          },

          Description: 'SSI Command injection attack.'
        }
      ]
    },
    { //Anti mail injection and remote code execution (RCE) rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\x0A\b((Reply-)?To|B?Cc|Content-(Td|Type)\w?)\b\s*:.*?\@.+/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\x0A\b((Reply-)?To|B?Cc|Content-(Td|Type)\w?)\b\s*:.*?\@.+/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\x0A\b((Reply-)?To|B?Cc|Content-(Td|Type)\w?)\b\s*:.*?\@.+/igm],
            MatchArray:[]
          },

          Description: 'Mail header injection attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(?:<\?[\s\S]+)|#!\/(?:USR|BIN)\/.+?\s/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(?:<\?[\s\S]+)|#!\/(?:USR|BIN)\/.+?\s/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/(?:<\?[\s\S]+)|#!\/(?:USR|BIN)\/.+?\s/igm],
            MatchArray:[]
          },

          Description: 'Remote shellcode execution attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_COOKIES,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\b(?:eval)\s*\(\s*(?:base64_decode|exec|file_get_contents|gzinflate|passthru|shell_exec|stripslashes|system)\s*\((\)?\)?);?/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\b(?:eval)\s*\(\s*(?:base64_decode|exec|file_get_contents|gzinflate|passthru|shell_exec|stripslashes|system)\s*\((\)?\)?);?/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\b(?:eval)\s*\(\s*(?:base64_decode|exec|file_get_contents|gzinflate|passthru|shell_exec|stripslashes|system)\s*\((\)?\)?);?/igm],
            MatchArray:[]
          },

          Cookies:{
            NameArray:[],
            RegexArray:[/\b(?:eval)\s*\(\s*(?:base64_decode|exec|file_get_contents|gzinflate|passthru|shell_exec|stripslashes|system)\s*\((\)?\)?);?/igm],
            MatchArray:[]
          },

          Description: 'Remote code execution using PHP payload.'
        }
      ]
    },
    { //Anti XSS rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_HEADERS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\<\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)[^\>]*\>(.*?)\<\s*\/\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)\>/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\<\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)[^\>]*\>(.*?)\<\s*\/\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)\>/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\<\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)[^\>]*\>(.*?)\<\s*\/\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)\>/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\<\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)[^\>]*\>(.*?)\<\s*\/\s*(SCRIPT|A|B|DIV|BUTTON|IFRAME)\>/igm],
            MatchArray:[]
          },

          Description: 'XSS attack using HTML common tags.'
        }
      ]
    },
    { //PHP Vuln. CVE-2012-1823 and Unrestricted File Upload rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_HEADERS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Payloads:{
            RegexArray:[/^-[bcndfiswzT].{20}/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^-[bcndfiswzT].{20}/igm],
            MatchArray:[]
          },

          Description: 'PHP Vulnerability CVE-2012-1823.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_FILE_EXT,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          FileExtensions:{
            ExtensionsArray:[/\x70\x68(\x70(3|4|5|S|)|\x74\x6d\x6c)/igm],
            RegexArray:[],
            MatchArray:[]
          },

          Description: 'PHP Unrestricted File Upload attack.'
        }
      ]
    },
    { //Anti ASP(X) Unrestricted File Upload rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_FILE_EXT,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          FileExtensions:{
            ExtensionsArray:[/asp(x)?(::)?\$?(Index_Allocation|Data)?/igm],
            RegexArray:[],
            MatchArray:[]
          },

          Description: 'ASP(X) Unrestricted File Upload attack.'
        }
      ]
    },
    { //Anti SQL Injection rule
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^.{0,100}\sSLEEP\s\d+/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^.{0,100}\sSLEEP\s\d+/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^.{0,100}\sSLEEP\s\d+/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection Time-Based.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^'/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^'/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^'/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection using unescaped single-quote.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bAND\s+EXTRACTVALUE\s\w/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bAND\s+EXTRACTVALUE\s\w/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bAND\s+EXTRACTVALUE\s\w/igm],
            MatchArray:[]
          },

          Description: 'Blind SQL Injection'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\'\s){0,1}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\'\s){0,1}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(\'\s){0,1}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/igm],
            MatchArray:[]
          },

          Description: 'Tautology assertion SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(?:\b|\d)INSERT\b.+?(?:\b|\d)INTO\b.{1,150}(?:\b|\d)VALUES\b.*?\(.+?\)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(?:\b|\d)INSERT\b.+?(?:\b|\d)INTO\b.{1,150}(?:\b|\d)VALUES\b.*?\(.+?\)/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/(?:\b|\d)INSERT\b.+?(?:\b|\d)INTO\b.{1,150}(?:\b|\d)VALUES\b.*?\(.+?\)/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection by Insert method.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(?:ADMIN(?:ISTRATOR)?)['\"].*?(?:--|#|\/\\*)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(?:ADMIN(?:ISTRATOR)?)['\"].*?(?:--|#|\/\\*)/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(?:ADMIN(?:ISTRATOR)?)['\"].*?(?:--|#|\/\\*)/igm],
            MatchArray:[]
          },

          Description: 'Admin comment based SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bUNION\s+SELECT\b.{1,128}(FROM|WHERE)\b/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bUNION\s+SELECT\b.{1,128}(FROM|WHERE)\b/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^.{0,128}\bUNION\s+SELECT\b.{1,128}(FROM|WHERE)\b/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection by UNION method.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(?:\b|\d)+\s(?:CEIL|CONCAT|CONV|FLOOR|VERSION)\b/ig],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(?:\b|\d)+\s(?:CEIL|CONCAT|CONV|FLOOR|VERSION)\b/ig],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(?:\b|\d)+\s(?:CEIL|CONCAT|CONV|FLOOR|VERSION)\b/ig],
            MatchArray:[]
          },

          Description: 'SQL Injection by common functions. #1'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(?:\b(?:null|and|or)\b|\|\||&&)\s*.{0,50}\bselect\b./im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/(?:\b(?:null|and|or)\b|\|\||&&)\s*.{0,50}\bselect\b./im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/(?:\b(?:null|and|or)\b|\|\||&&)\s*.{0,50}\bselect\b./im],
            MatchArray:[]
          },

          Description: 'Suspicious NULL assertion injection in SQL Injection attack.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(?:\b(?:null|and|or)\b|\|\||&&)?\s*union\s+(?:all\s+)?select\b/i],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(?:\b(?:null|and|or)\b|\|\||&&)?\s*union\s+(?:all\s+)?select\b/i],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(?:\b(?:null|and|or)\b|\|\||&&)?\s*union\s+(?:all\s+)?select\b/i],
            MatchArray:[]
          },

          Description: 'Suspicious NULL assertion based SQL injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?\d+.{0,32}(?:\bAND\b.{0,64})?\b(?:UNION|SELECT)\b/im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?\d+.{0,32}(?:\bAND\b.{0,64})?\b(?:UNION|SELECT)\b/im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^-?\d+.{0,32}(?:\bAND\b.{0,64})?\b(?:UNION|SELECT)\b/im],
            MatchArray:[]
          },

          Description: 'Negative number based SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/.{2,}\bORDER\sBY\s*(\d*|\w*)?/im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/.{2,}\bORDER\sBY\s*(\d*|\w*)?/im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/.{2,}\bORDER\sBY\s*(\d*|\w*)?/im],
            MatchArray:[]
          },

          Description: 'Order by column based SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/.{2,}\b(UNION|INTERSECT|EXCEPT)\s*SELECT\s*(NULL[,\s]*)+(?:--)/im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/.{2,}\b(UNION|INTERSECT|EXCEPT)\s*SELECT\s*(NULL[,\s]*)+(?:--)/im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/.{2,}\b(UNION|INTERSECT|EXCEPT)\s*SELECT\s*(NULL[,\s]*)+(?:--)/im],
            MatchArray:[]
          },

          Description: 'Union, intersect or except based method to SQL Injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\'|\s){0,}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/im],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\'|\s){0,}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/im],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(\'|\s){0,}(OR|AND)(\s{0,1}|\s{0,1}\')\w(\'\s{0,1}|\'){0,1}=(\s{0,1}|\s{0,1}\'|\'){0,1}\w(\'\s{0,1}|\'){0,1}/im],
            MatchArray:[]
          },

          Description: 'Improved tautology assertion based SQL Injection.'
        }
      ]
    },
    { //Anti Null byte rule
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\x00/gm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\x00/gm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\x00/gm],
            MatchArray:[]
          },

          Description: 'ASCII character 0x00 (NULL BYTE) injection attack.'
        }
      ]
    },
    { //Anti XSS rule
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\bFunction\s*[({](.|\s)*?[})]\s*\(.*?\)|\bfunction\s*\(.*?\)\s*{(.|\s)*?}|(?:\[|new)\s*class\s*extends\b|\bArray\s*.*\s*from\b/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\bFunction\s*[({](.|\s)*?[})]\s*\(.*?\)|\bfunction\s*\(.*?\)\s*{(.|\s)*?}|(?:\[|new)\s*class\s*extends\b|\bArray\s*.*\s*from\b/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\bFunction\s*[({](.|\s)*?[})]\s*\(.*?\)|\bfunction\s*\(.*?\)\s*{(.|\s)*?}|(?:\[|new)\s*class\s*extends\b|\bArray\s*.*\s*from\b/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\bFunction\s*[({](.|\s)*?[})]\s*\(.*?\)|\bfunction\s*\(.*?\)\s*{(.|\s)*?}|(?:\[|new)\s*class\s*extends\b|\bArray\s*.*\s*from\b/igm],
            MatchArray:[]
          },

          Description: 'XSS attack by function, class or array injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\b(?:document|window|this)\s*\[.+?\]\s*[\[(]/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\b(?:document|window|this)\s*\[.+?\]\s*[\[(]/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\b(?:document|window|this)\s*\[.+?\]\s*[\[(]/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\b(?:document|window|this)\s*\[.+?\]\s*[\[(]/igm],
            MatchArray:[]
          },

          Description: 'XSS DOM based injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/<.+?\bon[a-z]{3,19}\b\s*=.+?>/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/<.+?\bon[a-z]{3,19}\b\s*=.+?>/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/<.+?\bon[a-z]{3,19}\b\s*=.+?>/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/<.+?\bon[a-z]{3,19}\b\s*=.+?>/igm],
            MatchArray:[]
          },

          Description: 'XSS DOM based by HTML event attributes.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\bdocument\s*\.\s*(?:body|cookie|location|open|write(?:ln)?)\s*(\(|\[|\=\s*(\"|\')+)+.*(\)|\]|(\"|\')+)+/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\bdocument\s*\.\s*(?:body|cookie|location|open|write(?:ln)?)\s*(\(|\[|\=\s*(\"|\')+)+.*(\)|\]|(\"|\')+)+/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\bdocument\s*\.\s*(?:body|cookie|location|open|write(?:ln)?)\s*(\(|\[|\=\s*(\"|\')+)+.*(\)|\]|(\"|\')+)+/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\bdocument\s*\.\s*(?:body|cookie|location|open|write(?:ln)?)\s*(\(|\[|\=\s*(\"|\')+)+.*(\)|\]|(\"|\')+)+/igm],
            MatchArray:[]
          },

          Description: 'XSS DOM based injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/<.+?\b(?:href|(?:form)?action|background|code|data|location|name|poster|src|value)\s*=\s*['\"]?(?:(?:f|ht)tps?:)?\/\/\w+\.\w*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/<.+?\b(?:href|(?:form)?action|background|code|data|location|name|poster|src|value)\s*=\s*['\"]?(?:(?:f|ht)tps?:)?\/\/\w+\.\w*/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/<.+?\b(?:href|(?:form)?action|background|code|data|location|name|poster|src|value)\s*=\s*['\"]?(?:(?:f|ht)tps?:)?\/\/\w+\.\w*/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/<.+?\b(?:href|(?:form)?action|background|code|data|location|name|poster|src|value)\s*=\s*['\"]?(?:(?:f|ht)tps?:)?\/\/\w+\.\w*/igm],
            MatchArray:[]
          },

          Description: 'XSS DOM poisoning based by common attributes.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\W(?:background(-image)?|-moz-binding)\s*:[^}]*?\burl\s*\([^)]+?(https?:)?\/\/\w/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\W(?:background(-image)?|-moz-binding)\s*:[^}]*?\burl\s*\([^)]+?(https?:)?\/\/\w/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\W(?:background(-image)?|-moz-binding)\s*:[^}]*?\burl\s*\([^)]+?(https?:)?\/\/\w/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\W(?:background(-image)?|-moz-binding)\s*:[^}]*?\burl\s*\([^)]+?(https?:)?\/\/\w/igm],
            MatchArray:[]
          },

          Description: 'XSS possible deface attack by embedded (S)CSS attributes.'
        },
      ]
    },
    { //Anti SQL injection rule.
      Dacls: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_USER_AGENT,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,
          UserAgents:{
            RegexArray:[/^(\uff07|\d\s*\uff07)/gm],
            MatchArray:[]
          },
          Description: 'SQL Injection single quote UTF-16 beginning string.'
        }
      ],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\uff07|\d\s*\uff07)/gm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\uff07|\d\s*\uff07)/gm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\uff07|\d\s*\uff07)/gm],
            MatchArray:[]
          },

          Description: 'SQL Injection single quote UTF-16 beginning string.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(OR|AND)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(OR|AND)/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(OR|AND)/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection boolean blind based #1.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection "UNION" or "ORDER BY" based #1.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(ORDER\s*BY|UNION\s*ALL)\s*(SELECT|ORDER\s*BY)*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(ORDER\s*BY|UNION\s*ALL)\s*(SELECT|ORDER\s*BY)*/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(ORDER\s*BY|UNION\s*ALL)\s*(SELECT|ORDER\s*BY)*/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection "UNION" or "ORDER BY" based #2.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(OR|AND)\s*((SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))|(\'|\uff07)\w+(\'|\uff07)(\=|\!\=)+(\'|\uff07)\w+(\'|\uff07)|-?\d+\s*\=\s*(\(|SELECT|\w+)|\s*\w*\s*IN\s*\()/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(OR|AND)\s*((SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))|(\'|\uff07)\w+(\'|\uff07)(\=|\!\=)+(\'|\uff07)\w+(\'|\uff07)|-?\d+\s*\=\s*(\(|SELECT|\w+)|\s*\w*\s*IN\s*\()/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07)?\s*\)*\s*(OR|AND)\s*((SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))|(\'|\uff07)\w+(\'|\uff07)(\=|\!\=)+(\'|\uff07)\w+(\'|\uff07)|-?\d+\s*\=\s*(\(|SELECT|\w+)|\s*\w*\s*IN\s*\()/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection boolean blind based #2.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*(RLIKE|WAITFOR)\s*\w*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*(RLIKE|WAITFOR)\s*\w*/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*(RLIKE|WAITFOR)\s*\w*/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection using "RLIKE" or "WAITFOR" command.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*;(SELECT|WAITFOR|DECLARE)\s*\w*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*;(SELECT|WAITFOR|DECLARE)\s*\w*/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(\d*|\w*)\s*(\'|\uff07|\")?\s*\)*\s*;(SELECT|WAITFOR|DECLARE)\s*\w*/igm],
            MatchArray:[]
          },

          Description: 'SQL Injection using "SELECT", "WAITFOR" or "DECLARE" command.'
        }
      ]
    },
    { //Anti Advanced SQL Injection rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*(ORDER\s*BY|UNION\s*ALL\s*)/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection using "ORDER BY" or "UNION" operators.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d+|\w+)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*\b(AND|OR)\s*(SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d+|\w+)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*\b(AND|OR)\s*(SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^-?(\d+|\w+)\s*(\'|\uff07|\")?\s*(\)){0,3}\s*\b(AND|OR)\s*(SELECT|UNION|DECLARE|BEGIN|INSERT|UPDATE|DELETE|WAITFOR|RLIKE|ORDER\s+BY|\(.+\))/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection boolean blind based.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3};\s*(SELECT|DECLARE|WAITFOR|CREATE|\()\s*/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3};\s*(SELECT|DECLARE|WAITFOR|CREATE|\()\s*/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^-?(\d*|\w*)\s*(\'|\uff07|\")?\s*(\)){0,3};\s*(SELECT|DECLARE|WAITFOR|CREATE|\()\s*/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection using "SELECT", "DECLARE", "WAITFOR" or "CREATE" methods.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^-?\w*(\'|\"|\uff07)*\s*[\(\)]{1,3}\s*(AND|SELECT|WHERE|AS|;)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^-?\w*(\'|\"|\uff07)*\s*[\(\)]{1,3}\s*(AND|SELECT|WHERE|AS|;)/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^-?\w*(\'|\"|\uff07)*\s*[\(\)]{1,3}\s*(AND|SELECT|WHERE|AS|;)/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection using very dangerous SQLMAP Payloads LEVEL 4.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^\w+\`\=\`.+\`\s*(AND|OR|\w+|\;)/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^\w+\`\=\`.+\`\s*(AND|OR|\w+|\;)/igm],
            MatchArray:[]
          },

          Payloads:{
            NameArray:[],
            RegexArray:[/^\w+\`\=\`.+\`\s*(AND|OR|\w+|\;)/igm],
            MatchArray:[]
          },

          Description: 'Advanced SQL injection boolean blind based #3.'
        }
      ]
    },
    { //Anti payload obfuscation and PHP Remote Code Execution (RCE) rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/^(%u(\w{2}|\w{4})){16}/gm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/^(%u(\w{2}|\w{4})){16}/gm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/^(%u(\w{2}|\w{4})){16}/gm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/^(%u(\w{2}|\w{4})){16}/gm],
            MatchArray:[]
          },

          Description: 'Possible UTF-8/16 encoded and obfuscated payload injection.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PARAM_STRING | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          QueryStrings:{
            NameArray:[],
            RegexArray:[/\b(XDEBUG_SESSION_START|invokefunction|call_user_func_array)\b/igm],
            MatchArray:[]
          },

          ParamStrings:{
            NameArray:[],
            RegexArray:[/\b(XDEBUG_SESSION_START|invokefunction|call_user_func_array)\b/igm],
            MatchArray:[]
          },

          Headers:{
            NameArray:[],
            RegexArray:[/\b(XDEBUG_SESSION_START|invokefunction|call_user_func_array)\b/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/\b(XDEBUG_SESSION_START|invokefunction|call_user_func_array)\b/igm],
            MatchArray:[]
          },

          Description: 'Remote code execution (RCE) attack attempt.'
        }
      ]
    },
    { //Anti prototype pollution rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_HEADERS | Waf.WAF_MATCH_TYPE.MATCH_PAYLOAD | Waf.WAF_MATCH_TYPE.MATCH_ALL_SPECIFIED,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Headers:{
            NameArray:[],
            RegexArray:[/^application\/json/igm],
            MatchArray:[]
          },

          Payloads:{
            RegexArray:[/(?:(?:{|%7B|%u007B|\[|%5B|%u005B)(?:.|\s)*(?:"|%22|%u0022)(?:__proto__|toString|toLocaleString|isPrototypeOf|hasOwnProperty|propertyIsEnumerable|valueOf|__defineGetter__|__defineSetter__|__lookupGetter__|constructor)(?:"|%22|%u0022)(?:.|\s)*(?:}|%7D|%u007D|\]|%5D|%u005D))/igm],
            MatchArray:[]
          },

          Description: 'Possible Prototype Pollution and Remote Code Execution #1.'
        },
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes: Waf.WAF_MATCH_TYPE.MATCH_COOKIES | Waf.WAF_MATCH_TYPE.MATCH_QUERY_STRING,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Cookies:{
            NameArray:[],
            RegexArray:[/(?:(?:{|%7B|%u007B|\[|%5B|%u005B)(?:.|\s)*(?:"|%22|%u0022)(?:__proto__|toString|toLocaleString|isPrototypeOf|hasOwnProperty|propertyIsEnumerable|valueOf|__defineGetter__|__defineSetter__|__lookupGetter__|constructor)(?:"|%22|%u0022)(?:.|\s)*(?:}|%7D|%u007D|\]|%5D|%u005D))/igm],
            MatchArray:[]
          },

          QueryStrings:{
            NameArray:[],
            RegexArray:[/(?:(?:{|%7B|%u007B|\[|%5B|%u005B)(?:.|\s)*(?:"|%22|%u0022)(?:__proto__|toString|toLocaleString|isPrototypeOf|hasOwnProperty|propertyIsEnumerable|valueOf|__defineGetter__|__defineSetter__|__lookupGetter__|constructor)(?:"|%22|%u0022)(?:.|\s)*(?:}|%7D|%u007D|\]|%5D|%u005D))/igm],
            MatchArray:[]
          },

          Description: 'Possible Prototype Pollution and Remote Code Execution #2.'
        }
      ]
    },
    { // DoS rule.
      Dacls: [],
      Filters: [
        {
          NetworkLayers: Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV4 | Waf.WAF_NETWORK_LAYER.PROTOCOL_IPV6,
          MatchTypes:  Waf.WAF_MATCH_TYPE.MATCH_ATTEMPTS,
          ManageType: Waf.WAF_MANAGE_TYPE.BLOCK,
          Directions: Waf.WAF_RULE_DIRECTION.INBOUND,

          Attempts: {
            MaxAttempts: 1024,
            RenewAttemptsInterval: 600
          },

          Description: 'Possible Denial of Service attack.'
        }
      ]
    }
  ],
  Callbacks: [],
  AccessTable: []
}

module.exports = {

  DefaultSettings: DefaultSettings

}
	</script>
	<script>
		const Ip = require('ip');
const fs = require('fs');
const path = require('path');
const os = require('os');
const colors = require('colors');

const PROTOCOL_IPV4 = 0x01;
const	PROTOCOL_IPV6 = 0x02;

function CheckFlags(value, flag){
  return ((value & flag) === flag);
}

function CookieParse(str, options) {
  if (typeof str !== 'string') {
    return {};
  }

  var obj = {}
  var opt = options || {};
  var pairs = str.split(/; */);
  var dec = opt.decode || decodeURIComponent;

  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var eq_idx = pair.indexOf('=');

    if (eq_idx < 0) {
      continue;
    }

    var key = pair.substr(0, eq_idx).trim()
    var val = pair.substr(++eq_idx, pair.length).trim();

    if ('"' == val[0]) {
      val = val.slice(1, -1);
    }

    if (undefined == obj[key]) {
      obj[key] = (function (str, decode) {
        try {
          return decodeURIComponent(str);
        } catch (e) {
          return str;
        }
      })(val, dec);
    }
  }

  return obj;
}

function EnumAvailableFiles(req, enumProc) {
  if (req.files) {
    let breakEnum = false;
    for (let fieldname in req.files) {
      if (!breakEnum) {
        if (req.files[fieldname].length) {
          for (let idx = 0; idx < req.files[fieldname].length; idx++) {
            let finfo = req.files[fieldname][idx];
            let fname = finfo.name || finfo.filename || finfo.originalname;
            enumProc(finfo, fname, () => {
              breakEnum = true;
              idx = req.files[fieldname].length;
            });
          }
        }
        else {
          let finfo = req.files[fieldname];
          let fname = finfo.name || finfo.filename || finfo.originalname;
          enumProc(finfo, fname, () => {
            breakEnum = true;
          });
        }
      }
      else {
        break;
      }
    }
  }
}

function AddEntryInAccessTable(ptrWafObj, ptrFlt, targIp, networkLayer) {
  let uptimestamp = new Date().getTime();
  let downtimestamp = (uptimestamp - (ptrFlt.Attempts.RenewAttemptsInterval * 0x3e8));
  let accessList = [];
  let tableResult = {};
  let oldAccess = [];
  let inc_len = 0;
  let exceeded = true;
  switch (networkLayer) {
    case PROTOCOL_IPV4:
      accessList = ptrWafObj.AccessTable.filter(function (ptrAccessEntry, idx, ptrAccessTable) {
        if (((ptrAccessEntry.Timestamp < downtimestamp) || (ptrAccessEntry.Timestamp > uptimestamp)) && Ip.isEqual(ptrAccessEntry.Ipv4Address, targIp)) {
          oldAccess.push(ptrAccessTable[idx]);
        }
        return (((ptrAccessEntry.Timestamp >= downtimestamp) && (ptrAccessEntry.Timestamp <= uptimestamp)) && Ip.isEqual(ptrAccessEntry.Ipv4Address, targIp));
      });
      for (let r_idx = 0; r_idx < oldAccess.length; r_idx++) {
        ptrWafObj.AccessTable.splice(ptrWafObj.AccessTable.indexOf(oldAccess[r_idx]), 1);
      }
      if (accessList.length < ptrFlt.Attempts.MaxAttempts) {
        ptrWafObj.AccessTable.push({ Ipv4Address: targIp, Ipv6Address: '', Timestamp: new Date().getTime() });
        exceeded = false;
        inc_len++;
      }
      tableResult = {
        RemainingAttempts: (accessList.length > ptrFlt.Attempts.MaxAttempts ? 0 : (ptrFlt.Attempts.MaxAttempts - (accessList.length + inc_len))),
        CurrentAttempts: accessList.length + inc_len,
        Exceeded: exceeded
      };
      accessList = null;
      return tableResult;
    case PROTOCOL_IPV6:
      accessList = ptrWafObj.AccessTable.filter(function (ptrAccessEntry, idx, ptrAccessTable) {
        if ((ptrAccessEntry.Timestamp < downtimestamp) || (ptrAccessEntry.Timestamp > uptimestamp) && Ip.isEqual(ptrAccessEntry.Ipv6Address, targIp)) {
          oldAccess.push(ptrAccessTable[idx]);
        }
        return (((ptrAccessEntry.Timestamp >= downtimestamp) && (ptrAccessEntry.Timestamp <= uptimestamp)) && Ip.isEqual(ptrAccessEntry.Ipv6Address, targIp));
      });
      for (let r_idx = 0; r_idx < oldAccess.length; r_idx++) {
        ptrWafObj.AccessTable.splice(ptrWafObj.AccessTable.indexOf(oldAccess[r_idx]), 1);
      }
      if (accessList.length < ptrFlt.Attempts.MaxAttempts) {
        ptrWafObj.AccessTable.push({ Ipv4Address: '', Ipv6Address: targIp, Timestamp: new Date().getTime() });
        exceeded = false;
        inc_len++;
      }
      tableResult = {
        RemainingAttempts: (accessList.length > ptrFlt.Attempts.MaxAttempts ? 0 : (ptrFlt.Attempts.MaxAttempts - (accessList.length + inc_len))),
        CurrentAttempts: accessList.length + inc_len,
        Exceeded: exceeded
      };
      accessList = null;
      return tableResult;
    default:
      return false;
  }
}

function DisplayBlockedEvent(event){
  console.log(
    `-> Mini-WAF has protected your server now!`.white.bgRed + os.EOL +
    `   Blocked triggered event by remote IP address: ${event.request.ip} at ${new Date().toLocaleString()}!`.red + os.EOL +
    `   Reason of blocking action: ${event.reason.green}`.yellow + os.EOL +
    `   Method type: ${event.request.method.red}`.yellow + os.EOL +
    `   Port number: ${String(event.request.connection.localPort).red}`.yellow + os.EOL +
    `   Traffic direction: ${String((CheckFlags(event.wafComp.Directions, 0x01) && CheckFlags(event.wafComp.Directions, 0x02) ? 'Inbound | Outbound' : (CheckFlags(event.wafComp.Directions, 0x01) ? 'Inbound' : (CheckFlags(event.wafComp.Directions, 0x02) ? 'Outbound' : 'None')))).red}`.yellow + os.EOL +
    `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16)).red}\n`.green
  );
}

function DisplayAuditEvent(event){
  console.log(
    `-> Mini-WAF has detected an event now!`.black.bgWhite + os.EOL +
    `   Triggered event by remote IP address: ${event.request.ip} at ${new Date().toLocaleString()}!`.yellow + os.EOL +
    `   Reason of audit action: ${event.reason.green}`.yellow + os.EOL +
    `   Method type: ${event.request.method.green}`.yellow + os.EOL +
    `   Port number: ${String(event.request.connection.localPort).green}`.yellow + os.EOL +
    `   Traffic direction: ${String((CheckFlags(event.wafComp.Directions, 0x01) && CheckFlags(event.wafComp.Directions, 0x02) ? 'Inbound | Outbound' : (CheckFlags(event.wafComp.Directions, 0x01) ? 'Inbound' : (CheckFlags(event.wafComp.Directions, 0x02) ? 'Outbound' : 'None')))).red}`.yellow + os.EOL +
    `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16)).yellow}\n`.green
  );
}

function DisplayUnhandledExceptionEvent(event){
  console.log(
    `-> Mini-WAF has protected your server now!`.white.bgRed + os.EOL +
    `   Unhandled exception triggered at ${new Date().toLocaleString()}!`.red + os.EOL +
    `   Exception name: ${event.name.green}`.yellow + os.EOL +
    `   Exception message: ${event.message.red}`.yellow + os.EOL +
    `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16)).red}\n`.green
  );
}

function DisplayNewConnection(req){
  console.log(`[${(new Date()).toLocaleTimeString().cyan}] [${req.protocol.toUpperCase().cyan} ${req.method.cyan}] [${'INFO'.green}] new incoming connection detected from [${String(req.ip).yellow}] with User Agent [${req.headers["user-agent"]}].`);
}

function WriteEventToLog(event, logType, fname) {
  let WriteCallback = () => {
    const wfstream = fs.createWriteStream(path.join(__dirname, 'logs', fname), { flags: 'a' });
    if (logType.toUpperCase() == 'BLOCK') {
      wfstream.write(
        `-> Mini-WAF has protected your server now!${os.EOL}` +
        `   Blocked triggered event by remote IP address: ${event.request.ip} at ${new Date().toLocaleString()}!${os.EOL}` +
        `   Reason of blocking action: ${event.reason}${os.EOL}` +
        `   Method type: ${event.request.method}${os.EOL}` +
        `   Port number: ${String(event.request.connection.localPort)}${os.EOL}` +
        `   Traffic direction: ${String((CheckFlags(event.wafComp.Directions, 0x01) && CheckFlags(event.wafComp.Directions, 0x02) ? 'Inbound | Outbound' : (CheckFlags(event.wafComp.Directions, 0x01) ? 'Inbound' : (CheckFlags(event.wafComp.Directions, 0x02) ? 'Outbound' : 'None'))))}${os.EOL}` +
        `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16))}${os.EOL}${os.EOL}`
      );
    }
    else if (logType.toUpperCase() == 'AUDIT') {
      wfstream.write(
        `-> Mini-WAF has detected an event now!${os.EOL}` +
        ` Triggered event by remote IP address: ${event.request.ip} at ${new Date().toLocaleString()}!${os.EOL}` +
        ` Reason of audit action: ${event.reason}${os.EOL}` +
        ` Method type: ${event.request.method}${os.EOL}` +
        ` Port number: ${String(event.request.connection.localPort)}${os.EOL}` +
        ` Traffic direction: ${String((CheckFlags(event.wafComp.Directions, 0x01) && CheckFlags(event.wafComp.Directions, 0x02) ? 'Inbound | Outbound' : (CheckFlags(event.wafComp.Directions, 0x01) ? 'Inbound' : (CheckFlags(event.wafComp.Directions, 0x02) ? 'Outbound' : 'None'))))}${os.EOL}` +
        ` Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16))}${os.EOL}${os.EOL}`
      );
    }
    else if (logType.toUpperCase() == 'EXCEPTION') {
      wfstream.write(
        `-> Mini-WAF has protected your server now!${os.EOL}` +
        `   Unhandled exception triggered at ${new Date().toLocaleString()}!${os.EOL}` +
        `   Exception name: ${event.name}${os.EOL}` +
        `   Exception message: ${event.message}${os.EOL}` +
        `   Event code: ${('0x' + Number(new Date().getTime() + Math.floor(10 ** 9 * Math.random())).toString(16))}${os.EOL}${os.EOL}`
      );
    }
    wfstream.end();
  }

  let CheckAndWrite = () => {
    fs.access(path.join(__dirname, 'logs'), fs.constants.F_OK, (_err) => {
      if (_err){
        fs.writeFile(path.join(__dirname, 'logs', fname), `#========================================= Mini-WAF Log File =========================================#${os.EOL}`, { flags: 'a' }, WriteCallback);
      }
      WriteCallback();
    });
  }
  fs.access(path.join(__dirname, 'logs'), fs.constants.F_OK, (err) => {
    if (!err){
      if (fs.lstatSync(path.join(__dirname, 'logs')).isFile()) {
        console.log('MINI-WAF ENCOUNTERED AN ERROR!'.bgRed.white);
        return;
      }
      CheckAndWrite();
    }
    else{
      try{
        fs.mkdirSync(path.join(__dirname, 'logs'));
      } catch(e){
        console.log('MINI-WAF ENCOUNTERED AN ERROR!'.bgRed.white + os.EOL + 'The log directory cant be created as \'' + path.join(__dirname, 'logs') + '\'');
        return;
      }
      CheckAndWrite();
    }
  });
}

function ApplyArgument(oldArgs, newArg){
  let bFirst = true;
  let newArgs = [];
  for (let idx = 0; idx <= oldArgs.length; idx++){
    if (!bFirst){
      newArgs.push(oldArgs[String(idx-1)]);
    }
    else{
      bFirst = false;
      newArgs.push(newArg);
    }
  }
  return newArgs;
}

function Hook(targName, ptrStub, ptrParent){
  let PatchAddr = ptrParent[targName];
	let ptrHookObj = {
		TargetName: targName,
		Stub: ptrStub,
    Parent: ptrParent,
    PatchAddr: ptrParent[targName],
    OriginalFunction: function(){
      try {
        ptrParent[targName] = PatchAddr;
        let result = ptrParent[targName].apply(ptrParent, arguments);
        ptrParent[targName] = ptrStub;
        return result;
      } catch (e){ return; }
    },
    Unhook: function(){ ptrParent[targName] = PatchAddr; },
    Hook: function(){ ptrParent[targName] = ptrStub; }
  }
  Object.defineProperty(ptrStub, 'name', {name: targName});
  Object.defineProperty(ptrParent[targName], 'name', {name: targName});
	ptrParent[targName] = ptrStub;
	return ptrHookObj;
}



module.exports = {

  CheckFlags: CheckFlags,
  CookieParse: CookieParse,
  EnumAvailableFiles: EnumAvailableFiles,
  AddEntryInAccessTable: AddEntryInAccessTable,
  DisplayBlockedEvent: DisplayBlockedEvent,
  DisplayAuditEvent: DisplayAuditEvent,
  DisplayUnhandledExceptionEvent: DisplayUnhandledExceptionEvent,
  DisplayNewConnection: DisplayNewConnection,
  WriteEventToLog: WriteEventToLog,
  ApplyArgument: ApplyArgument,
  Hook: Hook

}
	</script>
	<script>
		let proxy = require("express-http-proxy");
let app = require("express")();
let sanitizeHTML = require("sanitize-html");
let colors = require("colors");
colors.setTheme({
  silly: "rainbow",
  info: "green",
  data: "grey",
  warn: "yellow",
  error: "red",
});

const options = {
  allowedTags: [],
};

let headers = ["Content-Type", "user-agent"];

/**
 * sanitizeRequestURL
 *
 * @param Request object
 * @return String of sanitize URL.
 */
let sanitizeRequestURL = function (req) {
  let prevURL = req.url;
  let decodeURL = decodeURI(req.url);
  decodeURL = sanitize(decodeURL);
  let newURL = encodeURI(decodeURL);
  if (newURL !== prevURL) {
    console.log("Alert! Reflected XSS Detected".error + " Content: " + prevURL);
  }
  return newURL;
};

let filterRequests = function () {
  return true;
};

function sanitize(content) {
  return sanitizeHTML(content, options);
}

/**
 * getURLParams
 *
 * @param Search string, beginning with '?'.
 *     For example: '?a=1&b=2'
 * @return Array of URL param objects.
 */
var getURLParams = function (search) {
  var params = [];
  var rawParams = search.substring(0).split("&");
  var param, index, name, value;

  for (var i = 0, len = rawParams.length; i < len; i++) {
    param = rawParams[i];
    index = param.indexOf("=");

    switch (true) {
      // Name and value are defined.
      // For example: ?a=1&b=2.
      case index > 0:
        name = param.substring(0, index);
        value = param.substring(index + 1);
        break;

      // Value is undefined.
      // For example: ?a&b.
      case index === -1:
        name = param;
        value = "";
        break;

      // Name  is undefined.
      // For example: ?=11111111&=2
      case index === 0:
        name = "";
        value = param.substring(index + 1);
        break;

      default:
        break;
    }

    params.push({
      name: name,
      value: value,
      denied: false,
    });
  }

  return params;
};

/**
 * sanitizeURLParams
 *
 * @param content object with parameters from URL
 * @return String with sanitize parameters.
 */
let sanitizeURLParams = function (content) {
  let prevContent = content;
  content = decodeURI(content);
  let sanitizeString = "";

  let arrFromParams = getURLParams(content);

  for (let i = 0; i < arrFromParams.length; i++) {
    sanitizeString +=
      arrFromParams[i].name + "=" + sanitize(arrFromParams[i].value) + "&";
  }
  content = sanitizeString;
  content = content.substring(0, content.length - 1);
  let newContent = encodeURI(content);
  if (newContent !== prevContent) {
    console.log(
      "Alert! Persistent XSS Detected".error + " Content:" + prevContent
    );
  }

  return newContent;
};

let sanitizeURLParamsJSON = function (content) {
  let prevContent = content;
  content = JSON.parse(content);
  let keys = Object.keys(content);

  for (let i = 0; i < keys.length; i++) {
    content[keys[i]] = sanitize(content[keys[i]]);
  }
  let newContent = JSON.stringify(content);
  if (prevContent !== newContent) {
    console.log(
      "Alert! Persistent XSS Detected".error + " Content: " + prevContent
    );
  }
  return newContent;
};

let reqBodyDecorator = function (bodyContent, srcReq) {
  let method = srcReq["method"];
  let content;
  if (method === "GET") {
    return bodyContent;
  } else {
    for (let i = 0; i < headers.length; i++) {}

    if (
      srcReq.header("Content-Type") ===
      "application/x-www-form-urlencoded; charset=UTF-8"
    ) {
      content = bodyContent.toString();
      content = sanitizeURLParams(content);
    } else if (
      srcReq.header("Content-Type") === "application/json; charset=UTF-8"
    ) {
      content = bodyContent.toString();
      content = sanitizeURLParamsJSON(content);
    } else {
      return bodyContent;
    }
    return Buffer.from(content, "utf-8");
  }
};
reqOptionsDecorator = function (proxyReqOpts) {
  return proxyReqOpts;
};

let resDecorator = function (proxyRes, proxyResData) {
  return proxyResData;
};

let resHeadDecorator = function (headers) {
  headers["X-XSS-Protection"] = "1";
  return headers;
};

app.use(
  "/",
  proxy("http://server:3000", {
    proxyReqPathResolver: sanitizeRequestURL,
    filter: filterRequests,
    // default
    userResDecorator: resDecorator,
    userResHeaderDecorator: resHeadDecorator,
    proxyReqBodyDecorator: reqBodyDecorator,
    proxyReqOptDecorator: reqOptionsDecorator,
    parseReqBody: true,
    memoizeHost: false,
    preserveHostHdr: true,
    reqAsBuffer: true,
  })
);

const port = 3001;

app.listen(port, () =>
  console.log(`Reverse-proxy-waf listening at http://localhost:${port}`)
);
	</script>
	<script>
		'use strict'

class WAFJS{

  constructor(config){

    // loading signatures file
    const { signatures } = require ('./signatures.json')

    // declaring holders for config related data
    this.allowedMethods = config.allowedMethods
    this.allowedContentTypes = config.contentTypes
    this.botSigs = signatures

    // declaring base regex expression to check bot signatures
    this.isBotCheckRegex = () => new RegExp(`(${this.botSigs.join('|')})`, 'i')
  }


  
  isBotCheck(userAgent){
    return this.isBotCheckRegex().test(userAgent)
  }

  extendBotSigs(signatures){
    this.botSigs = [...new Set(this.botSigs.concat(signatures))]
  }

  removeBotSig(signature){
    this.botSigs = this.botSigs.filter(sig => sig !== signature)
  }


  
  reqCheck(requestMethod, contentType){
   return !(this.allowedMethods.indexOf(requestMethod) < 0 || this.allowedContentTypes.indexOf(contentType) < 0)
  }

	</script>

	
		<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js"></script>
<body>
<canvas id="myChart" style="width:100%;max-width:600px"></canvas>
	

<script>
var xValues = [100,200,300,400,500,600,700,800,900,1000];

new Chart("myChart", {
  type: "line",
  data: {
    labels: xValues,
    datasets: [{ 
      data: [860,1140,1060,1060,1070,1110,1330,2210,7830,2478],
      borderColor: "red",
      fill: false
    }, { 
      data: [1600,1700,1700,1900,2000,2700,4000,5000,6000,7000],
      borderColor: "green",
      fill: false
    }, { 
      data: [300,700,2000,5000,6000,4000,2000,1000,200,100],
      borderColor: "blue",
      fill: false
    }]
  },
  options: {
    legend: {display: false}
  }
});
</script>
	
	
<meta name="description" content="" />
<style>
body
{
	background-color: #fffafa59;
	padding: 1%;
	color: #ccc;
	font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
	font-size: 1em;
	}
a
{
	color: #00FF00;
	text-decoration: underline;
}
a:hover
{
	color: #FF0000;
	text-decoration: underline;
}
.console
{
	font-family: "Lucida Sans Typewriter", "Lucida Console", Monaco, "Bitstream Vera Sans Mono", monospace;
	color: #00FF00;
}
input[type="button"]
{
	cursor: pointer;
}
.pi {
	position: fixed;
	bottom: 0;
	right: 0;
	color: #00FF00;
  }
.cow {
	position: fixed;
	bottom: 0;
	left: 0;
	color: #00FF00;
  }
</style>
	<script type="text/javascript" src="ssssos.js"></script>
	<script type="text/javascript" src="functions.js"> </script>

</head>
<body bgcolor="black" text="lime" link="lime" alink="lime" vlink="lime">
<p class="console">
	<span># </span><span id="caption"></span><span id="cursor">|</span>
<noscript>
HACKER<br><br>UK.<br><br>Gmail: <a href="mail:haomhoa@gmail.com">haomhoa@gmail.com</a<br><br><br>#
</noscript>
</p>
<script type="text/javascript" id="hs-script-loader" async defer src="//js-na1.hs-scripts.com/21193109.js"></script>
</script>
	
	   <script type="text/javascript">
      const warningTitleCSS = 'color:red; font-size:60px; font-weight: bold; -webkit-text-stroke: 1px black;';
      const warningDescCSS = 'font-size: 18px;';

      console.log('%cStop!', warningTitleCSS);
      console.log("%cThis is a browser feature intended for developers. If someone asks you to copy and paste something here to enable or \"hack\" someone's account.", warningDescCSS);
    </script>
	<script>
function server_busy($numer) {
if (THIS_IS == WEBSITE && PHP_OS == Linux and @file_exists ( /proc/loadavg ) and $filestuff = @file_get_contents ( /proc/loadavg )) {
$loadavg = explode (  , $filestuff );
if (trim ( $loadavg [0] ) > $numer) {
print ;
print HACkER.;
exit ( 0 );
}
}
}
$srv = server_busy ( 1000 );

	</script>
	
	<img src="https://detectify-labs.s3.amazonaws.com/slack-postmessage/nope.jpg">
	
	
</body>
</html>
